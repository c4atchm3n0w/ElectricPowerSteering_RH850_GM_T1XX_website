---
title: CM103A_RamMem
linkTitle: CM103A_RamMem
weight: 2
---

<p><strong>RAM Memory RH850</strong></p>
<p><strong>(RamMem)</strong></p>
<p><strong>FDD CM103A</strong></p>
<p><a href="#high-level-description">1. High Level Description 3</a></p>
<p><a href="#sub-functions-in-this-document">2. Sub-Functions In This Document 4</a></p>
<p><a href="#critical-registers">3. Critical Registers 5</a></p>
<p><a href="#sub-functions">4. Sub-functions 6</a></p>
<p><a href="#sub-function-ram-ntcs-initialization">4.1. Sub-Function: RAM NTCs Initialization 6</a></p>
<p><a href="#ntcs">4.1.1. NTCs 6</a></p>
<p><a href="#san-linkage">4.1.2. SAN Linkage 6</a></p>
<p><a href="#description">4.1.3. Description 6</a></p>
<p><a href="#rationale">4.1.4. Rationale 7</a></p>
<p><a href="#implementation">4.1.5. Implementation 7</a></p>
<p><a href="#reference-registers">4.1.6. Reference Registers 7</a></p>
<p><a href="#verification-method">4.1.7. Verification Method 7</a></p>
<p><a href="#sub-function-ram-ecc--2-bit-and-address-parity-faults">4.2. Sub-Function: RAM ECC -2 Bit and Address Parity Faults 7</a></p>
<p><a href="#ntcs-1">4.2.1. NTCs 8</a></p>
<p><a href="#san-linkage-1">4.2.2. SAN Linkage 8</a></p>
<p><a href="#description-1">4.2.3. Description 8</a></p>
<p><a href="#rationale-1">4.2.4. Rationale 8</a></p>
<p><a href="#__RefHeading___Toc451438549">4.2.5. Implementation 8</a></p>
<p><a href="#reference">4.2.6. Reference 10</a></p>
<p><a href="#verification-method-1">4.2.7. Verification Method 12</a></p>
<p><a href="#sub-function-local-ram-ecc---1-bit">4.3. Sub-Function: Local RAM ECC - 1 Bit 13</a></p>
<p><a href="#ntcs-2">4.3.1. NTCs 13</a></p>
<p><a href="#san-linkage-2">4.3.2. SAN Linkage 13</a></p>
<p><a href="#description-2">4.3.3. Description 13</a></p>
<p><a href="#rationale-2">4.3.4. Rationale 13</a></p>
<p><a href="#implementation-1">4.3.5. Implementation 14</a></p>
<p><a href="#reference-registers-1">4.3.6. Reference Registers 20</a></p>
<p><a href="#verification-method-2">4.3.7. Verification Method 23</a></p>
<p><a href="#sub-function-i-cache-ecc-setting-the-ntcs">4.4. Sub-Function: I-Cache ECC &amp; Setting the NTCs 24</a></p>
<p><a href="#ntcs-3">4.4.1. NTCs 24</a></p>
<p><a href="#san-linkage-3">4.4.2. SAN Linkage 24</a></p>
<p><a href="#description-3">4.4.3. Description 25</a></p>
<p><a href="#rationale-3">4.4.4. Rationale 25</a></p>
<p><a href="#implementation-2">4.4.5. Implementation 26</a></p>
<p><a href="#reference-registers-2">4.4.6. Reference Registers 33</a></p>
<p><a href="#verification-method-3">4.4.7. Verification Method 37</a></p>
<p><a href="#revision-record-change-approval">5. Revision Record &amp; Change Approval 38</a></p>
<h1 id="high-level-description">High Level Description</h1>
<p>This document describes the diagnostics configuration for all RAM memory in the RH850 based design. RAM initialization is also included in this document.</p>
<p><strong>Local RAM:</strong></p>
<p>PE1 is capable of simultaneously writing or reading up to 128 bits of data at a time to or from the local RAM. Meanwhile, ECC bits are provided for each 32 bits of data and the locations for storage of each 32-bit data segment are referred to as banks 0 to 3.</p>
<ul>
<li><p>ECC error detection and correction are carried out (2-bit error detection and 1-bit error detection and correction are carried out)</p></li>
</ul>
<p>A status register is provided, which indicates the status of 2-bit ECC error detection and 1- bit ECC error detection. If an error occurs while no error status is set, the corresponding status is set. The error status can be cleared using the clear register.</p>
<p><strong>Instruction Cache RAM:</strong></p>
<p>ECC error detection and correction can be either enabled or disabled.</p>
<p>When enabled, either of the following settings can be selected.</p>
<ul>
<li><p>For instruction cache (data), ECC error detection and correction are carried out (2- bit error detection and 1-bit error detection and correction) or ECC error detection is carried out (2-bit error detection and 1-bit error detection).</p></li>
<li><p>For instruction cache (TAG), ECC error detection is carried out (2-bit error detection and 1-bit error detection and correction).</p></li>
</ul>
<p>Upon occurrence of an ECC error, it is notified to the error control module.</p>
<ul>
<li><p>Error notification can be either enabled or disabled upon detection of a 2-bit ECC error.</p></li>
<li><p>Error notification can be either enabled or disabled upon detection of a 1-bit ECC error.</p></li>
</ul>
<p>A status register is provided, which indicates the statuses of 2-bit ECC error detection and 1-bit ECC error detection. If an error occurs while no error status is set, the corresponding status is set. The error status can be cleared using the clear register.</p>
<p><strong>Peripheral RAM:</strong></p>
<p>This is an ECC module for the RAM of the following peripheral modules:</p>
<p>RS-CAN, FlexRay, CSIHn (n = 0 to 3)</p>
<p>Seven-bit ECC data is appended to the 32-bit RAM data.</p>
<p>This ECC circuit provides 2-bit ECC error detection and 1-bit ECC error detection and correction.</p>
<p>Enabling or disabling ECC error detection and correction</p>
<ul>
<li><p>ECC error detection can be either enabled or disabled.</p></li>
<li><p>One-bit ECC error correction can be either enabled or disabled.</p></li>
<li><p>If all the bits of RAM output data are stuck to 0 or 1, it is detected as a 2-bit ECC error.</p></li>
</ul>
<p>Error notification</p>
<ul>
<li><p>Error notification is made to the ECM upon detection of a 2-bit ECC error (notification can be either enabled or disabled).</p></li>
<li><p>Error notification is made to the ECM upon detection of a 1-bit ECC error (notification can be either enabled or disabled).</p></li>
</ul>
<p>Once an error is notified to the ECM, another error notification is not made until the corresponding error status flag is cleared even if another ECC error is detected. Special registers are provided to clear error status.</p>
<h1 id="sub-functions-in-this-document">Sub-Functions In This Document</h1>
<p>Below is a linked list of all sub-functions owned by this document.</p>
<table>
<colgroup>
<col style="width: 73%" />
<col style="width: 26%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Sub-Function Name</strong></td>
<td><strong>Link</strong></td>
</tr>
<tr class="even">
<td>RAM Register Configuration</td>
<td>4.1</td>
</tr>
<tr class="odd">
<td>RAM ECC 2-Bit and Address Parity Faults</td>
<td>4.2</td>
</tr>
<tr class="even">
<td>Local RAM 1-Bit ECC and Data Parity</td>
<td>4.3</td>
</tr>
<tr class="odd">
<td>Peripheral RAM Single Bit ECC</td>
<td>Error: Reference source not found</td>
</tr>
<tr class="even">
<td>I-Cache</td>
<td>4.4</td>
</tr>
</tbody>
</table>
<h1 id="critical-registers">Critical Registers</h1>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 17%" />
<col style="width: 13%" />
<col style="width: 9%" />
<col style="width: 15%" />
<col style="width: 11%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Register</strong></td>
<td><p><strong>Register No.</strong></p>
<p><strong>(regID, selID)</strong></p></td>
<td><strong>Access Permission</strong></td>
<td><p><strong>Init/Periodic</strong></p>
<p><strong>Verification</strong></p></td>
<td><strong>Masking</strong></td>
<td><strong>Expected Value</strong></td>
<td><p><strong>Protn Score From</strong></p>
<p><strong>Eval Sheet</strong></p></td>
</tr>
<tr class="even">
<td>LRSTCLR_PE1</td>
<td>Memory Mapped</td>
<td><p>SV – R/W</p>
<p>UM – R/W</p></td>
<td>Init</td>
<td>None</td>
<td>0x0000 0000</td>
<td>2</td>
</tr>
<tr class="odd">
<td>LROVFSTR_PE1</td>
<td>Memory Mapped</td>
<td><p>SV – R/W</p>
<p>UM – R/W</p></td>
<td>Init</td>
<td>None</td>
<td>0x0000 0000</td>
<td>2</td>
</tr>
<tr class="even">
<td>LR1STERSTR_PE1</td>
<td>Memory Mapped</td>
<td><p>SV – R/W</p>
<p>UM – R/W</p></td>
<td>Init</td>
<td>None</td>
<td>0x0000 0000</td>
<td>2</td>
</tr>
<tr class="odd">
<td>LR1STEADR0_PE1</td>
<td>Memory Mapped</td>
<td><p>SV – R/W</p>
<p>UM – R/W</p></td>
<td>Init</td>
<td>None</td>
<td>0x0000 0000</td>
<td>2</td>
</tr>
<tr class="even">
<td>LR1STEADR1_PE1</td>
<td>Memory Mapped</td>
<td><p>SV – R/W</p>
<p>UM – R/W</p></td>
<td>Init</td>
<td>None</td>
<td>0x0000 0000</td>
<td>2</td>
</tr>
<tr class="odd">
<td>LR1STEADR2_PE1</td>
<td>Memory Mapped</td>
<td><p>SV – R/W</p>
<p>UM – R/W</p></td>
<td>Init</td>
<td>None</td>
<td>0x0000 0000</td>
<td>2</td>
</tr>
<tr class="even">
<td>LR1STEADR3_PE1</td>
<td>Memory Mapped</td>
<td><p>SV – R/W</p>
<p>UM – R/W</p></td>
<td>Init</td>
<td>None</td>
<td>0x0000 0000</td>
<td>2</td>
</tr>
<tr class="odd">
<td>ECCCSIH0CTL</td>
<td>Memory Mapped</td>
<td><p>SV – R/W</p>
<p>UM – R/W</p></td>
<td>Init</td>
<td>None</td>
<td>0x0000 0018</td>
<td>1</td>
</tr>
<tr class="even">
<td>ECCCSIH1CTL</td>
<td>Memory Mapped</td>
<td><p>SV – R/W</p>
<p>UM – R/W</p></td>
<td>Init</td>
<td>None</td>
<td>0x0000 0018</td>
<td>1</td>
</tr>
<tr class="odd">
<td>ECCCSIH2CTL</td>
<td>Memory Mapped</td>
<td><p>SV – R/W</p>
<p>UM – R/W</p></td>
<td>Init</td>
<td>None</td>
<td>0x0000 0018</td>
<td>1</td>
</tr>
<tr class="even">
<td>ECCCSIH3CTL</td>
<td>Memory Mapped</td>
<td><p>SV – R/W</p>
<p>UM – R/W</p></td>
<td>Init</td>
<td>None</td>
<td>0x0000 0018</td>
<td>1</td>
</tr>
<tr class="odd">
<td>ECCCSIH0EAD0</td>
<td>Memory Mapped</td>
<td><p>SV – R/W</p>
<p>UM – R/W</p></td>
<td>Init</td>
<td>None</td>
<td>0x0000 0000</td>
<td>1</td>
</tr>
<tr class="even">
<td>ECCCSIH1EAD0</td>
<td>Memory Mapped</td>
<td><p>SV – R/W</p>
<p>UM – R/W</p></td>
<td>Init</td>
<td>None</td>
<td>0x0000 0000</td>
<td>1</td>
</tr>
<tr class="odd">
<td>ECCCSIH2EAD0</td>
<td>Memory Mapped</td>
<td><p>SV – R/W</p>
<p>UM – R/W</p></td>
<td>Init</td>
<td>None</td>
<td>0x0000 0000</td>
<td>1</td>
</tr>
<tr class="even">
<td>ECCCSIH3EAD0</td>
<td>Memory Mapped</td>
<td><p>SV – R/W</p>
<p>UM – R/W</p></td>
<td>Init</td>
<td>None</td>
<td>0x0000 0000</td>
<td>1</td>
</tr>
<tr class="odd">
<td>ECCRCAN0CTL</td>
<td>Memory Mapped</td>
<td><p>SV – R/W</p>
<p>UM – R/W</p></td>
<td>Init</td>
<td>None</td>
<td>0x0000 0018</td>
<td>1</td>
</tr>
<tr class="even">
<td>ECCRCAN0EAD0</td>
<td>Memory Mapped</td>
<td><p>SV – R/W</p>
<p>UM – R/W</p></td>
<td>Init</td>
<td>None</td>
<td>0x0000 0000</td>
<td>1</td>
</tr>
</tbody>
</table>
<h1 id="sub-functions">Sub-functions</h1>
<h2 id="sub-function-ram-ntcs-initialization">Sub-Function: RAM NTCs Initialization</h2>
<p>Return to sub-function list link: Sub-Functions In This Document</p>
<h3 id="ntcs">NTCs</h3>
<p>012.0: Local RAM ECC – Single Bit Correction (Soft Fault)</p>
<p>012.2: I-Cache ECC Error Detection (Cache Miss)</p>
<p>012.4: CAN RAM ECC Single Bit Correction (Soft Fault)</p>
<p>012.6: CSIH0-3 RAM ECC Single Bit Correction (Soft Fault)</p>
<p>017.1: CSIH0 RAM ECC Double Bit (Hard Fault)</p>
<p>018.1: CSIH1 RAM ECC Double Bit (Hard Fault)</p>
<p>019.1: CSIH 2 RAM ECC Double Bit (Hard Fault)</p>
<p>01A.1: CSIH 3 RAM ECC Double Bit (Hard Fault)</p>
<p>01B.2: CAN RAM ECC Double Bit Fault</p>
<p>01D.1: Flexray Message RAM ECC Double Bit Fault</p>
<p>01D.3: Flexray Buffer A RAM ECC Double Bit Fault</p>
<p>01D.5: Flexray Buffer B RAM ECC Double Bit Fault</p>
<h3 id="san-linkage">SAN Linkage</h3>
<p>N/A</p>
<h3 id="description">Description</h3>
<p>This RTE Initialization function sets all the NTCs to Passed State.</p>
<h3 id="rationale">Rationale</h3>
<p>N/A</p>
<h3 id="implementation">Implementation</h3>
<p>N/A</p>
<h4 id="initialization-rammeminit1">Initialization (RamMemInit1)</h4>
<p><u>Psuedo Code:</u></p>
<p>SpiErrChFlg = 255;</p>
<p>// Set NTC 012 to Passed</p>
<p>SetNtcSts (0x012, 0x00, NtcSts1.NTCSTS_PASSD, 0);</p>
<p>// Set NTC 017 to Passed</p>
<p>SetNtcSts (0x017, 0x02, NtcSts1.NTCSTS_PASSD, 0);</p>
<p>// Set NTC 018 to Passed</p>
<p>SetNtcSts (0x018, 0x02, NtcSts1.NTCSTS_PASSD, 0);</p>
<p>// Set NTC 019 to Passed</p>
<p>SetNtcSts (0x019, 0x02, NtcSts1.NTCSTS_PASSD, 0);</p>
<p>// Set NTC 01A to Passed</p>
<p>SetNtcSts (0x01A, 0x02, NtcSts1.NTCSTS_PASSD, 0);</p>
<p>// Set NTC 01B to Passed</p>
<p>SetNtcSts (0x01B, 0x00, NtcSts1.NTCSTS_PASSD, 0);</p>
<p>// Set NTC 01D to Passed</p>
<p>SetNtcSts (0x01D, 0x00, NtcSts1.NTCSTS_PASSD, 0);</p>
<h3 id="reference-registers">Reference Registers</h3>
<p>N/A</p>
<h3 id="verification-method">Verification Method</h3>
<p>N/A</p>
<h2 id="sub-function-ram-ecc--2-bit-and-address-parity-faults">Sub-Function: RAM ECC -2 Bit and Address Parity Faults</h2>
<p>Return to sub-function list link: Sub-Functions In This Document</p>
<p>Refer to FDD CM101A_ExcpnHndlg for information on RAM double bit failures (local RAM and DTS RAM) and Address Parity Failures.</p>
<h3 id="ntcs-1">NTCs</h3>
<p>N/A</p>
<h3 id="san-linkage-1">SAN Linkage</h3>
<p>None</p>
<h3 id="description-1">Description</h3>
<p>N/A</p>
<h3 id="rationale-1">Rationale</h3>
<p>N/A</p>
<h4 id="event-driven">Event Driven</h4>
<p>N/A</p>
<h3 id="reference">Reference</h3>
<p>N/A</p>
<h3 id="verification-method-1">Verification Method</h3>
<p>NA</p>
<h2 id="sub-function-local-ram-ecc---1-bit">Sub-Function: Local RAM ECC - 1 Bit</h2>
<p>Return to sub-function list link: Sub-Functions In This Document</p>
<h3 id="ntcs-2">NTCs</h3>
<p>N/A</p>
<h3 id="san-linkage-2">SAN Linkage</h3>
<p><strong>SAN-402 – 406</strong></p>
<p>In case 1-bit corruption is flagged by the ECC logic, a SW test <strong>shall</strong> be executed to check if the error was due to:</p>
<ol type="a">
<li><p>Transient failure of one of the logical word corresponding cell</p></li>
<li><p>Permanent failure of one of the logical word corresponding cell</p></li>
<li><p>Multiple bits (&gt; 2bits) corruption</p></li>
<li><p>An address failure</p></li>
</ol>
<p><strong>SAN-407</strong></p>
<p>In case of a) the operation <strong>can</strong> be continued. In the unlikely event that the corruption is confirmed (permanent fault) and the related data is not duplicated in other locations, it is up to the user whether or not to move to the safe state or to tolerate the error.</p>
<p><strong>SAN-408</strong></p>
<p>In case c) and d) transition to the MCU and the system into the safe state <strong>shall</strong> be done. Unless, the data is duplicated in two different locations</p>
<p><strong>SAN-409</strong></p>
<p>Whenever an ECC error has occurred, it <strong>should</strong> be handled and the corresponding flag should be cleared by means of LRSTCLR register.</p>
<h3 id="description-2">Description</h3>
<p>This sub-function is called by the MCU handler and addresses single bit ECC / data parity issues. It is also responsible for confirming if the single bit error is “real” as based on the hardware, multiple failures could present as single bit faults when they are not. In this instance, a flag is set and the NTC is monitored in a periodic function.</p>
<h3 id="rationale-2">Rationale</h3>
<p>Design sets a flag within the exception for triggering of NTCs in a periodic function as NTC setting is not allowed in an exception (architecture requirement).</p>
<p>Design assumes that 1 bit ECC Error detection and correction has been enabled and hence we do not perform software reset on multiple single bit ECC Errors in the same word line addresses.</p>
<p>NxtrSwRstFromExcpn function is designed to clear the ECM bits that triggered the interrupt and hence the ECC bits corresponding to Local RAM 1-bit failure in the ECM register will not be cleared in the periodic tasks.</p>
<p>R7F701311 has 128KB of RAM with a Base address of 0xFEB8 0000 and the Offset starting at 0x0006 0000. Based on this data, we check if the address that we read from the Error Address register has a valid offset address. If not, we log a fault and drive software reset since we could be accessing invalid RAM addresses.</p>
<p>When doing RAM failure mode classification check, we loop through all 8 address locations to read them and we clear any single bit ECC faults if they occurred during the 8 reads. In this small window, there is a chance that DMA can make an access to local RAM and set a single bit ECC fault which can be misinterpreted as a single bit ECC fault from reading the 8 addresses. Also, we have setup the local RAM double bit ECC fault to be configured as a SYSERR. In the event a double bit error occurs while reading the 8 addresses a SYSERR will take us to safe state, hence there is no explicit check for the double bit ECC fault.</p>
<h3 id="implementation-1">Implementation</h3>
<p>Applicable Registers’ Information:</p>
<table style="width:100%;">
<colgroup>
<col style="width: 19%" />
<col style="width: 59%" />
<col style="width: 9%" />
<col style="width: 11%" />
</colgroup>
<tbody>
<tr class="odd">
<td rowspan="2"><strong>Register</strong></td>
<td rowspan="2"><strong>Use</strong></td>
<td colspan="2"><strong>Access</strong></td>
</tr>
<tr class="even">
<td><strong>SV</strong></td>
<td><strong>UM</strong></td>
</tr>
<tr class="odd">
<td>LRSTCLR_PE1</td>
<td>Used in the design to clear error information in the register LR1STERSTR_PE1</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>LROVFSTR_PE1</td>
<td>Used in design to indicate address location of error</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>LR1STERSTR_PE1</td>
<td>Used in design to indicate RAM bank (to identify which register to read for LR1STEADRn_PE1) and identify failure type</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td><p>LR1STEADRn_PE1</p>
<p>n = 0,1,2,3</p></td>
<td>Multiple registers, one for each bank. Contains the address of the memory having the issue.</td>
<td>R/W</td>
<td>R/W</td>
</tr>
</tbody>
</table>
<h4 id="event-rammemlclramsngbitecc">Event (RamMemLclRamSngBitEcc)</h4>
<p><strong>// From EIINT Handler in MCU</strong></p>
<p>// Disable all the EI Interrupts</p>
<p>SuspendAllInterrupts ();</p>
<p>// Identify responsible bank – Check for Bank 0</p>
<p>If ((ECCCPU1ERROVF0 == 1)</p>
<p>{</p>
<p>// Check if the saved address in the valid range</p>
<p>LclRamFailrAdr = (ECCCPU1LR1STEADR0_PE1 &lt;&lt; 4);</p>
<p>If (LclRamFailrAdr &amp; 0xFFFE 0000 != 0x0006 0000)</p>
<p>{</p>
<blockquote>
<p>// Invalid Address Found</p>
<p>// API Call for Software Reset</p>
<p>NxtrSwRstFromExcpn (McuDiagc1.MCUDIAGC_LCLRAMECCSNGBITHARDFAILR, LclRamFailrAdr)</p>
</blockquote>
<p>}</p>
<p>// Get the valid RAM address by OR-ing the Base address with the offset</p>
<p>LclRamFailrAdr = LclRamFailrAdr | 0xFEB8 0000;</p>
<p>// Overflow detected</p>
<p>// API Call for Software Reset</p>
<blockquote>
<p>NxtrSwRstFromExcpn (McuDiagc1.MCUDIAGC_LCLRAMECCSNGBITHARDFAILR, LclRamFailrAdr)</p>
</blockquote>
<p>}</p>
<p>ElseIf (ECCCPU1SEDF0 == 1)</p>
<p>{</p>
<p>// Save Failure Address</p>
<p>LclRamFailrAdr = (ECCCPU1LR1STEADR0_PE1 &lt;&lt; 4);</p>
<p>If (LclRamFailrAdr &amp; 0xFFFE 0000 != 0x0006 0000)</p>
<p>{</p>
<blockquote>
<p>// Invalid Address Found</p>
<p>// API Call for Software Reset</p>
<p>NxtrSwRstFromExcpn (McuDiagc1.MCUDIAGC_LCLRAMECCSNGBITHARDFAILR, LclRamFailrAdr)</p>
</blockquote>
<p>}</p>
<p>// Get the valid RAM address by OR-ing the Base address with the Offset</p>
<p>LclRamFailrAdr = LclRamFailrAdr | 0xFEB8 0000;</p>
<p>// No overflow</p>
<p>// Clear RAM Bank 0 error info only</p>
<p>ECCCPU1STCLR0 = 1;</p>
<p>// Clears the following</p>
<p>// 1) LROVFSTR_PE1.ERROVF0 (overflow flag)</p>
<p>// 2) LR1STERSTR_PE1.SEDF0 (error status flag)</p>
<p>// 3) LR1STEADR0_PE1 (error address)</p>
<p>// Check for multibit errors or address errors disguised as single bit</p>
<p>RamFailrModClassnChk (LclRamFailrAdr, 0x0000 0001, 0x0000 0001);</p>
<p>}</p>
<p>// Identify responsible bank – Check for Bank 1</p>
<p>If ((ECCCPU1ERROVF1 == 1)</p>
<p>{</p>
<p>// Check if the saved address in the valid range</p>
<p>LclRamFailrAdr = (ECCCPU1LR1STEADR1_PE1 &lt;&lt; 4) | 0x04;</p>
<p>If (LclRamFailrAdr &amp; 0xFFFE 0000 != 0x0006 0000)</p>
<p>{</p>
<blockquote>
<p>// Invalid Address Found</p>
<p>// API Call for Software Reset</p>
<p>NxtrSwRstFromExcpn (McuDiagc1.MCUDIAGC_LCLRAMECCSNGBITHARDFAILR, LclRamFailrAdr)</p>
</blockquote>
<p>}</p>
<p>// Get the valid RAM address by OR-ing the Base address with the Offset</p>
<p>LclRamFailrAdr = LclRamFailrAdr | 0xFEB8 0000;</p>
<p>// Overflow detected</p>
<p>// API Call for Software Reset</p>
<blockquote>
<p>NxtrSwRstFromExcpn (McuDiagc1.MCUDIAGC_LCLRAMECCSNGBITHARDFAILR, LclRamFailrAdr)</p>
</blockquote>
<p>}</p>
<p>ElseIf (ECCCPU1SEDF1 == 1)</p>
<p>{</p>
<p>// Save Failure Address</p>
<p>LclRamFailrAdr = (ECCCPU1LR1STEADR1_PE1 &lt;&lt; 4) | 0x04;</p>
<p>If (LclRamFailrAdr &amp; 0xFFFE 0000 != 0x0006 0000)</p>
<p>{</p>
<blockquote>
<p>// Invalid Address Found</p>
<p>// API Call for Software Reset</p>
<p>NxtrSwRstFromExcpn (McuDiagc1.MCUDIAGC_LCLRAMECCSNGBITHARDFAILR, LclRamFailrAdr)</p>
</blockquote>
<p>}</p>
<p>// Get the valid RAM address by OR-ing the Base address with the Offset</p>
<p>LclRamFailrAdr = LclRamFailrAdr | 0xFEB8 0000;</p>
<p>// No overflow</p>
<p>// Clear RAM Bank 1 error info only</p>
<p>ECCCPU1STCLR1 = 1;</p>
<p>// Clears the following</p>
<p>// 1) LROVFSTR_PE1.ERROVF1 (overflow flag)</p>
<p>// 2) LR1STERSTR_PE1.SEDF1 (error status flag)</p>
<p>// 3) LR1STEADR1_PE1 (error address)</p>
<p>// Check for multibit errors or address errors disguised as single bit</p>
<p>RamFailrModClassnChk (LclRamFailrAdr, 0x0000 0002, 0x0000 0100);</p>
<p>}</p>
<p>// Identify responsible bank – Check for Bank 2</p>
<p>If ((ECCCPU1ERROVF2 == 1) Then</p>
<p>{</p>
<p>// Check if the saved address in the valid range</p>
<p>LclRamFailrAdr = (ECCCPU1LR1STEADR2_PE1 &lt;&lt; 4) | 0x08;</p>
<p>If (LclRamFailrAdr &amp; 0xFFFE 0000 != 0x0006 0000)</p>
<p>{</p>
<blockquote>
<p>// Invalid Address Found</p>
<p>// API Call for Software Reset</p>
<p>NxtrSwRstFromExcpn (McuDiagc1.MCUDIAGC_LCLRAMECCSNGBITHARDFAILR, LclRamFailrAdr)</p>
</blockquote>
<p>}</p>
<p>// Get the valid RAM address by OR-ing the Base address with the Offset</p>
<p>LclRamFailrAdr = LclRamFailrAdr | 0xFEB8 0000;</p>
<p>// Overflow detected</p>
<p>// API Call for Software Reset</p>
<blockquote>
<p>NxtrSwRstFromExcpn (McuDiagc1.MCUDIAGC_LCLRAMECCSNGBITHARDFAILR, LclRamFailrAdr)</p>
</blockquote>
<p>}</p>
<p>ElseIf (ECCCPU1SEDF2 == 1)</p>
<p>{</p>
<p>// Save Failure Address</p>
<p>LclRamFailrAdr = (ECCCPU1LR1STEADR2_PE1 &lt;&lt; 4) | 0x08;</p>
<p>If (LclRamFailrAdr &amp; 0xFFFE 0000 != 0x0006 0000)</p>
<p>{</p>
<blockquote>
<p>// Invalid Address Found</p>
<p>// API Call for Software Reset</p>
<p>NxtrSwRstFromExcpn (McuDiagc1.MCUDIAGC_LCLRAMECCSNGBITHARDFAILR, LclRamFailrAdr)</p>
</blockquote>
<p>}</p>
<p>// Get the valid RAM address by OR-ing the Base address with the Offset</p>
<p>LclRamFailrAdr = LclRamFailrAdr | 0xFEB8 0000;</p>
<p>// No overflow</p>
<p>// Clear RAM Bank 2 error info only</p>
<p>ECCCPU1STCLR2 = 1;</p>
<p>// Clears the following</p>
<p>// 1) LROVFSTR_PE1.ERROVF2 (overflow flag)</p>
<p>// 2) LR1STERSTR_PE1.SEDF2 (error status flag)</p>
<p>// 3) LR1STEADR2_PE1 (error address)</p>
<p>// Check for multibit errors or address errors disguised as single bit</p>
<p>RamFailrModClassnChk (LclRamFailrAdr, 0x0000 0004, 0x0001 0000);</p>
<p>}</p>
<p>// Identify responsible bank – Check for Bank 3</p>
<p>If ((ECCCPU1ERROVF3 == 1)</p>
<p>{</p>
<p>// Check if the saved address in the valid range</p>
<p>LclRamFailrAdr = (ECCCPU1LR1STEADR3_PE1 &lt;&lt; 4) | 0x0C;</p>
<p>If (LclRamFailrAdr &amp; 0xFFFE 0000 != 0x0006 0000)</p>
<p>{</p>
<blockquote>
<p>// Invalid Address Found</p>
<p>// API Call for Software Reset</p>
<p>NxtrSwRstFromExcpn (McuDiagc1.MCUDIAGC_LCLRAMECCSNGBITHARDFAILR, LclRamFailrAdr)</p>
</blockquote>
<p>}</p>
<p>// Get the valid RAM address by OR-ing the Base address with the Offset</p>
<p>LclRamFailrAdr = LclRamFailrAdr | 0xFEB8 0000;</p>
<p>// Overflow detected</p>
<p>// API Call for Software Reset</p>
<blockquote>
<p>NxtrSwRstFromExcpn (McuDiagc1.MCUDIAGC_LCLRAMECCSNGBITHARDFAILR, LclRamFailrAdr)</p>
</blockquote>
<p>}</p>
<p>ElseIf (ECCCPU1SEDF3 == 1)</p>
<p>{</p>
<p>// Save Failure Address</p>
<p>LclRamFailrAdr = (ECCCPU1LR1STEADR3_PE1 &lt;&lt; 4) | 0x0C;</p>
<p>If (LclRamFailrAdr &amp; 0xFFFE 0000 != 0x0006 0000)</p>
<p>{</p>
<blockquote>
<p>// Invalid Address Found</p>
<p>// API Call for Software Reset</p>
<p>NxtrSwRstFromExcpn (McuDiagc1.MCUDIAGC_LCLRAMECCSNGBITHARDFAILR, LclRamFailrAdr)</p>
</blockquote>
<p>}</p>
<p>// Get the valid RAM address by OR-ing the Base address with the Offset</p>
<p>LclRamFailrAdr = LclRamFailrAdr | 0xFEB8 0000;</p>
<p>// No overflow</p>
<p>// Clear RAM Bank 3 error info only</p>
<p>ECCCPU1STCLR3 = 1;</p>
<p>// Clears the following</p>
<p>// 1) LROVFSTR_PE1.ERROVF3 (overflow flag)</p>
<p>// 2) LR1STERSTR_PE1.SEDF3 (error status flag)</p>
<p>// 3) LR1STEADR3_PE1 (error address)</p>
<p>// Check for multibit errors or address errors disguised as single bit</p>
<p>RamFailrModClassnChk (LclRamFailrAdr, 0x0000 0008, 0x0100 0000);</p>
<p>}</p>
<p>RamFailrModClassnChk (LclRamFailrAdr, ClrErrInfo, SngBitErrMask)</p>
<p>{</p>
<p>WordLineAdr = LclRamFailrAdr &amp; 0xFFFF FF1F;</p>
<p>WordLineAdrIdx_u08 = 0;</p>
<p>LclRamEccSngBitSoftFailr = TRUE;</p>
<p>While (WordLineAdrIdx_u08 &lt; 8)</p>
<p>{</p>
<p>// Implementation must ensure all 8 reads happen</p>
<p>LclRamWordLineRead = *WordLineAdr;</p>
<blockquote>
<p>WordLineAdrIdx_u08++;</p>
<p>WordLineAdr = WordLineAdr + 0x0000 0020;</p>
</blockquote>
<p>}</p>
<p>// Wait until read from the RAM word line is complete</p>
<p>__asm ("SYNCM");</p>
<p>// Clear Bank Specific Error Info</p>
<p>ECCCPU1LRSTCLR_PE1 = ClrErrInfo;</p>
<p>// Clears the following in Bank Specific RAM Status Register</p>
<p>// 1) Overflow flag</p>
<p>// 2) Error status flag</p>
<p>// 3) Error address</p>
<p>// Single Bit faults detected, Single Bit Soft Fault Flag is already set</p>
<p>}</p>
<p>// Re-enable all the disabled EI Interrupts</p>
<p>ResumeAllInterrupts ();</p>
<h3 id="reference-registers-1">Reference Registers</h3>
<p><img src="ElectricPowerSteering_RH850_GM_T1XX_website/static/media/image1.png" style="width:5.99861in;height:5.89236in" /></p>
<p><img src="ElectricPowerSteering_RH850_GM_T1XX_website/static/media/image2.png" style="width:5.99931in;height:6.07986in" /></p>
<p><img src="ElectricPowerSteering_RH850_GM_T1XX_website/static/media/image3.png" style="width:5.99583in;height:5.80972in" /></p>
<p><img src="ElectricPowerSteering_RH850_GM_T1XX_website/static/media/image4.png" style="width:5.99306in;height:5.575in" /></p>
<h3 id="verification-method-2">Verification Method</h3>
<p>N/A</p>
<h2 id="sub-function-i-cache-ecc-setting-the-ntcs">Sub-Function: I-Cache ECC &amp; Setting the NTCs</h2>
<p>Return to sub-function list link: Sub-Functions In This Document</p>
<h3 id="ntcs-3">NTCs</h3>
<p>012.0: Local RAM ECC – Single Bit Correction (Soft Fault)</p>
<p>012.2: I-Cache ECC Error Detection</p>
<p>012.4: CAN RAM ECC Single Bit Correction (Soft Fault)</p>
<p>012.6: CSIH0-3 RAM ECC Single Bit Correction (Soft Fault)</p>
<p>017.1: CSIH0 RAM ECC Double Bit (Hard Fault)</p>
<p>018.1: CSIH1 RAM ECC Double Bit (Hard Fault)</p>
<p>019.1: CSIH2 RAM ECC Double Bit (Hard Fault)</p>
<p>01A.1: CSIH3 RAM ECC Double Bit (Hard Fault)</p>
<p>01B.1: CAN RAM ECC Double Bit Fault</p>
<p>01D.1: Flexray Message RAM ECC Double Bit Fault</p>
<p>01D.3: Flexray Buffer A RAM ECC Double Bit Fault</p>
<p>01D.5: Flexray Buffer B RAM ECC Double Bit Fault</p>
<h3 id="san-linkage-3">SAN Linkage</h3>
<p><strong>SAN528:</strong></p>
<p>The ECC error detection and the notification to the ECM <strong>should</strong> not be disabled.</p>
<p><strong>SAN 871:</strong></p>
<p>The detection of all error types and the status interrupt for each RSCAN module should be enabled. Whether or not to execute a loop back for safety purposes depends on the implemented system level safety measures and should be decided by the user.</p>
<p><strong>SAN 507 - 508:</strong></p>
<p>Whenever an ECC occurs, the corresponding flags shall be cleared by means of IDSTCLR_PE1 and ITSTCLR_PE1 register. Otherwise, the error event remains active and the error status will not be updated. The ECC check of the instruction cache data read out from tag or data RAM is automatically enabled.</p>
<p><strong>SAN 509:</strong></p>
<p>Up on detection of a 1-bit/2-bit ECC error, the corresponding flag will be set in the error status register and the original data will be reloaded from the Code Flash (treated as cache miss). This behavior may lead to performance loss. The critical performance loss can be detected by timeout monitoring. In the case of the critical performance loss, the MCU shall be moved into the safe state.</p>
<h3 id="description-3">Description</h3>
<p>This function is called by the MCU handler and addresses ECC problems with the peripheral RAM (for the Nexteer design this includes four SPI channels and two CAN channels).</p>
<p>This function also includes an action when a CAN RAM ECC double bit fault error occurs.</p>
<p>Added content… DTS single bit, FR, Cntr</p>
<p>ECM status registers are periodically polled looking for an I-Cache ECC problem. In the event of an I-Cache Error, the respective NTC is set in a periodic and the Error Status Register is cleared.</p>
<p>This sub function reads all the Flags related to Single Bit ECC fault from Local RAM, CSIH RAM and CAN RAM (Singe Bit and Double Bit ECC faults) and takes the following actions</p>
<ul>
<li><p>Setting an NTC if required in a periodic task</p></li>
<li><p>Clearing the respective ECM Status Register bit</p></li>
</ul>
<p>Registers in use:</p>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 48%" />
<col style="width: 11%" />
<col style="width: 11%" />
</colgroup>
<tbody>
<tr class="odd">
<td rowspan="2"><strong>Register</strong></td>
<td rowspan="2"><strong>Use</strong></td>
<td colspan="2"><strong>Access</strong></td>
</tr>
<tr class="even">
<td><strong>SV</strong></td>
<td><strong>UM</strong></td>
</tr>
<tr class="odd">
<td>IDSTCLR_PE1 (Instruction Cache Data RAM Error Status Clear Register)</td>
<td>IDSTCLR clears the error flags in the error status register (ID1STERSTR), the overflow flag in the error overflow status register (IDOVFSTR), and the error address register (ID1STEADR).</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>ITSTCLR_PE1 (Instruction Cache Tag RAM Error Status Clear Register)</td>
<td>ITSTCLR clears the error flags in the error status register (IT1STERSTR), the overflow flag in the error overflow status register (ITOVFSTR), and the error address register (IT1STEADR).</td>
<td>R/W</td>
<td>R/W</td>
</tr>
</tbody>
</table>
<h3 id="rationale-3">Rationale</h3>
<p>No startup tests are required as the ECC circuit of the peripheral modules is target of LBIST and the associated RAMs are target of the M-BIST as mentioned in the <strong>SAN 530</strong>.</p>
<p>CAN RAM single bit and double bit ECC, Flexray single bit and double bit ECC, SPI RAM single bit and double bit ECC are all polled in the periodic as a step towards reducing throughput impact (in case of a single bit memory failure).</p>
<p>SPI use in the design applies to several critical functions that may have redundant data sources (motor position, gate drive and power supply control).</p>
<p>SPI has four channels and all four channel errors are routed to a single bit in the ECM error source. To provide flexibility, each of these SPI channels are associated with a unique NTC which can be configured to be an F1 or F3 fault depending on their use case.</p>
<p>Since the I-Cache is configured to reload from flash with a problem (cache misses) there is no need to take action other than notifying via a trouble code and clearing the Error Flags in the Error Status Register.</p>
<p>This design sets NTCs in a periodic function as NTC setting is not allowed in an exception due to design constraints of the Diagnostic Manager getting interrupted in the middle of an NTC (architecture requirement).</p>
<p>When we read from a corrupted address in Peripheral RAM, ECEMF bit is set. The ECEMF bit self clears when uncorrupted data is read from Peripheral RAM. In order to clear the ECER2F or ECER1F bit, according to the Hardware Manual, it is necessary that the ECEMF bit is ‘0’, otherwise a write to ECER1C or ECER2C would not clear the ECER1F or ECER2F bits respectively. Therefore, an attempt to clear to error status flag is done in the periodic assuming that an uncorrupted read from the Peripheral RAM would have occurred.</p>
<h3 id="implementation-2">Implementation</h3>
<p>Applicable Registers</p>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 35%" />
<col style="width: 26%" />
<col style="width: 8%" />
<col style="width: 8%" />
</colgroup>
<tbody>
<tr class="odd">
<td rowspan="2"><strong>Register</strong></td>
<td rowspan="2"><strong>Use</strong></td>
<td rowspan="2"><strong>Comments</strong></td>
<td colspan="2"><strong>Access</strong></td>
</tr>
<tr class="even">
<td><strong>SV</strong></td>
<td><strong>UM</strong></td>
</tr>
<tr class="odd">
<td rowspan="4">ECCCSIHnCTL (SPI 3 Peripheral RAM ECC Control Register)</td>
<td>ECCCSIHnCTL.ECSEDF0</td>
<td>When set, indicates 1 bit error found at address EAD0</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>ECCCSIHnCTL.ECER1C</td>
<td>When set, will clear ECER1F bit</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>ECCCSIHnCTL.ECER1F</td>
<td>When set, indicates a 1 bit error occurred</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>ECCCSIHnCTL.ECEMF</td>
<td>When set, indicates the RAM output data has bit errors</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>ECCCSIH0EAD0</td>
<td>Address of ECC error – SPI 0</td>
<td></td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>ECCCSIH1EAD0</td>
<td>Address of ECC error – SPI 1</td>
<td></td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>ECCCSIH2EAD0</td>
<td>Address of ECC error – SPI 2</td>
<td></td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>ECCCSIH3EAD0</td>
<td>Address of ECC error – SPI 3</td>
<td></td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td rowspan="4">ECCRCAN0CTL (CAN Peripheral RAM ECC Control)</td>
<td>ECCRCAN0CTL.ECSEDF0</td>
<td>When set, indicates 1 bit error found at address EAD0</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>ECCRCAN0CTL.ECER1C</td>
<td>When set, will clear ECER1F bit</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>ECCRCAN0CTL.ECER1F</td>
<td>When set, indicates a 1 bit error occurred</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>ECCRCAN0CTL.ECEMF</td>
<td>When set, indicates the RAM output data has bit errors</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>ECCRCAN0EAD0</td>
<td>Address of ECC error – CAN</td>
<td></td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td rowspan="4">ECCFLX0CTL</td>
<td>ECCFLX0CTL.ECSEDF0</td>
<td>When set, indicates 1 bit error found at address EAD0</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>ECCFLX0CTL.ECER1C</td>
<td>When set, will clear ECER1F bit</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>ECCFLX0CTL.ECER1F</td>
<td>When set, indicates a 1 bit error occurred</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>ECCFLX0CTL.ECEMF</td>
<td>When set, indicates the RAM output data has bit errors</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>ECCFLX0EAD0</td>
<td>Address of ECC error – FlexRay</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td rowspan="4">ECCFLX0T1CTL</td>
<td>ECCFLX0T1CTL.ECSEDF0</td>
<td>When set, indicates 1 bit error found at address EAD0</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>ECCFLX0T1CTL.ECER1C</td>
<td>When set, will clear ECER1F bit</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>ECCFLX0T1CTL.ECER1F</td>
<td>When set, indicates a 1 bit error occurred</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>ECCFLX0T1CTL.ECEMF</td>
<td>When set, indicates the RAM output data has bit errors</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>ECCFLX0T1EAD0</td>
<td>Address of ECC error – FlexRay</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td rowspan="4">ECCFLX0T0CTL</td>
<td>ECCFLX0T0CTL.ECSEDF0</td>
<td>When set, indicates 1 bit error found at address EAD0</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>ECCFLX0T0CTL.ECER1C</td>
<td>When set, will clear ECER1F bit</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>ECCFLX0T0CTL.ECER1F</td>
<td>When set, indicates a 1 bit error occurred</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>ECCFLX0T0CTL.ECEMF</td>
<td>When set, indicates the RAM output data has bit errors</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>ECCFLX0T0EAD0</td>
<td>Address of ECC error – FlexRay</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>ECCCSIH0CTL (ECC Control / Status Register for SPI 0)</td>
<td>Indicates a SPI double bit error in SPI 0</td>
<td></td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>ECCCSIH1CTL (ECC Control / Status Register for SPI 1)</td>
<td>Indicates a SPI double bit error in SPI 1</td>
<td></td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>ECCCSIH2CTL (ECC Control / Status Register for SPI 2)</td>
<td>Indicates a SPI double bit error in SPI 2.</td>
<td></td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>ECCCSIH3CTL (ECC Control / Status Register for SPI 2)</td>
<td>Indicates a SPI double bit error in SPI 3.</td>
<td></td>
<td>R/W</td>
<td>R/W</td>
</tr>
</tbody>
</table>
<h4 id="periodic---2ms-rammemper1">Periodic - 2ms (RamMemPer1)</h4>
<p><u>Pseudo Code:</u></p>
<p>// SPI Single bit failures</p>
<p>If ((ECCCSIH0CTL &amp; 0x0001 0002) != 0)</p>
<p>{</p>
<p>// Stores address information for debug</p>
<p>dRamMemSpiRamEccErrAdr = ECCCSIH0EAD0;</p>
<p>// Clear error flags by setting the ECMCLSSE107 bit of the ECMESSTC1 register</p>
<p>ECMESSTC1_Desired = 0x0000 0080;</p>
<p>WrProtdRegEcm_u32 (ECMESSTC1_Desired, Address of ECMESSTC1);</p>
<p>// Clear the 1 Bit Error Detection Flag</p>
<p>ECCCSIH0CTL = 0x0000 0200;</p>
<p>// Set NTC 012.6 to Failed</p>
<p>SetNtcSts (0x012, 0x40, NtcSts1.NTCSTS_FAILD, 0) ;</p>
<p>}</p>
<p>Else If ((ECCCSIH1CTL &amp; 0x0001 0002) != 0)</p>
<p>{</p>
<p>// Stores address information for debug</p>
<p>dRamMemSpiRamEccErrAdr = ECCCSIH1EAD0;</p>
<p>// Clear error flags by setting the ECMCLSSE107 bit of the ECMESSTC1 register</p>
<p>ECMESSTC1_Desired = 0x0000 0080;</p>
<p>WrProtdRegEcm_u32 (ECMESSTC1_Desired, Address of ECMESSTC1);</p>
<p>// Clear the 1 Bit Error Detection Flag</p>
<p>ECCCSIH1CTL = 0x0000 0200;</p>
<p>// Set NTC 012.6 to Failed</p>
<p>SetNtcSts (0x012, 0x40, NtcSts1.NTCSTS_FAILD, 0) ;</p>
<p>}</p>
<p>Else If ((ECCCSIH2CTL &amp; 0x0001 0002) != 0)</p>
<p>{</p>
<p>// Stores address information for debug</p>
<p>dRamMemSpiRamEccErrAdr = ECCCSIH2EAD0;</p>
<p>// Clear error flags by setting the ECMCLSSE107 bit of the ECMESSTC1 register</p>
<p>ECMESSTC1_Desired = 0x0000 0080;</p>
<p>WrProtdRegEcm_u32 (ECMESSTC1_Desired, Address of ECMESSTC1);</p>
<p>// Clear the 1 Bit Error Detection Flag</p>
<p>ECCCSIH2CTL = 0x0000 0200;</p>
<p>// Set NTC 012.6 to Failed</p>
<p>SetNtcSts (0x012, 0x40, NtcSts1.NTCSTS_FAILD, 0) ;</p>
<p>}</p>
<p>Else If ((ECCCSIH3CTL &amp; 0x0001 0002) != 0)</p>
<p>{</p>
<p>// Stores address information for debug</p>
<p>dRamMemSpiRamEccErrAdr = ECCCSIH3EAD0;</p>
<p>// Clear error flags by setting the ECMCLSSE107 bit of the ECMESSTC1 register</p>
<p>ECMESSTC1_Desired = 0x0000 0080;</p>
<p>WrProtdRegEcm_u32 (ECMESSTC1_Desired, Address of ECMESSTC1);</p>
<p>// Clear the 1 Bit Error Detection Flag</p>
<p>ECCCSIH13CTL = 0x0000 0200;</p>
<p>// Set NTC 012.6 to Failed</p>
<p>SetNtcSts (0x012, 0x40, NtcSts1.NTCSTS_FAILD, 0) ;</p>
<p>}</p>
<p>Else</p>
<p>{</p>
<p>// Do Nothing</p>
<p>}</p>
<p>// SPI 0 ECC Double Bit Fault</p>
<p>If (ECCCSIH0CTL &amp; 0x0002 0004 != 0)</p>
<p>{</p>
<p>SetNtcSts (0x017, 0x02, NtcSts1.NTCSTS_FAILD, 0)</p>
<p>// Stores address information for debug</p>
<p>dRamMemSpi0RamEccErrAdr = ECCCSIH0EAD0;</p>
<p>// Clear error flags by setting the ECMCLSSE018 bit of the ECMESSTC0 register</p>
<p>ECMESSTC0_Desired = 0x0004 0000;</p>
<p>WrProtdRegEcm_u32 (ECMESSTC0_Desired, Address of ECMESSTC0);</p>
<p>// Clear the 2 Bit Error Detection Flag</p>
<p>ECCCSIH0CTL = 0x0000 0400;</p>
<p>}</p>
<p>// SPI 1 ECC Double Bit Fault</p>
<p>If (ECCCSIH1CTL &amp; 0x0002 0004 != 0)</p>
<p>{</p>
<p>SetNtcSts (0x018, 0x02, NtcSts1.NTCSTS_FAILD, 0)</p>
<p>// Stores address information for debug</p>
<p>dRamMemSpi1RamEccErrAdr = ECCCSIH1EAD0;</p>
<p>// Clear error flags by setting the ECMCLSSE018 bit of the ECMESSTC0 register</p>
<p>ECMESSTC0_Desired = 0x0004 0000;</p>
<p>WrProtdRegEcm_u32 (ECMESSTC0_Desired, Address of ECMESSTC0);</p>
<p>// Clear the 2 Bit Error Detection Flag</p>
<p>ECCCSIH1CTL = 0x0000 0400;</p>
<p>}</p>
<p>// SPI 2 ECC Double Bit Fault</p>
<p>If (ECCCSIH2CTL &amp; 0x0002 0004 != 0)</p>
<p>{</p>
<p>SetNtcSts (0x019, 0x02, NtcSts1.NTCSTS_FAILD, 0)</p>
<p>// Stores address information for debug</p>
<p>dRamMemSpi2RamEccErrAdr = ECCCSIH2EAD0;</p>
<p>// Clear error flags by setting the ECMCLSSE018 bit of the ECMESSTC0 register</p>
<p>ECMESSTC0_Desired = 0x0004 0000;</p>
<p>WrProtdRegEcm_u32 (ECMESSTC0_Desired, Address of ECMESSTC0);</p>
<p>// Clear the 2 Bit Error Detection Flag</p>
<p>ECCCSIH2CTL = 0x0000 0400;</p>
<p>}</p>
<p>// SPI 3 ECC Double Bit Fault</p>
<p>If (ECCCSIH3CTL &amp; 0x0002 0004 != 0)</p>
<p>{</p>
<p>SetNtcSts (0x01A, 0x02, NtcSts1.NTCSTS_FAILD, 0)</p>
<p>// Stores address information for debug</p>
<p>dRamMemSpi3RamEccErrAdr = ECCCSIH3EAD0;</p>
<p>// Clear error flags by setting the ECMCLSSE018 bit of the ECMESSTC0 register</p>
<p>ECMESSTC0_Desired = 0x0004 0000;</p>
<p>WrProtdRegEcm_u32 (ECMESSTC0_Desired, Address of ECMESSTC0);</p>
<p>// Clear the 2 Bit Error Detection Flag</p>
<p>ECCCSIH3CTL = 0x0000 0400;</p>
<p>}</p>
<p>// Check if a CAN RAM single bit ECC error was detected</p>
<p>If ((ECCRCAN0CTL &amp; 0x0001 0002) != 0)</p>
<p>{</p>
<p>// Stores address information for debug</p>
<p>dRamMemCanRamSngBitEccErrAdr = ECCRCAN0EAD0;</p>
<p>// Clear error flags by setting the ECMCLSSE107 bit of the ECMESSTC1 register</p>
<p>ECMESSTC1_Desired = 0x0000 0080;</p>
<p>WrProtdRegEcm_u32 (ECMESSTC1_Desired, Address of ECMESSTC1);</p>
<p>// Clear the 1 Bit Error Detection Flag</p>
<p>ECCRCAN0CTL = 0x0000 0200;</p>
<p>// Set NTC 012.4 to Failed</p>
<p>SetNtcSts (0x012, 0x10, NtcSts1.NTCSTS_FAILD, 0);</p>
<p>}</p>
<p>// Check if a CAN RAM double bit ECC error was detected</p>
<p>If ((ECCRCAN0CTL &amp; 0x0002 0004) != 0)</p>
<p>{</p>
<blockquote>
<p>// Stores address information for debug</p>
<p>dRamMemCanRamDblBitEccErrAdr = ECCRCAN0EAD0;</p>
</blockquote>
<p>// Clear error flags by setting the ECMCLSSE017 bit of the ECMESSTC0 register</p>
<p>ECMESSTC0_Desired = 0x0008 0000;</p>
<p>WrProtdRegEcm_u32 (ECMESSTC0_Desired, Address of ECMESSTC0);</p>
<p>// Clear the 2 Bit Error Detection Flag</p>
<p>ECCRCAN0CTL = 0x0000 0400;</p>
<p>// Set NTC 01B.1 to Failed</p>
<p>SetNtcSts (0x01B, 0x02, NtcSts1.NTCSTS_FAILD, 0);</p>
<p>}</p>
<p>// Check if a FlexRay RAM single bit ECC error was detected</p>
<p>If ((ECCFLX0CTL &amp; 0x0001 0002) != 0)</p>
<p>{</p>
<p>// Stores address information for debug</p>
<p>dRamMemFrRamSngBitEccErrAdr = ECCFLX0EAD0;</p>
<p>// Clear error flags by setting the ECMCLSSE107 bit of the ECMESSTC1 register</p>
<p>ECMESSTC1_Desired = 0x0000 0080;</p>
<p>WrProtdRegEcm_u32 (ECMESSTC1_Desired, Address of ECMESSTC1);</p>
<p>// Clear the 1 Bit Error Detection Flag</p>
<p>ECCFLX0CTL = 0x0000 0200;</p>
<p>// Set NTC 012.5 to Failed</p>
<p>SetNtcSts (0x012, 0x20, NtcSts1.NTCSTS_FAILD, 0);</p>
<p>}</p>
<p>// Check if a FlexRay Temporary buffer (TBF B) RAM single bit ECC error was detected</p>
<p>Else If ((ECCFLX0T0CTL &amp; 0x0001 0002) != 0)</p>
<p>{</p>
<p>// Stores address information for debug</p>
<p>dRamMemFrRamSngBitEccErrAdr = ECCFLX0T0EAD0;</p>
<p>// Clear error flags by setting the ECMCLSSE107 bit of the ECMESSTC1 register</p>
<p>ECMESSTC1_Desired = 0x0000 0080;</p>
<p>WrProtdRegEcm_u32 (ECMESSTC1_Desired, Address of ECMESSTC1);</p>
<p>// Clear the 1 Bit Error Detection Flag</p>
<p>ECCFLX0T0CTL = 0x0000 0200;</p>
<p>// Set NTC 012.5 to Failed</p>
<p>SetNtcSts (0x012, 0x20, NtcSts1.NTCSTS_FAILD, 0);</p>
<p>}</p>
<p>// Check if a FlexRay Temporary buffer (TBF A) RAM single bit ECC error was detected</p>
<p>Else If ((ECCFLX0T1CTL &amp; 0x0001 0002) != 0)</p>
<p>{</p>
<p>// Stores address information for debug</p>
<p>dRamMemFrRamSngBitEccErrAdr = ECCFLX0T1EAD0;</p>
<p>// Clear error flags by setting the ECMCLSSE107 bit of the ECMESSTC1 register</p>
<p>ECMESSTC1_Desired = 0x0000 0080;</p>
<p>WrProtdRegEcm_u32 (ECMESSTC1_Desired, Address of ECMESSTC1);</p>
<p>// Clear the 1 Bit Error Detection Flag</p>
<p>ECCFLX0T1CTL = 0x0000 0200;</p>
<p>// Set NTC 012.5 to Failed</p>
<p>SetNtcSts (0x012, 0x20, NtcSts1.NTCSTS_FAILD, 0);</p>
<p>}</p>
<p>Else</p>
<p>{</p>
<blockquote>
<p>// Do Nothing</p>
</blockquote>
<p>}</p>
<p>// Check if a FlexRay RAM double bit ECC error was detected</p>
<p>If ((ECCFLX0CTL &amp; 0x0002 0004) != 0)</p>
<p>{</p>
<blockquote>
<p>// Stores address information for debug</p>
<p>dRamMemFrRamDblBitEccErrAdr = ECCFLX0EAD0;</p>
</blockquote>
<p>// Clear error flags by setting the ECMCLSSE020 bit of the ECMESSTC0 register</p>
<p>ECMESSTC0_Desired = 0x0010 0000;</p>
<p>WrProtdRegEcm_u32 (ECMESSTC0_Desired, Address of ECMESSTC0);</p>
<p>// Clear the 2 Bit Error Detection Flag</p>
<p>ECCFLX0CTL = 0x0000 0400;</p>
<p>// Set NTC 01D.1 to Failed</p>
<p>SetNtcSts (0x01D, 0x02, NtcSts1.NTCSTS_FAILD, 0);</p>
<p>}</p>
<p>// Check if a FlexRay Temporary buffer (TBF B) RAM double bit ECC error was detected</p>
<p>If ((ECCFLX0T0CTL &amp; 0x0002 0004) != 0)</p>
<p>{</p>
<blockquote>
<p>// Stores address information for debug</p>
<p>dRamMemFrRamTmpBufBDblBitEccErrAdr = ECCFLX0T0EAD0;</p>
</blockquote>
<p>// Clear error flags by setting the ECMCLSSE020 bit of the ECMESSTC0 register</p>
<p>ECMESSTC0_Desired = 0x0010 0000;</p>
<p>WrProtdRegEcm_u32 (ECMESSTC0_Desired, Address of ECMESSTC0);</p>
<p>// Clear the 2 Bit Error Detection Flag</p>
<p>ECCFLX0T0CTL = 0x0000 0400;</p>
<p>// Set NTC 01D.5 to Failed</p>
<p>SetNtcSts (0x01D, 0x20, NtcSts1.NTCSTS_FAILD, 0);</p>
<p>}</p>
<p>// Check if a FlexRay Temporary buffer (TBF A) RAM double bit ECC error was detected</p>
<p>If ((ECCFLX0T1CTL &amp; 0x0002 0004) != 0)</p>
<p>{</p>
<blockquote>
<p>// Stores address information for debug</p>
<p>dRamMemFrRamTmpBufADblBitEccErrAdr = ECCFLX0T1EAD0;</p>
</blockquote>
<p>// Clear error flags by setting the ECMCLSSE020 bit of the ECMESSTC0 register</p>
<p>ECMESSTC0_Desired = 0x0010 0000;</p>
<p>WrProtdRegEcm_u32 (ECMESSTC0_Desired, Address of ECMESSTC0);</p>
<p>// Clear the 2 Bit Error Detection Flag</p>
<p>ECCFLX0T1CTL = 0x0000 0400;</p>
<p>// Set NTC 01D.3 to Failed</p>
<p>SetNtcSts (0x01D, 0x08, NtcSts1.NTCSTS_FAILD, 0);</p>
<p>}</p>
<p>If ((DMASSDTSER2 &amp; 0x0000 8000) != 0)</p>
<p>{</p>
<p>// Stores address information for debug</p>
<p>dRamMemDtsRamEccErrAdr = DMASSRAMSECAD;</p>
<p>// Clear error flags by setting the ECMCLSSE106 bit of the ECMESSTC1 register</p>
<p>ECMESSTC1_Desired = 0x0000 0040;</p>
<p>WrProtdRegEcm_u32 (ECMESSTC1_Desired, Address of ECMESSTC1);</p>
<p>// Clear the 1 Bit Error Detection Flag</p>
<p>DMASSDTSERC = 0x0000 8000;</p>
<p>// Set NTC 012.3 to Failed</p>
<p>SetNtcSts (0x012, 0x08, NtcSts1.NTCSTS_FAILD, 0);</p>
<p>}</p>
<p>// Check for Local RAM Single Bit Soft Failures and set NTC</p>
<p>If (LclRamEccSngBitSoftFailr == TRUE)</p>
<p>{</p>
<p>// Set NTC 012.0 to Failed</p>
<p>SetNtcSts (0x012, 0x01, NtcSts1.NTCSTS_FAILD, 0)</p>
<p>LclRamEccSngBitSoftFailr = FALSE;</p>
<blockquote>
<p>// Increment counter and saturate at LCLRAMSNGBITCNTRMAX_CNT_U08</p>
<p>LclRamEccSngBitCntr++;</p>
<p>// Output Counter value</p>
<p>LclRamEccSngBitCntrOutp = LclRamEccSngBitCntr;</p>
</blockquote>
<p>}</p>
<p>// Check ECM status registers for an I-Cache ECC indication .ECMmSSE014 bit</p>
<p>If (((ECMMESSTR0 &amp; 0x0000 4000) != 0) OR ((ECMCESSTR0 &amp; 0x0000 4000) != 0)))</p>
<p>{</p>
<blockquote>
<p>// Clear error flags by setting the ECMCLSSE014 bit of the ECMESSTC0 register</p>
<p>ECMESSTC0_Desired = 0x0000 4000;</p>
<p>WrProtdRegEcm_u32 (ECMESSTC0_Desired, Address of ECMESSTC0);</p>
<p>// Clear the Error Flags in the Error Status Register</p>
<p>ECCIC1IDSTCLR_PE1 = 0x0000 0003;</p>
<p>ECCIC1ITSTCLR_PE1 = 0x0000 0001;</p>
<p>// Set NTC 012.2 to Failed</p>
</blockquote>
<p>SetNtcSts (0x012, 0x04, NtcSts1.NTCSTS_FAILD, 0);</p>
<p>}</p>
<h3 id="reference-registers-2">Reference Registers</h3>
<p><img src="ElectricPowerSteering_RH850_GM_T1XX_website/static/media/image5.wmf" style="width:5.99583in;height:7.92569in" /></p>
<p><img src="ElectricPowerSteering_RH850_GM_T1XX_website/static/media/image6.wmf" style="width:5.99306in;height:7.27847in" /><img src="ElectricPowerSteering_RH850_GM_T1XX_website/static/media/image7.wmf" style="width:5.99722in;height:4.75069in" /></p>
<p><img src="ElectricPowerSteering_RH850_GM_T1XX_website/static/media/image8.png" style="width:5.99653in;height:5.91736in" /></p>
<p><img src="ElectricPowerSteering_RH850_GM_T1XX_website/static/media/image9.png" style="width:5.99583in;height:5.07986in" /></p>
<h3 id="verification-method-3">Verification Method</h3>
<p>N/A</p>
<h1 id="revision-record-change-approval">Revision Record &amp; Change Approval</h1>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 8%" />
<col style="width: 54%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Rev</strong></td>
<td><strong>Date</strong></td>
<td><strong>Change Control #</strong></td>
<td><strong>Drw</strong></td>
<td><strong>Change Description</strong></td>
</tr>
<tr class="even">
<td>01.00.00</td>
<td>10/21/2015</td>
<td>EA4#1735</td>
<td>SK</td>
<td>Initial Release</td>
</tr>
<tr class="odd">
<td>01.01.00</td>
<td>11/19/2015</td>
<td>EA4#2568</td>
<td>SK</td>
<td>Corrected the polled ECM Bits for I Cache. Refer Anomaly EA4#2524</td>
</tr>
<tr class="even">
<td>02.00.00</td>
<td>03/29/2016</td>
<td>EA4#4865</td>
<td>GM</td>
<td><p>Change from EI Interrupt to Periodic Polling:</p>
<p>CAN single bit and double bit</p>
<p>SPI single bit</p>
<p>Added Flex Ray Single and Double Bit ECC</p>
<p>In RAM failure mode classification check function, error flag is cleared after all 8 addresses have been read.</p>
<p>Added counter for Local RAM single bit ECC</p>
<p>Added SPI RAM double bit ECC from CM101A</p>
<p>Single bit DTS Ram ECC also added to periodic</p></td>
</tr>
<tr class="odd">
<td>02.00.01</td>
<td>3/31/2016</td>
<td>EA4#5094</td>
<td>GM</td>
<td>Add rationale to Local RAM ECC - 1 Bit</td>
</tr>
<tr class="even">
<td>02.01.00</td>
<td>4/11/2016</td>
<td>EA4#5279</td>
<td>SK</td>
<td><p>Combined Reference Registers sections 4.4.6 and 4.4.7</p>
<p>Added SetMcuDiagcIdnData() in SpiDblBitEcc</p>
<p>Added new PIMs for FlexRay Double Bit ECC and CAN Double ECC</p>
<p>Added coniditon to saturate LclRamEccSngBitCntr on reaching LCLRAMSNGBITCNTRMAX</p></td>
</tr>
<tr class="odd">
<td>2.2.0</td>
<td>4/18/2016</td>
<td>EA4#5405</td>
<td>GM</td>
<td><p>Remove set MCU Diag data from SPI double bit ECC</p>
<p>Remove mask from ECC Error Message Flag in CTL registers</p></td>
</tr>
<tr class="even">
<td>3.0.0</td>
<td>07/25/2016</td>
<td>EA4#6656</td>
<td>SK</td>
<td>SPI ECC 2 Bit changed from EI to Polling</td>
</tr>
<tr class="odd">
<td>3.0.1</td>
<td>08/28/2016</td>
<td>EA4#7051</td>
<td>SK</td>
<td>Added instructions to clear ECC Status Registers of CAN, FlexRay and DTS RAM</td>
</tr>
</tbody>
</table>
