---
title: CM106A_McuCoreCfgAndDiagc
linkTitle: CM106A_McuCoreCfgAndDiagc
weight: 2
---

<p><strong>Microcontroller Core Configuration</strong></p>
<p><strong>And</strong></p>
<p><strong>Diagnostics</strong></p>
<p><strong>CM106A</strong></p>
<p><a href="#high-level-description">1. High Level Description 5</a></p>
<p><a href="#sub-function-in-this-document">2. Sub-Function In This Document 5</a></p>
<p><a href="#critical-registers">3. Critical Registers 6</a></p>
<p><a href="#sub-functions">4. Sub-functions 6</a></p>
<p><a href="#sub-function-bist-failure-analysis">4.1. Sub-Function: BIST Failure Analysis 6</a></p>
<p><a href="#ntcs">4.1.1. NTCs 6</a></p>
<p><a href="#san-linkage">4.1.2. SAN Linkage 6</a></p>
<p><a href="#description">4.1.3. Description 6</a></p>
<p><a href="#rationale">4.1.4. Rationale 14</a></p>
<p><a href="#implementation">4.1.5. Implementation 14</a></p>
<p><a href="#verification-method">4.1.6. Verification Method 15</a></p>
<p><a href="#sub-function-cpudma-lock-step-error-forcing-startup-test-failure">4.2. Sub-Function: CPU/DMA Lock Step Error Forcing Startup Test Failure 15</a></p>
<p><a href="#ntcs-1">4.2.1. NTCs 15</a></p>
<p><a href="#san-linkage-1">4.2.2. SAN Linkage 15</a></p>
<p><a href="#description-1">4.2.3. Description 16</a></p>
<p><a href="#rationale-1">4.2.4. Rationale 20</a></p>
<p><a href="#implementation-1">4.2.5. Implementation 21</a></p>
<p><a href="#verification-method-1">4.2.6. Verification Method 23</a></p>
<p><a href="#revision-record-change-approval">5. Revision Record &amp; Change Approval 23</a></p>
<h1 id="high-level-description">High Level Description</h1>
<p>This document describes start up test procedures related to BIST and LockStep.</p>
<p>This MCU provides a BIST (build-in-Self-Test) function that is mainly intended to detect latent faults within the parts which are used as a safety mechanism. The BIST, termed field BIST, consists of LBIST (Logical BIST) and MBIST (Memory BIST). The LBIST scans all flip flops of the target modules and checks if the signature matches the expected one. The result of the field BIST after its execution is stored in BSEQ0ST register. Its initial setting indicates that the field BIST is not passed and can only be replaced by the correct result if the field BIST is executed and no error has been detected.</p>
<p>Lockstep Dual Core (LSDC) for PE (Processor Element):</p>
<p>A redundant Processor Element is implemented based on Lockstep Dual Core (LSDC) architecture containing Master PE, Checker PE and the related compare unit. Both PEs have identical inputs and perform the same processing operations.</p>
<p>The lockstep mode is automatically enabled and cannot be disabled by software. The Checker PE is delayed by two clocks to mitigate dependent faults resulting from power supply or clock disturbances. The Master PE, Checker PE and the related compare unit are target of the LBIST.</p>
<p>Lockstep Dual Core (LSDC) for DMA:</p>
<p>This MCU embodies a redundant Direct Memory Access (DMA Master and Checker). As in the case of LSDC for PE, all inputs to the DMA checker are delayed by two clocks and the outputs from the DMA Master and Checker are compared by the related compare unit. Thus failures within the DMA Master are detected by the compare unit. The lockstep mode is automatically enabled and cannot be disabled by software.</p>
<h1 id="sub-function-in-this-document">Sub-Function In This Document</h1>
<p>Below is a linked list of all sub-functions owned by this document.</p>
<table>
<colgroup>
<col style="width: 73%" />
<col style="width: 26%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Sub-Function Name</strong></td>
<td><strong>Link</strong></td>
</tr>
<tr class="even">
<td>BIST Failure Analysis</td>
<td>4.1</td>
</tr>
<tr class="odd">
<td>CPU/DMA Lock Step Error Forcing Startup Test Failure</td>
<td>4.2</td>
</tr>
</tbody>
</table>
<h1 id="critical-registers">Critical Registers</h1>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 12%" />
<col style="width: 14%" />
<col style="width: 10%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Register</strong></td>
<td><p><strong>Register No.</strong></p>
<p><strong>(regID, selID)</strong></p></td>
<td><strong>Access Permission</strong></td>
<td><p><strong>Init / Periodic</strong></p>
<p><strong>Verification</strong></p></td>
<td><strong>Masking</strong></td>
<td><strong>Expected Value</strong></td>
<td><strong>Protn Score From Eval Sheet</strong></td>
</tr>
<tr class="even">
<td>OPBT0</td>
<td>N/A</td>
<td><p>SV – R/W</p>
<p>UM – R/W</p></td>
<td>Init</td>
<td>None</td>
<td>0x7F8F FFFB</td>
<td>1</td>
</tr>
<tr class="odd">
<td>OPBT2</td>
<td>N/A</td>
<td><p>SV – R/W</p>
<p>UM – R/W</p></td>
<td>Init</td>
<td>None</td>
<td>0xBFFF FFFF</td>
<td>1</td>
</tr>
</tbody>
</table>
<h1 id="sub-functions">Sub-functions</h1>
<h2 id="sub-function-bist-failure-analysis">Sub-Function: BIST Failure Analysis</h2>
<p>Return to sub-function list link: Sub-Function In This Document</p>
<h3 id="ntcs">NTCs</h3>
<p>N/A</p>
<h3 id="san-linkage">SAN Linkage</h3>
<p><strong>SAN-1082:</strong></p>
<p>In case an ECC error during the transfer of the Field BIST parameters to the Field BIST controller has occurred, an error signal will be issued to ECM. In that case operation <strong>shall</strong> not be entered.</p>
<p><strong>SAN-1080:</strong></p>
<p>The result of the field BIST <strong>shall</strong> be checked before executing any safety related application program. The execution of the Field BIST <strong>shall</strong> not be disabled in order to detect latent faults of the targeted parts.</p>
<h3 id="description">Description</h3>
<p>This sub-function checks if an ECC 2-bit error has been detected during the transfer of the Field BIST parameters to the Field BIST controller during BIST execution.</p>
<p>This sub-function checks if the execution of MCU Field BIST completed successfully. If the execution of the BIST is not completed, the result of LBIST and MBIST cannot be checked.</p>
<p>This sub-function checks the results of MBIST (Memory BIST) and LBIST (Logic BIST) when execution of BIST is completed successfully.</p>
<p>Register Info:</p>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 44%" />
<col style="width: 14%" />
<col style="width: 13%" />
</colgroup>
<tbody>
<tr class="odd">
<td rowspan="2"><strong>Register</strong></td>
<td rowspan="2"><strong>Use</strong></td>
<td colspan="2"><strong>Register Access</strong></td>
</tr>
<tr class="even">
<td><strong>SV</strong></td>
<td><strong>UM</strong></td>
</tr>
<tr class="odd">
<td>BSEQ0CTL (Field BIST Control Register)</td>
<td>Controls the execution of BIST after reset release</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>ECMPE1 (ECM Pseudo Error Trigger Register 1)</td>
<td>Used to generate a pseudo error for test purposes</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>ECMMESSTR1 (ECM Master Error Source Status Register 1)</td>
<td>Indicates the state of individual internal error sources, which is irrelevant to the setting of the error mask</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>ECMCESSTR1 (ECM Checker Error Source Status Register 1)</td>
<td>Indicates the state of individual internal error sources, which is irrelevant to the setting of the error mask</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>ECMESSTC1 (ECM Error Source Status Clear Trigger Register 1)</td>
<td>Used to clear the individual error source status of the ECM master/checker error source status register 1</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>BSEQ0ST (BIST Error Status Register)</td>
<td>Register holds the error status of field BIST</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>BSEQ0STB (BIST Error Status Inversion Register)</td>
<td>Register holds the inverse of the bits of the BSEQ0ST register</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>MBISTREF (Memory BIST Signature Register)</td>
<td>Register holds the expected value when memory BIST is executed.</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>MBISTSIG (Memory BIST Signature Result Register)</td>
<td>Register holds the result value of memory BIST execution.</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>LBISTREF1 (Logic BIST signature register 1)</td>
<td>Register holds the expected value when logic BIST1 is executed.</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>LBISTSIG1 (Logic BIST Signature Result Register 1)</td>
<td>Register holds the result value of logic BIST1 execution.</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>LBISTREF2 (Logic BIST signature register 2)</td>
<td>Register holds the expected value when logic BIST2 is executed.</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>LBISTSIG2 (Logic BIST Signature Result Register 2)</td>
<td>Register holds the result value of logic BIST2 execution.</td>
<td>R/W</td>
<td>R/W</td>
</tr>
</tbody>
</table>
<p><img src="ElectricPowerSteering_RH850_GM_T1XX_website/static/media/image1.png" style="width:6.49514in;height:5.94306in" /></p>
<p><img src="ElectricPowerSteering_RH850_GM_T1XX_website/static/media/image2.png" style="width:6.49097in;height:7.15069in" /></p>
<p><img src="ElectricPowerSteering_RH850_GM_T1XX_website/static/media/image3.png" style="width:6.49792in;height:7.72014in" /></p>
<p><img src="ElectricPowerSteering_RH850_GM_T1XX_website/static/media/image4.png" style="width:6.49097in;height:7.29722in" /></p>
<p><img src="ElectricPowerSteering_RH850_GM_T1XX_website/static/media/image5.png" style="width:6.49306in;height:5.18889in" /></p>
<p><img src="ElectricPowerSteering_RH850_GM_T1XX_website/static/media/image6.png" style="width:6.49722in;height:4.91944in" /></p>
<h3 id="rationale">Rationale</h3>
<p>BSEQ0CTL controls the execution of field BIST after reset release. This register is only initialized by POCRES, CVMRES or DBRES.</p>
<p>Run BIST only on POCRES. So, write the bit BSEQ0CTL.HWBISTEXE = 0 to disable BIST from running on EXTRES or ECM Reset. This test has been excluded it from other types of resets to reduce start up time. SAN mentions that we only need to perform this test once only on POR. It is acceptable to not run BIST on CVM reset because the system will go to a safe state in that case.</p>
<p>When BSEQ0CTL.HWBISTEXE is set to 1, BIST is executed at a pin reset (EXTRES) or ECM reset (ECMRES). FieldBIST is not executed regardless of the HWBISTEXE value at SWRES.</p>
<p>Single bit ECC faults in BIST are detected and corrected by the Hardware.</p>
<p>The value of ECMMESSTR1 after a reset at cold start is 0000 0000H. Design assumes that the ECMMESSTR1 register will indicate a BIST 2 bit ECC failure. Single bit ECC errors are not described in this sub-function.</p>
<h3 id="implementation">Implementation</h3>
<h4 id="initialization-mcucorecfganddiagcinit1">Initialization (McuCoreCfgAndDiagcInit1)</h4>
<p><u>Pseudo Code:</u></p>
<p>// Only perform test if the following resets have occurred:</p>
<p>// Power On Reset when not in debug mode</p>
<p>GetMcuDiagcIdnData( Address of McuDiagData0);</p>
<p>If (McuDiagData0 == McuDiagc1.MCUDIAGC_PWRONRST)</p>
<p>{</p>
<blockquote>
<p>// Check if the chip is in Debug Mode</p>
<p>If ((SYSDEBUGMODE == 0) OR (SYSDEBUGMODEB == 1))</p>
<p>{</p>
<p>// Check if 1Bit or 2Bit ECC Error occurred during BIST execution</p>
<p>If ((ECMMSSE108 == 1) OR (ECMCSSE108 == 1) OR</p>
<p>(ECMMSSE109 == 1) OR (ECMCSSE109 == 1))</p>
<p>{</p>
<p>SetMcuDiagcIdnData (McuDiagc1.MCUDIAGC_BISTECCERR, 0);</p>
<p>}</p>
<p>Else</p>
<p>{</p>
<p>//Check if Both Registers indicate BIST execution has NOT completed successfully</p>
<p>If ((SYSBIST_RESULT != 02) AND (SYSBIST_RESULTB != 05))</p>
<p>{</p>
<p>SetMcuDiagcIdnData (McuDiagc1.MCUDIAGC_BISTNOTCMPLERR, 0);</p>
<p>}</p>
<p>// At least one Register indicates BIST Completed Successfully</p>
<p>Else</p>
<p>{</p>
<p>// Check if there were any errors during LBIST execution</p>
<p>If (SYSLBISTSIG1 != LBISTSIG1) OR (SYSLBISTSIG2 != LBISTSIG2))</p>
<p>{</p>
<p>SetMcuDiagcIdnData (McuDiagc1.MCUDIAGC_LOGLBISTERR, 0);</p>
<p>}</p>
<p>Else</p>
<p>{</p>
<p>// Check if there were any errors during MBIST execution</p>
<p>If (SYSMBISTSIG != MBISTSIG)</p>
<p>{</p>
<p>SetMcuDiagcIdnData (McuDiagc1.MCUDIAGC_MEMBISTERR, 0);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>}</p>
</blockquote>
<p>}</p>
<h4 id="event-driven">Event Driven</h4>
<p>N/A</p>
<h4 id="periodic">Periodic</h4>
<p>N/A</p>
<h3 id="verification-method">Verification Method</h3>
<p>N/A</p>
<h2 id="sub-function-cpudma-lock-step-error-forcing-startup-test-failure">Sub-Function: CPU/DMA Lock Step Error Forcing Startup Test Failure</h2>
<p>Return to sub-function list link: Sub-Function In This Document</p>
<h3 id="ntcs-1">NTCs</h3>
<p>N/A</p>
<h3 id="san-linkage-1">SAN Linkage</h3>
<p><strong>SAN-62:</strong></p>
<p>It is possible to perform a functional test of the compare unit by fault injection. This optional test <strong>can</strong> be executed at start-up.</p>
<p><strong>SAN-109,110:</strong></p>
<p>The LSDC self-test <strong>shall</strong> be executed by writing to the mentioned register to forcibly cause a compare error:</p>
<p>111111_11111111_00000111_00001111 to DMACMPERR together with the PROT bit in the PDMA_COMP_CNTRL register. Writing this value will generate an error that is flagged as compare error in the ECM.</p>
<h3 id="description-1">Description</h3>
<p>This sub-function is responsible for performing a diagnostic check that the CPU and DMA controller lock step error detection mechanism of the MCU is working correctly.</p>
<p>Register Info:</p>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 44%" />
<col style="width: 14%" />
<col style="width: 13%" />
</colgroup>
<tbody>
<tr class="odd">
<td rowspan="2"><strong>Register</strong></td>
<td rowspan="2"><strong>Use</strong></td>
<td colspan="2"><strong>Register Access</strong></td>
</tr>
<tr class="even">
<td><strong>SV</strong></td>
<td><strong>UM</strong></td>
</tr>
<tr class="odd">
<td>ECMEMK0 (ECM Error Mask Register 0)</td>
<td>Used to mask the individual error sources of the ERROROUT output.</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>ECMIRCFG0 (ECM Internal Reset Configuration Register 0)</td>
<td><p>Used to set the generation of internal resets</p>
<p>(ECMRES) in response to internal errors</p></td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>ECMESSTC0 (ECM Error Source Status Clear Trigger Register 0)</td>
<td>Used to clear the individual error source status of the ECM master/checker error source status register 0</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>ECMMESSTR0 (ECM Master Error Source Status Register 0)</td>
<td>Indicates the state of individual internal error sources, which is irrelevant to the setting of the error mask</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>ECMCESSTR0 (ECM Checker Error Source Status Register 0)</td>
<td>Indicates the state of individual internal error sources, which is irrelevant to the setting of the error mask</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>PDMA_COMP_CNTRL (DMA Control Register)</td>
<td>Can control the output signals on the checker side of the DMAC</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="odd">
<td>TESTCOMPREG0 (Comparator Test Register 0)</td>
<td>Used for the lockstep function of the CPU1. Combining TESTCOMPREG1 with TESTCOMPREG0 enables self-diagnosis of the lockstep function</td>
<td>R/W</td>
<td>R/W</td>
</tr>
<tr class="even">
<td>TESTCOMPREG1 (Comparator Test Register 1)</td>
<td>Used for the lockstep function of the CPU1. Combining TESTCOMPREG1 with TESTCOMPREG0 enables self-diagnosis of the lockstep function</td>
<td>R/W</td>
<td>R/W</td>
</tr>
</tbody>
</table>
<p><img src="ElectricPowerSteering_RH850_GM_T1XX_website/static/media/image7.png" style="width:6.49375in;height:7.81597in" /></p>
<p><img src="ElectricPowerSteering_RH850_GM_T1XX_website/static/media/image8.png" style="width:6.49167in;height:7.90208in" /></p>
<p><img src="ElectricPowerSteering_RH850_GM_T1XX_website/static/media/image9.png" style="width:6.49167in;height:7.80278in" /></p>
<p><img src="ElectricPowerSteering_RH850_GM_T1XX_website/static/media/image10.png" style="width:6.49167in;height:7.75in" /></p>
<h3 id="rationale-1">Rationale</h3>
<p>After a reset is released and before the lockstep errors are enabled in the ECM, registers in the master and the slave Processor Elements should match. Otherwise, we could end up with a lockstep fault.</p>
<p>Some registers are ‘undefined’ following a reset, meaning it is likely that the master PE and the checker PE registers will contain different values. Master and slave registers should be initialized by the software to avoid having different values. The application software needs to only write to the master PE registers explicitly; the checker PE will reflect those writes.</p>
<p>Uninitialized registers are assumed to be initialized with their suggested initial values in the Bootloader.</p>
<p>We skip the startup test if a core compare fault already occurred because the startup sequence does a check on all the status bits at MCUinit() and notifies a CPU/DMA LockStep error. If an error is already present and we are notified of it, there is no need to perform another startup test to recreate the situation.</p>
<h3 id="implementation-1">Implementation</h3>
<h4 id="initialization-mcucorecfganddiagcinit2">Initialization (McuCoreCfgAndDiagcInit2)</h4>
<p><u>Psuedo Code:</u></p>
<p>// Only perform test if the following resets have occurred:</p>
<p>// Power On Reset, Flash Programming Complete, Soft Rest or Hard Reset</p>
<p>ChkForStrtUpTest (Address of ExecStrtUpTest);</p>
<p>If (ExecStrtUpTest == TRUE)</p>
<p>{</p>
<blockquote>
<p>// Check if the chip is in Debug Mode</p>
<p>If ((SYSDEBUGMODE == 0) OR (SYSDEBUGMODEB == 1))</p>
<p>{</p>
<p>// Check if a DMA or CPU Lockstep compare fault has already occurred</p>
<p>If ((ECMMSSE001 == 0) AND (ECMCSSE001 == 0))</p>
<p>{</p>
<p>// Save contents of ECMEMK0 and ECMIRCFG0 to a temp variable in RAM</p>
<p>ECMEMK0_Temp = ECMEMK0;</p>
<p>ECMMICFG0_Temp = ECMMICFG0;</p>
<p>ECMNMICFG0_Temp = ECMNMICFG0;</p>
<p>ECMIRCFG0_Temp = ECMIRCFG0;</p>
<p>// Mask the Error Source 1, NMI Interrupt and MI Interrupt of the ECMmESSTR0</p>
<p>ECMEMK0_Desired = ECMEMK0 | 0x0000 0002;</p>
<p>ECMMICFG0_Desired = ECMMICFG0 &amp; ~ (0x0000 0002);</p>
<p>ECMNMICFG0_Desired = ECMNMICFG0 &amp; ~ (0x0000 0002);</p>
<p>ECMIRCFG0_Desired = ECMIRCFG0 &amp; ~ (0x0000 0002);</p>
<p>WrProtdRegEcm_u32 (ECMEMK0_Desired, Address of ECMEMK0);</p>
<p>WrProtdRegEcm_u32 (ECMMICFG0_Desired, Address of ECMMICFG0);</p>
<p>WrProtdRegEcm_u32 (ECMNMICFG0_Desired, Address of ECMNMICFG0);</p>
<p>WrProtdRegEcm_u32 (ECMIRCFG0_Desired, Address of ECMIRCFG0);</p>
<p>// Inject Fault to cause a DMA Lockstep Error</p>
<p>PDMACOMPPDMA_COMP_CNTRL = 0xBFFF070F;</p>
<p>// Wait until read from the TESTCOMPREG0 is complete to trigger the fault</p>
<p>__asm ("SYNCM");</p>
<p>// Check if the DMA Lockstep fault was notified</p>
<p>If ((ECMMSSE001 == 0) OR (ECMCSSE001 == 0)</p>
<p>{</p>
<p>// DMA Lockstep test failed</p>
<p>SetMcuDiagcIdnData (McuDiagc1.MCUDIAGC_DMALOCKSTEPERR, 0);</p>
<p>}</p>
<p>Else</p>
<p>{</p>
<p>// Clear Notification</p>
<p>ECMESSTC0_Desired = 0x0000 0002;</p>
<p>WrProtdRegEcm_u32 (ECMESSTC0_Desired, Address of ECMESSTC0);</p>
<p>// Inject Fault to cause a CPU Lockstep Error</p>
<p>TESTCOMPREG0 = 0x11111111;</p>
<p>TESTCOMPREG1 = 0X22222222;</p>
<p>// According to SAN, a Read is required to induce a CPU Lockstep Fault</p>
<p>CoreCompTestRegRead = TESTCOMPREG0;</p>
<p>// Wait until read from the TESTCOMPREG0 is complete to trigger the fault</p>
<p>__asm ("SYNCM");</p>
<p>// Check if the CPU Lockstep fault was notified</p>
<p>If ((ECMMSSE001 == 0) OR (ECMCSSE001 == 0))</p>
<p>{</p>
<p>SetMcuDiagcIdnData (McuDiagc1.MCUDIAGC_CPULOCKSTEPERR, 0);</p>
<p>}</p>
<p>}</p>
<p>// Clear Notification</p>
<p>ECMESSTC0_Desired = 0x0000 0002;</p>
<p>WrProtdRegEcm_u32 (ECMESSTC0_Desired, Address of ECMESSTC0);</p>
<p>// Restore the contents of the ECMEMK0 and EMCIRCFG0 register</p>
<p>WrProtdRegEcm_u32 (ECMEMK0_Temp, Address of ECMEMK0);</p>
<p>WrProtdRegEcm_u32 (ECMMICFG0_ Temp, Address of ECMMICFG0);</p>
<p>WrProtdRegEcm_u32 (ECMNMICFG0_ Temp, Address of ECMNMICFG0);</p>
<p>WrProtdRegEcm_u32 (ECMIRCFG0_Temp, Address of ECMIRCFG0);</p>
<p>}</p>
</blockquote>
<p>}</p>
<p>}</p>
<h4 id="initialization-mcucorecfganddiagcinit3">Initialization (McuCoreCfgAndDiagcInit3)</h4>
<p>This is an empty Initialization function that contains no logic.</p>
<p>McuCoreCfgAndDiagcInit3 is an RTE function which is required for memory mapping PIM and Calibration definitions.</p>
<h4 id="event-driven-1">Event Driven</h4>
<p>N/A</p>
<h4 id="periodic-1">Periodic</h4>
<p>N/A</p>
<h3 id="verification-method-1">Verification Method</h3>
<p>N/A</p>
<h1 id="revision-record-change-approval">Revision Record &amp; Change Approval</h1>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 8%" />
<col style="width: 54%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Rev</strong></td>
<td><strong>Date</strong></td>
<td><strong>Change Control #</strong></td>
<td><strong>Drw</strong></td>
<td><strong>Change Description</strong></td>
</tr>
<tr class="even">
<td>01.00.00</td>
<td>10/21/2015</td>
<td>EA4#1736</td>
<td>SK</td>
<td>Initial Release</td>
</tr>
<tr class="odd">
<td>02.00.00</td>
<td>02/11/2016</td>
<td>EA4#3810</td>
<td>SK</td>
<td>Replaced GetMcuDiagcData with ChkForStrtUpTest to check for startup test condition</td>
</tr>
<tr class="even">
<td>02.01.00</td>
<td>03/29/2016</td>
<td>EA4#5047</td>
<td>EC</td>
<td>Remove unnecessary syncms per latest Renesas guidance, handle 1 bit ECC Error during MBIST same as 2 bit, remove ChkForStrtUpTest and added check for McuDiagcData for poweron reset</td>
</tr>
<tr class="odd">
<td>2.2.0</td>
<td>04/04/2016</td>
<td>EA4#5047</td>
<td>GM</td>
<td>Added syncms that were removed in previous revision</td>
</tr>
<tr class="even">
<td>2.2.1</td>
<td>04/05/2016</td>
<td>EA4#5047</td>
<td>GM</td>
<td>Change BIST2BITERR to BISTECCERR in BIST Failure Analysis sub-function implementation</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
