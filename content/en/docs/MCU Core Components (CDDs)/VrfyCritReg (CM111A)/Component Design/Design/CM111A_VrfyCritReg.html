---
title: CM111A_VrfyCritReg
linkTitle: CM111A_VrfyCritReg
weight: 2
---

<p><strong>Verify Critical Register</strong></p>
<p><strong>(VrfyCritReg)</strong></p>
<p><strong>FDD #CM111A</strong></p>
<p><a href="#high-level-description">1. High Level Description 3</a></p>
<p><a href="#sub-function-in-this-document">2. Sub-Function In This Document 3</a></p>
<p><a href="#critical-registers">3. Critical Registers 3</a></p>
<p><a href="#__RefHeading___Toc448933443">3.1. Sub-Function: VrfyCritRegInit1 3</a></p>
<p><a href="#ntcs">3.1.1. NTCs 3</a></p>
<p><a href="#san-linkage">3.1.2. SAN Linkage 3</a></p>
<p><a href="#description">3.1.3. Description 4</a></p>
<p><a href="#rationale">3.1.4. Rationale 4</a></p>
<p><a href="#implementation">3.1.5. Implementation 5</a></p>
<p><a href="#sub-function-vrfycritregper1">3.2. Sub-Function: VrfyCritRegPer1 6</a></p>
<p><a href="#ntcs-1">3.2.1. NTCs 6</a></p>
<p><a href="#san-linkage-1">3.2.2. SAN Linkage 6</a></p>
<p><a href="#description-1">3.2.3. Description 6</a></p>
<p><a href="#rationale-1">3.2.4. Rationale 6</a></p>
<p><a href="#implementation-1">3.2.5. Implementation 6</a></p>
<p><a href="#verification-method">3.2.6. Verification Method 8</a></p>
<p><a href="#__RefHeading___Toc448933456">4. Revision Record &amp; Change Approval 8</a></p>
<h1 id="high-level-description">High Level Description</h1>
<p>This document describes the microcontroller configuration for the critical register verification functions. Critical registers are ones whose contained values are considered vital to safety or function (secondary to safety) beyond the protections provided by protection hardware and software.</p>
<p>The functions described herein perform read back and value verification functions. If a mismatch is detected in the result shall be transition to a safe state preceded by non-volatile storage of the specific cause of this decision if possible.</p>
<p>The initial lists of critical registers were obtained by reviewing the recommendations of Renesas’ Safety Application Note ver 1.20.</p>
<p>Some of these recommendations were not followed because they would require masking off of unpredictable bits and some may have been rejected if the particular hardware interface is not used.</p>
<h1 id="sub-function-in-this-document">Sub-Function In This Document</h1>
<p>Below is a list of all sub-functions owned by this document.</p>
<table>
<colgroup>
<col style="width: 80%" />
<col style="width: 19%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Sub-Function Name</strong></td>
<td><strong>Link</strong></td>
</tr>
<tr class="even">
<td>Check critical registers once at initialization ( VrfyCritRegInit1 )</td>
<td><a href="#_Sub-Function%3A_VrfyCritRegInit1">3.1</a></td>
</tr>
<tr class="odd">
<td>Check critical registers during periodic updates ( VrfyCritRegPer1 )</td>
<td><a href="#sub-function-vrfycritregper1">3.2</a></td>
</tr>
<tr class="even">
<td>Empty Initial Sub-function ( VrfyCritRegInit2 )</td>
<td><a href="#_Sub-Function%3A_VrfyCritRegInit2">3.3</a></td>
</tr>
</tbody>
</table>
<h1 id="critical-registers">Critical Registers</h1>
<h2 id="sub-function-vrfycritreginit1">Sub-Function: VrfyCritRegInit1</h2>
<h3 id="ntcs">NTCs</h3>
<p>N/A</p>
<h3 id="san-linkage">SAN Linkage</h3>
<p>5.2 Read back of configuration static register should be done at start-up [SAN-P1x-0504].</p>
<p>7.2 Read back the static configuration registers shall be done once at start-up [SAN-P1x-0704]. This includes to check that ECC is enabled, error notification to ECM and test registers.</p>
<p>8.2 At startup it shall be checked that the address parity check is enabled by reading back the related control register.</p>
<p>9.2 Read back DFECCCTL and FERRINT registers should be done once at start-up.</p>
<p>10.2 Read back the static configuration register once at start-up shall be done to ensure that the correct values are set [SAN-P1x-1005]. This includes to check that ECC is enabled and error notification to the ECM.</p>
<p>11.2 Read back the static configuration register once at start-up shall be done to ensure that the default settings are correctly set.</p>
<p>13.2 Read back the static configuration register once at start-up shall be done to ensure that the correct values are set. This includes to check that ECC is enabled and error notification to ECM as well [SAN-P1x-1305].</p>
<p>14.2 The control register shall be also read back once after configuration to ensure the CLM is enable [SAN-P1x-</p>
<p>1403].</p>
<p>15.2 In order to confirm the operation of the locking function, the SW shall write "0" to CVMDIAGMEW and CVMFBISTMEW bits and verify that "1" is not overwritten by "0" by reading back CVMDE register [SAN-P1x-1508].</p>
<p>15.2 Moreover static configuration register shall be read-back and verified to ensure that the correct values are</p>
<p>set.</p>
<p>16.2 Static configuration register shall be read back and verified once at start-up to ensure that the related register</p>
<p>have the proper configuration.</p>
<p>25.2 The configuration from the mode register shall be read to confirm that the correct operating mode (normal</p>
<p>mode) has been entered and/or that the proper value has been applied to the external mode pins.</p>
<p>29.2 Field BIST control register shall be read back and verified to ensure that the Field BIST is enabled [SAN-P1x-2902].</p>
<p>31.2 the user shall check that the transfer of the data is carried out without error. This can be done by reading back the option byte register and checking the content.</p>
<h3 id="description">Description</h3>
<p>This sub-function reads values from critical registers and verifies that the stable portion retains the expected value which has been deemed to be critical.</p>
<h3 id="rationale">Rationale</h3>
<p>This function is intended to be called once per update period so that it can verify that critical registers still hold the values expected. Because an NTC code is set on failure, this function must not be called until after the Diagnostic Manager has run to start the handling of these calls</p>
<p>Caution: In order to record a unique number which will identify which value has failed this test, the number of “periodic” test critical registers must be maintained/communicated to the “initialization” code to use as the starting value for its count.</p>
<h3 id="implementation">Implementation</h3>
<p>Each entry in the register table shall be read, bitwise masked (an AND operation) with a value specific to the register to handle unused or dynamic bits and compared to the expected value. Any mismatch indicates a non-recoverable error so the code shall set a NTC diagnostic code and stop iterating.</p>
<p>struct NonSysCritRegRec1</p>
<p>{</p>
<p>uint CritRegAdr;</p>
<p>uint CritRegVal;</p>
<p>uint CritRegMask;</p>
<p>}</p>
<p>struct NonSysCritRegRec1 <strong>Inin</strong>CritReg<strong>8</strong>BitChk[NROFININCRITREG8BIT_CNT_U16];</p>
<p>struct NonSysCritRegRec1 <strong>Inin</strong>CritReg<strong>16</strong>BitChk[NROFININCRITREG16BIT_CNT_U16];</p>
<p>struct NonSysCritRegRec1 <strong>Inin</strong>CritReg<strong>32</strong>BitChk[NROFININCRITREG32BIT_CNT_U16];</p>
<p>struct NonSysCritRegRec1 <strong>Per</strong>CritReg<strong>8</strong>BitChk[NROFPERCRITREG8BIT_CNT_U16];</p>
<p>struct NonSysCritRegRec1 <strong>Per</strong>CritReg<strong>16</strong>BitChk[NROFPERCRITREG16BIT_CNT_U16];</p>
<p>struct NonSysCritRegRec1 <strong>Per</strong>CritReg<strong>32</strong>BitChk[NROFPERCRITREG32BIT_CNT_U16];</p>
<p>void VrfyCritRegInit1( void )</p>
<p>{</p>
<p>temp boolean CritRegInitTestPassd = TRUE;</p>
<blockquote>
<p>//CritRegFltTyp = 0 when there is no error, CritRegFltTyp = 1 when there is a non-system critical //register error, CritRegFltTyp = 2 when there is a system critical error</p>
</blockquote>
<p>uint CritRegFltTyp = 0;</p>
<p>//If there is one bad comparison no other critical registers need to be verified</p>
<p>//configure IninCritReg#BitChk as a trusted function because it needs to run in supervisor mode</p>
<blockquote>
<p>For each <strong>Inin</strong>CritReg<strong>#</strong>BitChk[] struct instance, loop over all “init” critical register values until CritRegFltTyp != 0;</p>
<p>{</p>
<p>Read the register’s value,</p>
<p>mask the register’s value with the mask value for this register;</p>
<p>if (the masked value != expected value)</p>
<p>CritRegFltTyp = 1;</p>
<p>else</p>
<p>Nothing;</p>
</blockquote>
<p>}</p>
<p>//configure SysCritRegIninChk as a trusted function because it needs to run in supervisor mode</p>
<p>For each SysCritRegIninChk, verify all “init” critical register values until CritRegFltTyp != 0;</p>
<blockquote>
<p>{</p>
<p>Read the register’s value,</p>
<p>mask the register’s value with the mask value for this register;</p>
<p>if (the masked value != expected value)</p>
<p>SysCritRegInitTestPassd = FALSE;</p>
<p>CritRegFltTyp = 2;</p>
<p>else</p>
<p>Nothing;</p>
</blockquote>
<p>}</p>
<p>if (CritRegFltTyp = 0)</p>
<blockquote>
<p>SetNtcSts( NtcNr1.NTCNR_0x20, 0, NtcSts1.NTCSTS_PASSD, 0);</p>
<p>else</p>
<p>SetNtcSts( NtcNr1.NTCNR_0x20, CritRegFltTyp, NtcSts1.NTCSTS_FAILD, 0);</p>
</blockquote>
<p>}</p>
<h2 id="sub-function-vrfycritregper1">Sub-Function: VrfyCritRegPer1</h2>
<p>Return to sub-function list link: Sub-Function In This Document</p>
<h3 id="ntcs-1">NTCs</h3>
<p>Critical Register Verification Fault NTC #0x20.</p>
<h3 id="san-linkage-1">SAN Linkage</h3>
<p>4.5.1 For PBG0A the customer should ensure that the guard setting settings are not<br />
accidently changed (e.g. periodic check of the protection setting register, MPU and so on).</p>
<h3 id="description-1">Description</h3>
<p>This sub-function reads values from critical registers and verifies that the stable portion retains the expected value which has been deemed to be critical.</p>
<h3 id="rationale-1">Rationale</h3>
<p>This function is intended to be called once per update period so that it can verify that critical registers still hold the values expected.</p>
<h3 id="implementation-1">Implementation</h3>
<p>Each entry in the register table shall be read, bitwise “ANDed” with a mask specific to the register and compared to the expected value. Any mismatch indicates a non-recoverable error so the code shall set an NTC code.</p>
<p>void VrfyCritRegPer1( void )</p>
<p>{</p>
<p>temp boolean CritRegPerTestPassd = TRUE;</p>
<blockquote>
<p>//CritRegFltTyp = 0 when there is no error, CritRegFltTyp = 1 when there is a non-system critical //register error, CritRegFltTyp = 2 when there is a system critical error</p>
</blockquote>
<p>CritRegFltTyp = 0</p>
<p>//If there is one bad comparison no other critical registers need to be verified</p>
<p>//configure PerCritReg#BitChk as a trusted function because it needs to run in supervisor mode</p>
<blockquote>
<p>For each <strong>Per</strong>CritReg<strong>#</strong>BitChk[] struct instance, loop over all “periodic” critical register values until CritRegFltTyp != 0;</p>
<p>{</p>
<p>Read the register’s value,</p>
<p>mask the register’s value with the mask value for this register;</p>
<p>if (the masked value != expected value)</p>
<p>CritRegFltTyp = 1;</p>
<p>else</p>
<p>Nothing;</p>
</blockquote>
<p>}</p>
<p>//configure SysCritRegIninChk as a trusted function because it needs to run in supervisor mode</p>
<p>For each SysCritRegPerChk, verify all “init” critical register values until CritRegFltTyp != 0;</p>
<blockquote>
<p>{</p>
<p>Read the register’s value,</p>
<p>mask the register’s value with the mask value for this register;</p>
<p>if (the masked value != expected value)</p>
<p>CritRegFltTyp = 2;</p>
<p>else</p>
<p>Nothing;</p>
</blockquote>
<p>}</p>
<p>if (CritRegFltTyp = 0)</p>
<blockquote>
<p>SetNtcSts( NtcNr1.NTCNR_0x20, 0, NtcSts1.NTCSTS_PASSD, 0);</p>
<p>else</p>
<p>SetNtcSts( NtcNr1.NTCNR_0x20, CritRegFltTyp, NtcSts1.NTCSTS_FAILD, 0);</p>
</blockquote>
<p>}</p>
<h4 id="periodic">Periodic</h4>
<p>Iteration period T =10 msec second.</p>
<h3 id="verification-method">Verification Method</h3>
<p>N/A<span id="_Sub-Function%3A_VrfyCritRegInit2" class="anchor"></span></p>
<h1 id="revision-record-change-approval">Revision Record &amp; Change Approval</h1>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 12%" />
<col style="width: 8%" />
<col style="width: 54%" />
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Rev</strong></td>
<td><strong>Date</strong></td>
<td><strong>Change Control #</strong></td>
<td><strong>Drw</strong></td>
<td><strong>Change Description</strong></td>
</tr>
<tr class="even">
<td>01.00.00</td>
<td>01/14/2016</td>
<td>2772</td>
<td>EC</td>
<td>Initial Release</td>
</tr>
<tr class="odd">
<td>02.00.00</td>
<td>03/28/2016</td>
<td>4992</td>
<td>EC</td>
<td>Restore separate init entry and masks, both set NTC once per entry with second parameter being index to the problem register</td>
</tr>
<tr class="even">
<td>02.01.00</td>
<td>04/07/2016</td>
<td>4992</td>
<td>SK</td>
<td><p>Deleted Init2 because we already have an RTE Init1.</p>
<p>Updated Init1 and Per1 to show different parameter byte info for different register index.</p></td>
</tr>
<tr class="odd">
<td>02.02.00</td>
<td>04/20/2016</td>
<td>5444</td>
<td>GM</td>
<td><p>Add structure definitions for 8bit, 16bit and 32bit non-system critical register check.</p>
<p>Add separate definition for system critical register check.</p>
<p>Manage system and non-system critical register faults with different NTC parameter bits.</p></td>
</tr>
</tbody>
</table>
