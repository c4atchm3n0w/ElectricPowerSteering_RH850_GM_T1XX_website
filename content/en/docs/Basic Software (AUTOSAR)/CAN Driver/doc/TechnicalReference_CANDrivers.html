---
title: TechnicalReference_CANDrivers
linkTitle: TechnicalReference_CANDrivers
weight: 5
---

<!DOCTYPE html><html>
<head>
<title></title>
<style type="text/css">
<!--
.xflip {
    -moz-transform: scaleX(-1);
    -webkit-transform: scaleX(-1);
    -o-transform: scaleX(-1);
    transform: scaleX(-1);
    filter: fliph;
}
.yflip {
    -moz-transform: scaleY(-1);
    -webkit-transform: scaleY(-1);
    -o-transform: scaleY(-1);
    transform: scaleY(-1);
    filter: flipv;
}
.xyflip {
    -moz-transform: scaleX(-1) scaleY(-1);
    -webkit-transform: scaleX(-1) scaleY(-1);
    -o-transform: scaleX(-1) scaleY(-1);
    transform: scaleX(-1) scaleY(-1);
    filter: fliph + flipv;
}
-->
</style>
</head>
<body>
<a name=1></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-1_1.png"/><br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>&#160;<br/>&#160;<br/>&#160;<br/>&#160;<br/>&#160;<br/>&#160;<br/>&#160;<br/>&#160;<br/>&#160;<br/><b>Vector CAN Driver&#160;<br/></b>Technical Reference&#160;<br/>&#160;<br/>Reference Implementation 1.5&#160;<br/>&#160;<br/>&#160;<br/>Version 3.01.01&#160;<br/>&#160;<br/>&#160;<br/>&#160;<br/>&#160;<br/>&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>&#160;<br/>&#160;<br/>
<b>Authors:&#160;&#160;</b>H. Honert, K. Emmert&#160;<br/><b>Version:&#160;</b><br/>
3.01.01&#160;<br/>
<b>Status:&#160;</b><br/>
released&#160;(in preparation/completed/inspected/released)&#160;<br/>
&#160;<br/>&#160;<br/>&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
1&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=2></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-2_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>1&#160;&#160;Document Information&#160;</b><br/>
<b>1.1&#160;&#160;History&#160;</b><br/>
<b>Author&#160;</b><br/>
<b>Date&#160;</b><br/>
<b>Version&#160;</b><br/>
<b>Remarks&#160;</b><br/>
Hoffmann&#160;<br/>
July, 30th 1997&#160;&#160;1.00&#160;<br/>
Initial draft&#160;<br/>
Baudermann, Ebner&#160;<br/>
Aug, 9th 1999&#160;<br/>
2.00&#160;<br/>
Reorganization of the document<br/>Hardware related&#160;<br/>documentation removed&#160;<br/>
Ebner&#160;<br/>
Nov, 2nd 1999&#160;&#160;2.01&#160;<br/>
Spelling corrections&#160;<br/>
Baudermann&#160;<br/>
Nov, 6th 1999&#160;<br/>
2.02&#160;<br/>
Restrictions&#160;with reentrance&#160;<br/>capability for the following CAN&#160;<br/>Driver functions: CanInit,&#160;<br/>CanReset..., CanSleep,&#160;<br/>CanWakeUp and CAN&#160;<br/>interrupts&#160;<br/>
Honert&#160;<br/>
Dec, 14th 1999&#160;&#160;2.03&#160;<br/>
DLC check added&#160;<br/>
Ebner&#160;<br/>
Feb, 8th 2000&#160;<br/>
2.04&#160;<br/>
Configuration by tool support&#160;<br/>(CANgen) added&#160;<br/>
Baudermann, Rein, Honert,&#160;&#160;May, 23th 2000&#160;&#160;2.10&#160;<br/>
Generally reworked&#160;<br/>
Brändle&#160;<br/>
According to&#160;reference&#160;<br/>implementation, version&#160;1.1&#160;<br/>
Honert&#160;<br/>
Oct, 31th 2000&#160;&#160;2.11&#160;<br/>
Description&#160;of indexed CAN&#160;<br/>Driver added&#160;<br/>
Honert&#160;<br/>
Feb, 28th 2001&#160;&#160;2.12&#160;<br/>
Extensions according to&#160;<br/>reference implementation&#160;<br/>version 1.2&#160;<br/>Hardware related&#160;<br/>documentation of HC12 and&#160;<br/>C16x&#160;moved to a separate&#160;<br/>document&#160;<br/>
Honert&#160;<br/>
Aug, 10th 2001&#160;&#160;2.13&#160;<br/>
Description&#160;of&#160;API extended&#160;<br/>&#160;&#160;Single Receive Channel&#160;CAN&#160;<br/>
Driver&#160;<br/>
&#160;&#160;CanCancelTransmit and&#160;<br/>
CanCancelMsgTransmit added&#160;<br/>
&#160;&#160;Access to ErrorCounters added<br/>
Honert, &#160;<br/>
Aug, 20th 2001&#160;&#160;2.14&#160;<br/>
Prototype of&#160;UserPrecopy&#160;<br/>
&#160;<br/>
corrected&#160;<br/>Spelling corrections&#160;<br/>
Emmert&#160;<br/>
Modifications for pdf conversion<br/>
Emmert&#160;<br/>
Okt, 9th 2001&#160;<br/>
2.15&#160;<br/>
Modifications of Figure 4&#160;and 5.&#160;<br/>
Honert&#160;<br/>
Mai, 17th 2002&#160;&#160;2.16&#160;<br/>
Function name corrected for&#160;<br/>indexed driver&#160;<br/>Extensions according to&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
2&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=3></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-3_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
reference implementation&#160;<br/>version 1.3&#160;<br/>
Ebner, Honert, Emmert&#160;<br/>
Jun, 18th, 2003&#160;2.20&#160;<br/>
Macro names&#160;corrected&#160;in&#160;<br/>figure 7.&#160;<br/>Extensions according to&#160;<br/>reference implementation&#160;<br/>version 1.4.&#160;<br/>Additional explanation for offline&#160;<br/>/ partial of<a href="TechnicalReference_CANDrivers.html#35">fline mode (ch.&#160;5.2.6)&#160;</a><br/>
Emmert, Honert&#160;<br/>
Juli, 29th, 2003&#160;&#160;2.21&#160;<br/>
New tables for&#160;API descriptions.<br/>Corrections of&#160;some&#160;<br/>Parameters and&#160;API&#160;<br/>descriptions.&#160;<br/>
Stephan Hoffmann, Klaus&#160;<br/>
May 17nd,&#160;<br/>
2.22 Description&#160;<br/>
of&#160;<br/>
API&#160;<br/>
extended&#160;<br/>
Emmert, Heike Honert,&#160;<br/>
2004&#160;<br/>
&#160;&#160;Direct&#160;Transmit&#160;Objects&#160;<br/>
Patrick Markl&#160;<br/>
Cancel in Hardware&#160;<br/>Language corrections,&#160;New&#160;<br/>Layout, Technical&#160;revisions&#160;<br/>
Klaus Emmert&#160;<br/>
2005-12-30&#160;<br/>
2.23&#160;<br/>
GENy added as Generation&#160;<br/>
Matthias Fleischmann&#160;<br/>
Tool&#160;<br/>Added description for:&#160;<br/>
&#160;&#160;Multiple ECU&#160;<br/>
&#160;&#160;Common CAN&#160;<br/>
&#160;&#160;Signal Access&#160;Macros&#160;<br/>
&#160;&#160;Rx Queue&#160;<br/>
&#160;&#160;Conditional Message Received&#160;<br/>
&#160;&#160;Variable Datalen&#160;<br/>
Heike Honert&#160;<br/>
2006-08-01&#160;<br/>
2.30&#160;<br/>
Extensions according to&#160;<br/>reference implementation 1.5.&#160;<br/>
Heike Honert&#160;<br/>
2007-01-09&#160;<br/>
3.00&#160;<br/>
prepare links to hw specific &#160;<br/>Added description for:&#160;<br/>
&#160;&#160;CAN RAM&#160;check&#160;<br/>
&#160;&#160;Standard/HighEnd CAN Driver&#160;<br/>
Heike Honert&#160;<br/>
2007-01-29&#160;<br/>
3.01&#160;<br/>
some corrections&#160;<br/>
&#160;&#160;improve Common&#160;CAN&#160;<br/>
&#160;&#160;service functions for&#160;conditional&#160;<br/>
message reception added&#160;<br/>
&#160;&#160;Description for&#160;Partial Offline&#160;<br/>
Mode for GENy modified&#160;<br/>
&#160;&#160;ESCAN00032527: Update&#160;<br/>
description of&#160;<br/>ApplCanAddCanInterruptDisabl<br/>e/Restore call-back&#160;function&#160;<br/>
Heike Honert&#160;<br/>
2010-06-11&#160;<br/>
3.01.01&#160;<br/>
Reference to documentation of&#160;<br/>VstdLib changed&#160;<br/>
Table 1-1&#160;&#160;&#160;History&#160;of the&#160;Document&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
3&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=4></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-4_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-4_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>1.2&#160;</b><br/>
<b>Reference Documents&#160;</b><br/>
<b>Index and Document Name&#160;<br/></b>[1] TechnicalReference_&lt;hardware&gt;.pdf&#160;<br/>
Table 1-2&#160;&#160;&#160;Reference Documents&#160;<br/>
&#160;<br/>&#160;<br/>&#160;<br/>&#160;<br/>&#160;<br/>
<b>Please note&#160;<br/></b>We have configured the&#160;programs in accordance&#160;with your specifications in the&#160;<br/>
&#160;&#160;questionnaire. Whereas&#160;the programs do support&#160;other configurations than the one&#160;<br/>
specified&#160;in&#160;your questionnaire, Vector´s release&#160;of the programs delivered to your&#160;<br/>company is&#160;expressly restricted to the&#160;configuration you have&#160;specified in&#160;the&#160;<br/>questionnaire.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
4&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=5></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-5_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>1.3&#160;&#160;Contents&#160;</b><br/>
<a href="TechnicalReference_CANDrivers.html#2"><b>1</b>&#160;&#160;<b>Document Information&#160;...............................................................................................&#160;2</b></a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#2">1.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#2">History&#160;..........................................................................................................&#160;2</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#4">1.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#4">Reference Documents&#160;.................................................................................&#160;4</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#5">1.3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#5">Contents.......................................................................................................&#160;5</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#13"><b>2</b>&#160;&#160;<b>About this Document&#160;...............................................................................................&#160;13</b></a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#14">2.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#14">Documents&#160;this one refers to…..................................................................&#160;14</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#14">2.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#14">Naming Conventions..................................................................................&#160;14</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#15"><b>3</b>&#160;&#160;<b>Reference Implementations.....................................................................................&#160;15</b></a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#15">3.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#15">Version 1.0&#160;.................................................................................................&#160;15</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#15">3.1.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#15">What's new?...............................................................................................&#160;15</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#15">3.1.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#15">What's changed?........................................................................................&#160;15</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#16">3.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#16">Version 1.1&#160;.................................................................................................&#160;16</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#16">3.2.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#16">What's new?...............................................................................................&#160;16</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#16">3.2.1.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#16">Mandatory (for all CAN Drivers)&#160;.................................................................&#160;16</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#16">3.2.1.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#16">Optional (for some specific CAN Drivers)&#160;..................................................&#160;16</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#16">3.2.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#16">What's changed?........................................................................................&#160;16</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#17">3.3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#17">Version 1.2&#160;.................................................................................................&#160;17</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#17">3.3.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#17">What’s&#160;new?...............................................................................................&#160;17</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#17">3.3.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#17">What’s&#160;changed?&#160;.......................................................................................&#160;17</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#17">3.4&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#17">Version 1.3&#160;.................................................................................................&#160;17</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#17">3.4.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#17">What’s&#160;new?...............................................................................................&#160;17</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#17">3.4.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#17">What’s&#160;changed?&#160;.......................................................................................&#160;17</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#18">3.5&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#18">Version 1.4&#160;.................................................................................................&#160;18</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#18">3.5.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#18">What’s&#160;new?...............................................................................................&#160;18</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#18">3.5.1.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#18">Mandatory (for all CAN Drivers)&#160;.................................................................&#160;18</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#18">3.5.1.1.1&#160;&#160;Common features.......................................................................................&#160;18</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#18">3.5.1.1.2&#160;&#160;Transmission features&#160;................................................................................&#160;18</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#18">3.5.1.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#18">Optional (for some specific CAN Drivers)&#160;..................................................&#160;18</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#18">3.5.1.2.1&#160;&#160;Transmission features&#160;................................................................................&#160;18</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#18">3.5.1.2.2&#160;&#160;Reception features&#160;.....................................................................................&#160;18</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#19">3.5.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#19">What’s&#160;changed?&#160;.......................................................................................&#160;19</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#19">3.5.2.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#19">Transmission features&#160;................................................................................&#160;19</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#19">3.6&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#19">Version 1.5&#160;.................................................................................................&#160;19</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#19">3.6.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#19">What’s&#160;new?...............................................................................................&#160;19</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#20">3.6.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#20">What’s&#160;changed?&#160;.......................................................................................&#160;20</a>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
5&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=6></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-6_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#21"><b>4</b>&#160;&#160;<b>Overview&#160;...................................................................................................................&#160;21</b></a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#22">4.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#22">Short Summary of the Functional Scope&#160;...................................................&#160;22</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#22">4.1.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#22">Initialization&#160;................................................................................................&#160;22</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#22">4.1.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#22">Transmission&#160;..............................................................................................&#160;22</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#23">4.1.3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#23">Reception&#160;...................................................................................................&#160;23</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#23">4.1.4&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#23">Bus-Off&#160;.......................................................................................................&#160;23</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#23">4.1.5&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#23">Sleep Mode&#160;................................................................................................&#160;23</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#23">4.1.6&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#23">Special Features&#160;........................................................................................&#160;23</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#24">4.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#24">Data Structures for CAN Driver Customization&#160;..........................................&#160;24</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#25">4.2.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#25">ROM Data&#160;..................................................................................................&#160;25</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#25">4.2.1.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#25">Initialization Structures&#160;...............................................................................&#160;25</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#26">4.2.1.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#26">Transmit Structures&#160;....................................................................................&#160;26</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#26">4.2.1.3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#26">Receive Structures&#160;.....................................................................................&#160;26</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#26">4.2.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#26">RAM Data...................................................................................................&#160;26</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#27"><b>5</b>&#160;&#160;<b>Detailed Description of the Functional Scope (Standard)&#160;....................................&#160;27</b></a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#27">5.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#27">Initialization&#160;................................................................................................&#160;27</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#27">5.1.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#27">Power-On Initialization&#160;of the CAN&#160;Driver&#160;..................................................&#160;27</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#27">5.1.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#27">Re-Initialization of the CAN Controller&#160;.......................................................&#160;27</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#27">5.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#27">Transmission&#160;..............................................................................................&#160;27</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#27">5.2.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#27">Detailed Functional Description&#160;.................................................................&#160;27</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#32">5.2.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#32">Transmit Queue..........................................................................................&#160;32</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#33">5.2.3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#33">Data Copy&#160;Mechanisms&#160;.............................................................................&#160;33</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#33">5.2.3.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#33">Internal&#160;.......................................................................................................&#160;33</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#34">5.2.3.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#34">User defined (“Pretransmit Function”)........................................................&#160;34</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#34">5.2.4&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#34">Notification&#160;.................................................................................................&#160;34</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#34">5.2.4.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#34">Data Interface (Confirmation Flag).............................................................&#160;34</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#34">5.2.4.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#34">Functional Interface (Confirmation Function for each message)&#160;...............&#160;34</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#34">5.2.4.3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#34">Functional Interface (Common&#160;Confirmation Function for all&#160;messages)&#160;..&#160;34</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#35">5.2.5&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#35">Offline Mode...............................................................................................&#160;35</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#35">5.2.6&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#35">Partial Offline Mode....................................................................................&#160;35</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#36">5.2.6.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#36">Partial Offline Mode with GENy..................................................................&#160;36</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#39">5.2.7&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#39">Passive State&#160;.............................................................................................&#160;39</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#40">5.2.8&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#40">Tx Observe.................................................................................................&#160;40</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#41">5.2.9&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#41">Cancellation&#160;of a&#160;Transmission&#160;..................................................................&#160;41</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#41">5.2.9.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#41">Cancel a&#160;Transmission&#160;via CanInit.............................................................&#160;41</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#41">5.2.9.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#41">Cancel a&#160;Transmission&#160;via CanCancelTransmit&#160;or&#160;<br/>CanCancelMsgTransmit.............................................................................&#160;41</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#42">5.2.9.3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#42">Notification&#160;about Cancellation of a&#160;message&#160;............................................&#160;42</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#43">5.2.10&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#43">Overview of&#160;Transmit Objects&#160;....................................................................&#160;43</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#43">5.2.11&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#43">Normal Transmit&#160;Object&#160;.............................................................................&#160;43</a>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
6&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=7></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-7_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#43">5.2.12&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#43">Full CAN&#160;Transmit Objects.........................................................................&#160;43</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#43">5.2.13&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#43">Dynamic Transmit&#160;Objects&#160;.........................................................................&#160;43</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#45">5.2.14&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#45">Priority of&#160;Transmit Objects&#160;........................................................................&#160;45</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#46">5.3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#46">Reception&#160;...................................................................................................&#160;46</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#46">5.3.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#46">Detailed Functional Description&#160;.................................................................&#160;46</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#50">5.3.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#50">Receive Function&#160;.......................................................................................&#160;50</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#50">5.3.3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#50">Range-Specific Precopy&#160;Functions&#160;............................................................&#160;50</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#50">5.3.4&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#50">Identifier Search&#160;Algorithms&#160;.......................................................................&#160;50</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#51">5.3.5&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#51">DLC check..................................................................................................&#160;51</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#51">5.3.6&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#51">Data Copy&#160;Mechanism...............................................................................&#160;51</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#51">5.3.6.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#51">Internal&#160;.......................................................................................................&#160;51</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#52">5.3.6.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#52">User-defined Precopy Functions................................................................&#160;52</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#52">5.3.7&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#52">Notification&#160;.................................................................................................&#160;52</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#53">5.3.7.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#53">Data Interface (Indication Flag)..................................................................&#160;53</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#53">5.3.7.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#53">Functional Interface (Indication Function)&#160;..................................................&#160;53</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#53">5.3.8&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#53">Not-Matched Function................................................................................&#160;53</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#53">5.3.9&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#53">Overrun Handling&#160;.......................................................................................&#160;53</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#53">5.3.10&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#53">Full CAN Overrun Handling........................................................................&#160;53</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#54">5.3.11&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#54">Conditional Message&#160;Received..................................................................&#160;54</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#54">5.4&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#54">Bus-Off Handling........................................................................................&#160;54</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#55">5.5&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#55">Sleep Mode&#160;................................................................................................&#160;55</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#56">5.6&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#56">Special Features&#160;........................................................................................&#160;56</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#56">5.6.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#56">Status&#160;.........................................................................................................&#160;56</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#57">5.6.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#57">Stop Mode&#160;..................................................................................................&#160;57</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#57">5.6.3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#57">Remote Frames&#160;.........................................................................................&#160;57</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#57">5.6.4&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#57">Interrupt Control&#160;.........................................................................................&#160;57</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#57">5.6.4.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#57">Security Level.............................................................................................&#160;57</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#58">5.6.4.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#58">Control of CAN interrupts&#160;...........................................................................&#160;58</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#59">5.6.5&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#59">Assertions&#160;..................................................................................................&#160;59</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#62">5.6.6&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#62">Hardware Loop Check&#160;...............................................................................&#160;62</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#63">5.6.7&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#63">Support of OSEK-Compliant Operating Systems.......................................&#160;63</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#63">5.6.8&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#63">Multiple-Channel CAN Driver&#160;.....................................................................&#160;63</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#63">5.6.8.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#63">Indexed CAN Driver&#160;...................................................................................&#160;63</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#63">5.6.9&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#63">Standard Polling Mode&#160;...............................................................................&#160;63</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#64">5.6.9.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#64">Application Hints&#160;........................................................................................&#160;64</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#64">5.6.10&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#64">Handling of&#160;different identifier types...........................................................&#160;64</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#65">5.6.11&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#65">Copying Mechanisms.................................................................................&#160;65</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#65">5.6.12&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#65">Common CAN&#160;............................................................................................&#160;65</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#65">5.6.13&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#65">Multiple ECU&#160;..............................................................................................&#160;65</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#65">5.6.14&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#65">Signal Access&#160;Macros&#160;................................................................................&#160;65</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#66">5.6.15&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#66">CAN RAM&#160;Check&#160;.......................................................................................&#160;66</a>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
7&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=8></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-8_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#67"><b>6</b>&#160;&#160;<b>Detailed Description of the Functional Scope (High End extension)&#160;..................&#160;67</b></a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#67">6.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#67">Transmission&#160;..............................................................................................&#160;67</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#67">6.1.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#67">Low-Level Message&#160;Transmit&#160;....................................................................&#160;67</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#67">6.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#67">Reception&#160;...................................................................................................&#160;67</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#67">6.2.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#67">Multiple Basic CAN&#160;....................................................................................&#160;67</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#67">6.2.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#67">Rx Queue&#160;...................................................................................................&#160;67</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#68">6.2.2.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#68">Handling in&#160;Receive Interrupt.....................................................................&#160;68</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#69">6.2.2.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#69">Handling on&#160;Task&#160;Level&#160;..............................................................................&#160;69</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#70">6.2.2.3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#70">Resetting the Rx Queue.............................................................................&#160;70</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#71">6.3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#71">Special Features&#160;........................................................................................&#160;71</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#71">6.3.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#71">Individual Polling&#160;........................................................................................&#160;71</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#72"><b>7</b>&#160;&#160;<b>Feature List (Standard and High End)&#160;....................................................................&#160;72</b></a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#75"><b>8</b>&#160;&#160;<b>Description of the&#160;API (Standard)&#160;...........................................................................&#160;75</b></a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#75">8.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#75">API Categories&#160;...........................................................................................&#160;75</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#75">8.1.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#75">Single Receive Channel (SRC)..................................................................&#160;75</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#75">8.1.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#75">Multiple Receive Channel (MRC)...............................................................&#160;75</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#76">8.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#76">Data Types&#160;.................................................................................................&#160;76</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#77">8.3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#77">Constants&#160;...................................................................................................&#160;77</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#77">8.3.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#77">Version Number&#160;.........................................................................................&#160;77</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#77">8.4&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#77">Macros&#160;.......................................................................................................&#160;77</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#77">8.4.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#77">Conversion between Logical and Hardware Representation of CAN&#160;<br/>Parameter DLC&#160;..........................................................................................&#160;77</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#78">8.4.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#78">Direct&#160;Access to the CAN Controller Registers&#160;..........................................&#160;78</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#79">8.4.3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#79">Interpretation of the CAN Status&#160;................................................................&#160;79</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#80">8.4.4&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#80">Access to&#160;low level transmit structure&#160;........................................................&#160;80</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#80">8.5&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#80">Functions....................................................................................................&#160;80</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#81">8.5.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#81">Service Functions.......................................................................................&#160;81</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#81">8.5.1.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#81">CanInitPowerOn.........................................................................................&#160;81</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#81">8.5.1.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#81">CanInit........................................................................................................&#160;81</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#82">8.5.1.3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#82">CanTransmit...............................................................................................&#160;82</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#83">8.5.1.4&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#83">CanTask&#160;.....................................................................................................&#160;83</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#83">8.5.1.5&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#83">CanTxTask&#160;.................................................................................................&#160;83</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#84">8.5.1.6&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#84">CanRxFullCANTask&#160;...................................................................................&#160;84</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#84">8.5.1.7&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#84">CanRxBasicCANTask&#160;................................................................................&#160;84</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#85">8.5.1.8&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#85">CanErrorTask&#160;.............................................................................................&#160;85</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#85">8.5.1.9&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#85">CanWakeUpTask........................................................................................&#160;85</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#86">8.5.1.10&#160;&#160;CanOnline&#160;..................................................................................................&#160;86</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#86">8.5.1.11&#160;&#160;CanOffline&#160;..................................................................................................&#160;86</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#87">8.5.1.12&#160;&#160;CanPartOnline............................................................................................&#160;87</a>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
8&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=9></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-9_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#87">8.5.1.13&#160;&#160;CanPartOffline............................................................................................&#160;87</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#88">8.5.1.14&#160;&#160;CanGetPartMode&#160;.......................................................................................&#160;88</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#88">8.5.1.15&#160;&#160;CanGetStatus.............................................................................................&#160;88</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#89">8.5.1.16&#160;&#160;CanSleep&#160;...................................................................................................&#160;89</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#90">8.5.1.17&#160;&#160;CanWakeUp&#160;...............................................................................................&#160;90</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#91">8.5.1.18&#160;&#160;CanStart&#160;.....................................................................................................&#160;91</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#92">8.5.1.19&#160;&#160;CanStop&#160;.....................................................................................................&#160;92</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#92">8.5.1.20&#160;&#160;CanGlobalInterruptDisable.........................................................................&#160;92</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#93">8.5.1.21&#160;&#160;CanGlobalInterruptRestore&#160;........................................................................&#160;93</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#93">8.5.1.22&#160;&#160;CanCanInterruptDisable.............................................................................&#160;93</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#94">8.5.1.23&#160;&#160;CanCanInterruptRestore&#160;............................................................................&#160;94</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#94">8.5.1.24&#160;&#160;CanSetPassive...........................................................................................&#160;94</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#95">8.5.1.25&#160;&#160;CanSetActive&#160;.............................................................................................&#160;95</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#95">8.5.1.26&#160;&#160;CanResetBusOffStart&#160;.................................................................................&#160;95</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#96">8.5.1.27&#160;&#160;CanResetBusOffEnd..................................................................................&#160;96</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#96">8.5.1.28&#160;&#160;CanResetBusSleep....................................................................................&#160;96</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#97">8.5.1.29&#160;&#160;CanGetDynTxObj.......................................................................................&#160;97</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#99">8.5.1.30&#160;&#160;CanReleaseDynTxObj&#160;...............................................................................&#160;99</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#99">8.5.1.31&#160;&#160;CanDynTxObjSetId&#160;....................................................................................&#160;99</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#100">8.5.1.32&#160;&#160;CanDynTxObjSetExtId&#160;.............................................................................&#160;100</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#100">8.5.1.33&#160;&#160;CanDynTxObjSetDlc&#160;................................................................................&#160;100</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#101">8.5.1.34&#160;&#160;CanDynTxObjSetDataPtr&#160;.........................................................................&#160;101</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#101">8.5.1.35&#160;&#160;CanCancelTransmit..................................................................................&#160;101</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#101">8.5.1.36&#160;&#160;CanCopyFromCan&#160;...................................................................................&#160;101</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#102">8.5.1.37&#160;&#160;CanCopyToCan........................................................................................&#160;102</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#102">8.5.1.38&#160;&#160;CanTxGetActHandle&#160;................................................................................&#160;102</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#103">8.5.1.39&#160;&#160;CanResetMsgReceivedCondition&#160;............................................................&#160;103</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#103">8.5.1.40&#160;&#160;CanSetMsgReceivedCondition&#160;................................................................&#160;103</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#104">8.5.1.41&#160;&#160;CanGetMsgReceivedCondition................................................................&#160;104</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#105">8.5.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#105">User Specific Functions............................................................................&#160;105</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#105">8.5.2.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#105">UserPrecopy&#160;............................................................................................&#160;105</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#105">8.5.2.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#105">UserIndication&#160;..........................................................................................&#160;105</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#106">8.5.2.3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#106">UserPreTransmit&#160;......................................................................................&#160;106</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#106">8.5.2.4&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#106">UserConfirmation&#160;.....................................................................................&#160;106</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#107">8.5.3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#107">Callback Functions...................................................................................&#160;107</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#107">8.5.3.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#107">ApplCanBusOff&#160;........................................................................................&#160;107</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#107">8.5.3.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#107">ApplCanWakeUp......................................................................................&#160;107</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#108">8.5.3.3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#108">ApplCanOverrun&#160;......................................................................................&#160;108</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#108">8.5.3.4&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#108">ApplCanFullCanOverrun&#160;..........................................................................&#160;108</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#109">8.5.3.5&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#109">ApplCanMsgReceived..............................................................................&#160;109</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#109">8.5.3.6&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#109">ApplCanRangePrecopy............................................................................&#160;109</a>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
9&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=10></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-10_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#110">8.5.3.7&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#110">ApplCanAddCanInterruptDisable&#160;..............................................................110</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#110">8.5.3.8&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#110">ApplCanAddCanInterruptRestore&#160;.............................................................110</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#111">8.5.3.9&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#111">ApplCanFatalError&#160;....................................................................................111</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#111">8.5.3.10&#160;&#160;ApplCanMsgNotMatched&#160;..........................................................................111</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#112">8.5.3.11&#160;&#160;ApplCanInit................................................................................................112</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#113">8.5.3.12&#160;&#160;ApplCanTxObjStart&#160;...................................................................................113</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#113">8.5.3.13&#160;&#160;ApplCanTxObjConfirmed&#160;..........................................................................113</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#114">8.5.3.14&#160;&#160;ApplCanTimerStart&#160;....................................................................................114</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#114">8.5.3.15&#160;&#160;ApplCanTimerLoop&#160;...................................................................................114</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#115">8.5.3.16&#160;&#160;ApplCanTimerEnd&#160;.....................................................................................115</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#115">8.5.3.17&#160;&#160;ApplCanGenericPrecopy...........................................................................115</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#115">8.5.3.18&#160;&#160;ApplCanPreWakeup..................................................................................115</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#116">8.5.3.19&#160;&#160;ApplCanTxConfirmation&#160;............................................................................116</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#117">8.5.3.20&#160;&#160;ApplCanMsgDlcFailed...............................................................................117</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#117">8.5.3.21&#160;&#160;ApplCanCancelNotification&#160;.......................................................................117</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#118">8.5.3.22&#160;&#160;ApplCanOnline&#160;..........................................................................................118</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#118">8.5.3.23&#160;&#160;ApplCanOffline&#160;..........................................................................................118</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#118">8.5.3.24&#160;&#160;ApplCanMsgCondReceived&#160;......................................................................118</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#119">8.5.3.25&#160;&#160;ApplCanMemCheckFailed&#160;........................................................................119</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#119">8.5.3.26&#160;&#160;ApplCanCorruptMailbox&#160;............................................................................119</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#121"><b>9</b>&#160;&#160;<b>Description of the&#160;API (High End extension)&#160;.......................................................&#160;121</b></a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#121">9.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#121">Functions..................................................................................................&#160;121</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#121">9.1.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#121">Service Functions.....................................................................................&#160;121</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#121">9.1.1.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#121">CanTxObjTask..........................................................................................&#160;121</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#122">9.1.1.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#122">CanRxFullCANObjTask............................................................................&#160;122</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#122">9.1.1.3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#122">CanRxBasicCANObjTask.........................................................................&#160;122</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#123">9.1.1.4&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#123">CanMsgTransmit&#160;......................................................................................&#160;123</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#123">9.1.1.5&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#123">CanCancelMsgTransmit...........................................................................&#160;123</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#124">9.1.1.6&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#124">CanHandleRxMsg&#160;....................................................................................&#160;124</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#124">9.1.1.7&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#124">CanDeleteRxQueue&#160;.................................................................................&#160;124</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#125">9.1.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#125">Callback Functions...................................................................................&#160;125</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#125">9.1.2.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#125">ApplCanMsgTransmitConf&#160;.......................................................................&#160;125</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#125">9.1.2.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#125">ApplCanMsgTransmitInit&#160;..........................................................................&#160;125</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#125">9.1.2.3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#125">ApplCanMsgCancelNotification................................................................&#160;125</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#126">9.1.2.4&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#126">ApplCanPreRxQueue...............................................................................&#160;126</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#126">9.1.2.5&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#126">ApplCanRxQueueOverrun&#160;.......................................................................&#160;126</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#128"><b>10</b>&#160;&#160;<b>Configuration (Standard and High End)...............................................................&#160;128</b></a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#128">10.1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#128">Network Database –&#160;Attribute Definition&#160;..................................................&#160;128</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#128">10.2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#128">Automatic Configuration&#160;by GENy&#160;...........................................................&#160;128</a>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
10&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=11></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-11_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#139">10.3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#139">Automatic Configuration&#160;by CANgen&#160;.......................................................&#160;139</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#144">10.4&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#144">Manual configuration via user configuration file&#160;.......................................&#160;144</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#145"><b>11</b>&#160;&#160;<b>Glossary&#160;..................................................................................................................&#160;145</b></a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#149"><b>12</b>&#160;&#160;<b>Contact&#160;....................................................................................................................&#160;149</b></a>&#160;<br/>
&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
11&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=12></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-12_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Illustrations&#160;</b><br/>
<a href="TechnicalReference_CANDrivers.html#14">Figure 2-1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#14">Manuals and References for the CAN Driver&#160;.................................................&#160;14</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#21">Figure 4-1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#21">Relationship&#160;of the individual Software Components. &#160;They are&#160;<br/>customized&#160;by the Generation&#160;Tool.................................................................&#160;21</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#25">Figure 4-2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#25">Description&#160;data, CAN&#160;Driver and&#160;Application with their interfaces.&#160;...............&#160;25</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#28">Figure 5-1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#28">Transmission of a CAN&#160;message&#160;...................................................................&#160;28</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#30">Figure 5-2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#30">Transmission with an available transmit object; Using global&#160;data buffer.......&#160;30</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#31">Figure 5-3&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#31">Transmission with an available hardware transmit object; Using a&#160;<br/>pretransmit function to copy data....................................................................&#160;31</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#32">Figure 5-4&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#32">Transmit procedure if no&#160;hardware transmit object available&#160;.........................&#160;32</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#37">Figure 5-5&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#37">Partial Offline Mode settings in GENy.............................................................&#160;37</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#38">Figure 5-6&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#38">One Single&#160;Application&#160;Message Selected&#160;.....................................................&#160;38</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#38">Figure 5-7&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#38">User Defined assignment to Offline&#160;Modes&#160;....................................................&#160;38</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#39">Figure 5-8&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#39">Overview&#160;Messages and Offline Modes&#160;.........................................................&#160;39</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#45">Figure 5-9&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#45">Priority of&#160;Transmit Objects.............................................................................&#160;45</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#46">Figure 5-10&#160;&#160;Reception of a CAN messages.......................................................................&#160;46</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#48">Figure 5-11&#160;&#160;Reception of a CAN message:&#160;The&#160;data is completely processed in the&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#48">precopy function&#160;.............................................................................................&#160;48</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#49">Figure 5-12&#160;&#160;Reception of a CAN message:&#160;The&#160;CAN Driver internal copying&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#49">mechanism is used&#160;.........................................................................................&#160;49</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#66">Figure 5-13&#160;&#160;Name of signal access&#160;macros.......................................................................&#160;66</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#69">Figure 6-1&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#69">Handling of&#160;the Rx queue within the&#160;receive routine.&#160;.....................................&#160;69</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#70">Figure 6-2&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#70">Handling of&#160;the Rx queue on task level.&#160;.........................................................&#160;70</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#129">Figure 10-1&#160;&#160;Configuration of the common CAN Driver options with GENy......................&#160;129</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#135">Figure 10-2&#160;&#160;Channel Specific Configuration for GENy.....................................................&#160;135</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#136">Figure 10-3&#160;&#160;Configuration of individual polling with GENy&#160;...............................................&#160;136</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#137">Figure 10-4&#160;&#160;Configuration of a&#160;Tx message with&#160;GENy&#160;...................................................&#160;137</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#138">Figure 10-5&#160;&#160;Configuration of an Rx&#160;message with GENy&#160;................................................&#160;138</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#139">Figure 10-6&#160;&#160;CAN Driver&#160;configuration tab&#160;........................................................................&#160;139</a>&#160;<br/><a href="TechnicalReference_CANDrivers.html#143">Figure 10-7&#160;&#160;Configuration of Partial&#160;Offline Mode&#160;............................................................&#160;143</a>&#160;<br/>&#160;<br/>
<b>Tables&#160;<br/></b><a href="TechnicalReference_CANDrivers.html#3">Table 1-1&#160;&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#3">History of the Document&#160;...................................................................................&#160;3</a>&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#4">Table 1-2&#160;&#160;</a><br/>
<a href="TechnicalReference_CANDrivers.html#4">Reference Documents&#160;......................................................................................&#160;4</a>&#160;<br/>
&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
12&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=13></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-13_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>2&#160;&#160;About this Document&#160;</b><br/>
This document describes the concept, features,&#160;API and the configuration of the Vector&#160;<br/>CAN Driver.&#160;<br/>The CAN Driver interface to&#160;the CAN Controller is designed to&#160;use the hardware specific&#160;<br/>capabilities&#160;in an efficient way.&#160;The interface&#160;to the higher communication&#160;layers is mostly&#160;<br/>identical for different CAN Controllers, so that the Interaction Layer, Network Management,&#160;<br/>Transport Protocol and especially the user software are independent of the particular CAN&#160;<br/>Controller used. Please note that&#160;in this document the term&#160;Application is&#160;not used strictly&#160;<br/>for the user software but also for all the&#160;higher communication layers as listed above.&#160;<br/>Therefore,&#160;Application refers to any of&#160;the software modules using the CAN Driver.&#160;<br/>Two different types of CAN Driver are supported.&#160;These are the Standard CAN Driver and&#160;<br/>the High End CAN Driver.&#160;The&#160;High End CAN Driver&#160;is an extended Standard CAN Driver.&#160;<br/>The description of the Standard&#160;CAN Driver&#160;is also&#160;valid for the High End&#160;CAN Driver.&#160;The&#160;<br/>additional features of the High End CAN&#160;Driver are described&#160;in own chapters.&#160;<br/>The&#160;API of the functions is described in a separate chapter at the end&#160;of this document.&#160;<br/>Referred functions are always shown in&#160;the Single receive channel mode. &#160;<br/>Hardware related special features and implementation specifics are described in a&#160;<br/>separate document which is named&#160;TechnicalReference_CAN_&lt;hardware&gt;.pdf.&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
13&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=14></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-14_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-14_2.jpg"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-14_3.jpg"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-14_4.jpg"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>2.1&#160;&#160;Documents this one refers to…&#160;</b><br/>
&#160;&#160;User Manual CAN Driver&#160;<br/>
&#160;&#160;Hardware-specific documentation for the CAN Driver&#160;<br/>
&#160;<br/>
<b>User&#160;Manual</b><br/>
<b>Technical</b><br/>
<b>Technical</b><br/>
<b>Reference</b><br/>
<b>Reference</b><br/>
<b>General</b><br/>
<b>Hardware</b><br/>
<b>You are&#160;here</b><br/>
#hw_&lt;xxx&gt;<br/>
&#160;<br/>
Figure 2-1&#160;&#160;Manuals and References for the&#160;CAN Driver&#160;<br/>
&#160;<br/>
<b>2.2&#160;&#160;Naming Conventions&#160;<br/></b>Some of the function names are mandatory,&#160;because they are used in the CAN Driver.&#160;<br/>Other names are placeholders, and the&#160;Application can redefine or has to select them&#160;<br/>according to its requirements:&#160;<br/>
Can...&#160;<br/>
It is mandatory to use all names beginning with&#160;Can... as they appear. Can...&#160;<br/>stands for CAN Driver.&#160;<br/>
ApplCan...&#160;<br/>
The functions, starting with&#160;Appl... are so called callback functions.&#160;They are&#160;<br/>provided by&#160;the&#160;Application and called by&#160;the CAN Driver.&#160;They are used to&#160;<br/>notify the application about events such as state&#160;transitions.&#160;<br/>
User...&#160;<br/>
All names starting with User... are placeholders and will be selected by using&#160;<br/>the Generation&#160;Tool according to the&#160;requirements of the&#160;Application. User...&#160;<br/>stands for user-specific&#160;functions.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
14&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=15></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-15_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>3&#160;&#160;Reference Implementations&#160;</b><br/>
The reference implementation is a general specification for all Vector CAN Drivers.&#160;The&#160;<br/>software versions for specific CAN Drivers&#160;differs, because there&#160;are different source&#160;<br/>codes for different CAN Controllers.&#160;Therefore another overall version number exists,&#160;<br/>representing the reference implementation.&#160;The CAN Drivers are implemented according&#160;<br/>to this reference implementation with an identical feature set and&#160;Application interface as&#160;<br/>well as a harmonized implementation. &#160;<br/>&#160;<br/>
<b>3.1&#160;&#160;Version 1.0&#160;</b><br/>
<b>3.1.1&#160;&#160;What's new?&#160;</b><br/>
&#160;&#160;Identifier ranges defined by acceptance code&#160;and mask to receive a complete set of&#160;<br/>
several CAN identifiers.&#160;This is&#160;much more&#160;efficient for special requirements with fixed&#160;<br/>identifier ranges and can be&#160;configured by the&#160;Application. Useful settings for&#160;<br/>Application are selected automatically by the Generation&#160;Tool.&#160;<br/>
&#160;&#160;Some parameters are provided by preprocessor defines in the CAN&#160;Driver configuration&#160;<br/>
file instead of global variables.&#160;This&#160;results in more efficient code.&#160;<br/>
&#160;&#160;Notification of a CAN receive message overrun condition is done by the callback&#160;<br/>
function ApplCanOverrun().&#160;This is configurable.&#160;<br/>
&#160;&#160;The internal copy mechanism&#160;of&#160;the CAN Driver is&#160;configurable separately&#160;for receive&#160;<br/>
and transmit direction. It will be&#160;enabled automatically if an&#160;Application data&#160;buffer is&#160;<br/>selected by&#160;the Generation&#160;Tool.&#160;<br/>
<b>3.1.2&#160;&#160;What's changed?&#160;</b><br/>
&#160;&#160;General interrupt disable during critical service functions is&#160;replaced by a reentrant&#160;<br/>
solution.&#160;<br/>
&#160;&#160;General assertion categories for the following severe errors in the CAN Driver:&#160;<br/>
&#160;&#160;- User interface (e.g. invalid handles)&#160;<br/>
&#160;&#160;- Generated data (caused by&#160;the Generation&#160;Tool)&#160;<br/>
&#160;&#160;- Hardware problems (unexpected&#160;conditions of the CAN Controller)&#160;<br/>
&#160;&#160;- Internal errors&#160;(e.g. inconsistent transmit queue entries)&#160;<br/>
&#160;&#160;The different categories can be configured&#160;separately and the name of the callback&#160;<br/>
function has changed from&#160;ApplFatalError(..) to&#160;ApplCanFatalError(..).&#160;<br/>
&#160;&#160;Callback function CanMsgReceive() has changed in&#160;ApplCanMsgReceived().&#160;<br/>
&#160;&#160;Plausibility&#160;check for configuration switches&#160;of the CAN Driver&#160;is optional and will be&#160;<br/>
done in a separate header file called CAN_CHK.H.&#160;<br/>
&#160;&#160;CanRxActualDLC will be provided&#160;as a preprocessor macro.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
15&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=16></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-16_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;&#160;If the transmit queue is used for CAN Controllers&#160;with several hardware transmit&#160;<br/>
objects, only one of&#160;these register sets&#160;will be used for normal transmission (in&#160;<br/>combination with the transmit queue).&#160;The others are reserved for Full CAN&#160;Transmit&#160;<br/>Objects with fixed CAN identifier and DLC.&#160;<br/>
&#160;&#160;The names of the following global variables have been changed:&#160;<br/>
&#160;&#160;CanEcuNumber to canEcuNumber&#160;<br/>
&#160;&#160;CanRxHandle &#160; &#160;to canRxHandle&#160;<br/>
&#160;<br/>
<b>3.2&#160;&#160;Version 1.1&#160;</b><br/>
<b>3.2.1&#160;&#160;What's new?&#160;</b><br/>
<b>3.2.1.1&#160;</b><br/>
<b>Mandatory&#160;(for all CAN Drivers)&#160;</b><br/>
&#160;&#160;Configurable callback function if software acceptance filtering doesn't match.&#160;<br/>
&#160;&#160;Configurable callback functions to&#160;monitor the correct transmit behavior.&#160;<br/>
&#160;&#160;Dynamic transmit objects for variable CAN identifier and DLC&#160;<br/>
&#160;&#160;Security level for the data consistency during&#160;the internal copy routines for receive and&#160;<br/>
transmit data.&#160;<br/>
&#160;&#160;Configurable callback&#160;functions to control&#160;hardware dependent loop break&#160;conditions&#160;<br/>
(e.g. during the transition to reset, standby or sleep mode).&#160;<br/>
&#160;&#160;For micros with nested interrupt levels&#160;the global disabling of interrupts by&#160;<br/>
CanGlobalInterruptDisable/Restore() is replaced by a configurable interrupt lock level.&#160;<br/>
<b>3.2.1.2&#160;</b><br/>
<b>Optional (for some specific CAN Drivers)&#160;</b><br/>
&#160;&#160;Support of extended CAN identifiers in different modes (extended only or&#160;mixed with&#160;<br/>
standard identifiers)&#160;<br/>
&#160;&#160;Non-interrupt (polling) mode&#160;for asynchronous transmission, reception, error and wake-<br/>
up notification.&#160;<br/>
&#160;&#160;Dynamic transmit objects (for flexible transmit&#160;buffer,&#160;pretransmit as well as confirmation&#160;<br/>
function).&#160;<br/>
&#160;&#160;Full CAN&#160;Transmit Objects with fixed CAN identifier and&#160;DLC.&#160;<br/>
&#160;&#160;Dynamic hardware acceptance filtering for the reception of different messages.&#160;<br/>
<b>3.2.2&#160;&#160;What's changed?&#160;</b><br/>
&#160;&#160;Service functions for flexible CAN identifier and DLC CanTransmitVarDLC/ID(..) must&#160;<br/>
not be used for new developments. It will be replaced by dynamic transmit objects.&#160;<br/>
&#160;&#160;Special macros for the direct access to CAN&#160;message information (identifier,&#160;DLC, ...) in&#160;<br/>
the receive function (Dir...) will be removed.&#160;The standard macros can be used&#160;instead.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
16&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=17></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-17_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;&#160;Configurable DLC check for&#160;the length of the according&#160;receive buffer to avoid the&#160;<br/>
overwriting of the next receive buffer:&#160;The complete data will not be copied and the&#160;<br/>Application&#160;will not be notified if&#160;an inconsistency is detected.&#160;<br/>
&#160;&#160;The return code data type of the CanGetStatus() service function has changed because&#160;<br/>
of additional information in the software state of the CAN Driver and the hardware state&#160;<br/>of the CAN Controller.&#160;<br/>
<b>3.3&#160;&#160;Version 1.2&#160;</b><br/>
<b>3.3.1&#160;&#160;What’s new?&#160;</b><br/>
&#160;&#160;Hash search algorithm &#160;<br/>
&#160;&#160;Low level transmit functionality to support e.g. gateways&#160;<br/>
&#160;&#160;Service functions to stop and restart the CAN Controller.&#160;<br/>
&#160;&#160;partial offline to switch&#160;dedicated transmit messages off.&#160;<br/>
&#160;&#160;New return code of CanTransmit()&#160;in case of partial offline.&#160;<br/>
&#160;&#160;Macros which return 8 bit of a received&#160;extended ID for use in precopy functions.&#160;<br/>
&#160;&#160;Access to error counter of the CAN controller&#160;<br/>
&#160;&#160;Service function to cancel transmit requests and confirmations&#160;<br/>
<b>3.3.2&#160;&#160;What’s changed?&#160;</b><br/>
&#160;&#160;Generic Precopy function is now mandatory&#160;<br/>
&#160;&#160;CanSleep()&#160;and CanWakeUp() has now a return value.&#160;<br/>
&#160;&#160;CanGetStatus() is always available.&#160;Activation&#160;of extended status enables the additional&#160;<br/>
information in the hardware state of the CAN Controller.&#160;<br/>
&#160;&#160;Passive mode can only be activated for all transmit requests and not for dedicated&#160;<br/>
messages.&#160;<br/>
&#160;&#160;The name of some macros to access the ID&#160;in a precopy function has changed&#160;<br/>
&#160;&#160;In the indexed CAN Driver, CanGetDynTxObj()&#160;has the channel as additional parameter.&#160;<br/>
&#160;&#160;Macro CanRxActualIdHi renamed&#160;to CanRxActualIdRawHi&#160;<br/>
&#160;&#160;Macro CanRxActualIdLo renamed to CanRxActualIdRawLo&#160;<br/>
<b>3.4&#160;&#160;Version 1.3&#160;</b><br/>
<b>3.4.1&#160;&#160;What’s new?&#160;</b><br/>
&#160;&#160;New service functions to disable and restore CAN interrupts&#160;<br/>
<b>3.4.2&#160;&#160;What’s changed?&#160;</b><br/>
&#160;&#160;Function CanInterruptDisable renamed to CanGlobalInterruptDisable&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
17&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=18></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-18_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;&#160;Function CanInterruptRestore renamed to CanGlobalInterruptRestore&#160;<br/>
&#160;&#160;Support of systems with mixed Identifier expanded&#160;<br/>
&#160;&#160;Macro CanRxActualId returns the Identifier always in the logical presentation&#160;<br/>
<b>3.5&#160;&#160;Version 1.4&#160;</b><br/>
<b>3.5.1&#160;&#160;What’s new?&#160;</b><br/>
<b>3.5.1.1&#160;</b><br/>
<b>Mandatory&#160;(for all CAN Drivers)&#160;</b><br/>
<b>3.5.1.1.1&#160;Common features&#160;</b><br/>
&#160;&#160;New functions CanCopyFromCan and CanCopyToCan. Hardware/Compiler&#160;dependent&#160;<br/>
functions to optimize copying of data (provide for higher layers such as&#160;TP, Diag).&#160;&#160;&#160;&#160;<br/><a href="TechnicalReference_CANDrivers.html#65">more…</a><a href="TechnicalReference_CANDrivers.html#101">&#160; &#160;API…</a>&#160;<br/>
&#160;&#160;The CAN driver can be configured to run without any disabling of interrupts.&#160;<br/>
The application has&#160;to take care of reentrancy!&#160;To&#160;set the&#160;Can Driver to this&#160;mode, the&#160;<br/>security level has to be set to&#160;the lowest value. &#160; &#160;<a href="TechnicalReference_CANDrivers.html#58">more…&#160;</a><br/>
&#160;&#160;The CAN Driver is&#160;more fault tolerant&#160;against unexpected CAN interrupts like Rx&#160;<br/>
interrupt of a transmit object. Interrupt in polling mode or interrupts of unused objects&#160;<br/>are handled by the driver.&#160;<br/>
&#160;&#160;Callback function&#160;ApplCanPreWakeUp which is&#160;called immediately&#160;after the activation of&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#23">the wakeup interrupt. &#160;more...&#160; &#160; &#160;</a><a href="TechnicalReference_CANDrivers.html#115">API…</a>&#160;<br/>
&#160;&#160;The CAN Driver doesn’t use library function&#160;of the compiler library (except for intrinsic&#160;<br/>
functions)&#160;<br/>
&#160;&#160;The Can Driver code is MISRA&#160;compliant.&#160;<br/>
<b>3.5.1.1.2&#160;Transmission features&#160;<br/></b>A&#160;confirmation function common to all transmit messages is supported.&#160;This function is&#160;<br/>called after any successful transmission (except Direct&#160;Transmit Objects but includes&#160;<br/>canceled transmit object<a href="TechnicalReference_CANDrivers.html#34">s that had been sent although). &#160; &#160;more…</a><a href="TechnicalReference_CANDrivers.html#116">&#160; &#160;API…</a>&#160;<br/><b>3.5.1.2&#160;</b><br/>
<b>Optional (for some specific CAN Drivers)&#160;</b><br/>
<b>3.5.1.2.1&#160;Transmission features&#160;</b><br/>
&#160;&#160;CanDirectTransmit( txHandle ) to&#160;support direct transmit objects.&#160;<br/>
This transmission is&#160;completely independent&#160;of other transmit messages and can&#160;&#160;<br/>be sent e.g. out of a NMI (non-maskable interrupt service routine. (see also what’s&#160;<br/>changed).&#160;<br/>
<b>3.5.1.2.2&#160;Reception features&#160;</b><br/>
&#160;&#160;For Full CAN controllers polling of Basic CAN&#160;is supported (all functionality&#160;of the CAN&#160;<br/>
driver can be used in polling mode). &#160; &#160;<a href="TechnicalReference_CANDrivers.html#63">more…&#160;</a><br/>
&#160;&#160;A&#160;callback&#160;function is called,&#160;if&#160;the DLC check fails&#160;(this means if the DLC of the&#160;<br/>
received message is shorter than configured for this message). &#160; &#160;<a href="TechnicalReference_CANDrivers.html#51">more…&#160; &#160; &#160;</a><a href="TechnicalReference_CANDrivers.html#117">API…&#160;</a><br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
18&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=19></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-19_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;&#160;Support variable data length&#160;(for specific OEMs).&#160;<br/>
&#160;<br/>
<b>3.5.2&#160;&#160;What’s changed?&#160;</b><br/>
&#160;&#160;The names of the different kinds of transmission objects changed.&#160;To&#160;make the&#160;<br/>
differences&#160;clear in the following table all kinds of transmission objects&#160;are listed even if&#160;<br/>nothing changed. &#160; &#160;<a href="TechnicalReference_CANDrivers.html#43">more…&#160;</a><br/>
<b>Old names (before RI 1.4)&#160;</b><br/>
<b>New&#160;names&#160;(RI 1.4 and later)&#160;</b><br/>
Transmit Objects&#160;<br/>
Normal&#160;Transmit Object&#160;<br/>
Direct&#160;Transmit Objects&#160;<br/>
Full CAN&#160;Transmit Object&#160;<br/>
Dynamic Transmit&#160;Objects&#160;<br/>
Dynamic Transmit&#160;Objects&#160;<br/>
--- Direct&#160;<br/>
Transmit&#160;<br/>
Objects&#160;<br/>
Low Level Message&#160;Transmit&#160;<br/>
Low Level Message&#160;Transmit&#160;<br/>
&#160;<br/><b>3.5.2.1&#160;</b><br/>
<b>Transmission features&#160;</b><br/>
&#160;&#160;The interface of the&#160;TxObserve Callback&#160;functions has changed (parameter of the&#160;<br/>
functions&#160;&#160;<a href="TechnicalReference_CANDrivers.html#112">ApplCanTxObjStart() and&#160;</a><a href="TechnicalReference_CANDrivers.html#113">ApplCanTxObjConfirmed() and&#160;</a><a href="TechnicalReference_CANDrivers.html#112">ApplCanInit(). An</a>&#160;<br/>additional parameter&#160;is used.&#160;This additional parameter is the handle of the hardware&#160;<br/>object (a unique number over all hardware transmit objects which starts with 0). &#160;&#160;&#160; &#160;&#160;<br/><a href="TechnicalReference_CANDrivers.html#40">more…</a><a href="TechnicalReference_CANDrivers.html#112">&#160; &#160;API…</a>&#160;<br/>
&#160;&#160;The functions CanCancelTransmit() and CanCancelMsgTransmit can now delete a&#160;<br/>
message in the hardware transmit buffe<a href="TechnicalReference_CANDrivers.html#41">r as well as in the queue. &#160; &#160;more…</a><a href="TechnicalReference_CANDrivers.html#101">&#160;API…</a>&#160;<br/>
&#160;&#160;To&#160;get the tx handle of&#160;a pending transmit message, a new Service function is defined:&#160;<br/>
CanTxGetActHandle(CanObjectHand<a href="TechnicalReference_CANDrivers.html#41">le logTxHwObject) &#160; &#160;more…</a><a href="TechnicalReference_CANDrivers.html#102">&#160; &#160;API…</a>&#160;<br/>
&#160;&#160;If a CAN controller doesn’t support arbitration by ID, Direct&#160;Transmit Objects and Full&#160;<br/>
CAN&#160;Transmit Objects have a higher priority&#160;than the Normal&#160;Transmit Object.&#160;The Low&#160;<br/>Level Message transmission has the lowest priority<a href="TechnicalReference_CANDrivers.html#45">. &#160; &#160;more…</a>&#160;<br/>
&#160;&#160;It is not possible/necessary any longer to specify the number of the&#160;CAN transmit buffer&#160;<br/>
for Full CAN&#160;Transmit Objects.&#160;This will be&#160;done by the Generation&#160;Tool automatically.&#160;<br/>
&#160;&#160;The functions CanPartOffline and CanPartOnline are designed to&#160;<a href="TechnicalReference_CANDrivers.html#87">be reentrant. &#160; &#160;API…</a>&#160;<br/>
<b>3.6&#160;&#160;Version 1.5&#160;</b><br/>
<b>3.6.1&#160;&#160;What’s new?&#160;</b><br/>
&#160;&#160;data size optimized&#160;Tx Queue.&#160;<br/>
&#160;&#160;In systems with mixed IDs (standard and extended), each range can be configured to&#160;<br/>
standard or extended ID&#160;individually.&#160;<br/>
&#160;&#160;Each hardware objects&#160;can be configured individually to polling or interrupt mode.&#160;&#160;&#160;&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#64">more...</a><a href="TechnicalReference_CANDrivers.html#86">&#160; &#160;API...&#160;</a><br/>
&#160;&#160;Multiple Basic CAN objects can be defined&#160;to optimize the hardwar<a href="TechnicalReference_CANDrivers.html#54">e filters. &#160; &#160;more...</a>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
19&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=20></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-20_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;&#160;Rx Queue supports now queuing of&#160;messages out of a range.&#160;<br/>
&#160;&#160;Notification about mode change of the CAN driver between offline and online mode.&#160;<br/>
&#160;&#160;New macros to fill structure&#160;of Low Level Message&#160;Transmit&#160;<br/>
&#160;&#160;distinguish between Standard CAN Driver and&#160;High End CAN Driver&#160;instead of optional&#160;<br/>
features&#160;<br/>
<b>3.6.2&#160;&#160;What’s changed?&#160;</b><br/>
&#160;&#160;Source&#160;Address of Range Specific Precopy&#160;Messages&#160;removed – deviation to&#160;HIS CAN&#160;<br/>
Driver Sp<a href="TechnicalReference_CANDrivers.html#76">ecification. (EcuNumber isn’t any longer a member of&#160;tCanRxInfoStruct</a>)&#160;<br/>
&#160;&#160;Return code of Range Precopy Functions has effect on further&#160;reception handling.&#160;<br/>
&#160;&#160;Direct&#160;Transmit Objects are not supported any more&#160;<br/>
&#160;&#160;API Categories Single Receive Buffer (SRD)&#160;and Multiple Receive Buffer (MRB) are not&#160;<br/>
supported any more.&#160;<br/>
&#160;&#160;Global Interrupt Control has been moved&#160;to VStdLib (CanGlobalInterruptDisable(),.&#160;<br/>
CanGlobalInterruptRestore(),&#160;&#160;Interrupt Control by&#160;Application, Interrupt Lock Level).&#160;<br/>...more information see&#160;Application Note&#160;AN-ISC-2-1050_VstdLibIntegration.pdf.&#160;<br/>
&#160;&#160;Channel parameter for Hardware&#160;Loop Check Callbacks – deviation&#160;to HIS CAN Driver&#160;<br/>
Specification &#160; &#160;<a href="TechnicalReference_CANDrivers.html#114">API...&#160;</a><br/>
&#160;&#160;The following macros are not available any more:&#160;MK_EXTID_LO, MK_EXTID_HI,&#160;<br/>
MK_STDID_LO, MK_STDID_HI, CanRxActualIdRaw, CanRxActualIdRawHi,&#160;<br/>
CanRxActualIdRawLo&#160;<br/>
&#160;&#160;The polling&#160;Tasks are allowed to&#160;be called in Sleep mode, too.&#160;<br/>
&#160;&#160;Improvement of usage of assertions&#160;<br/>
&#160;&#160;Same OSEK OS interrupt category for all CAN interrupts.&#160;<br/>
&#160;&#160;Variable data&#160;length replaced by copying data with&#160;received DLC and DLC check&#160;<br/>
against minimum length.&#160;<br/>
&#160;&#160;Description of dynamic pretransmit function,&#160;dynamic&#160;confirmation function and dynamic&#160;<br/>
acceptance filtering removed.&#160;<br/>
&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
20&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=21></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-21_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-21_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>4&#160;&#160;Overview&#160;</b><br/>
For error prevention,&#160;maintainability and expandability of&#160;Application programs, it is&#160;<br/>essential to&#160;have a uniform interface between&#160;Application and CAN Driver, mostly&#160;<br/>independent of the CAN Controller used.&#160;The CAN Driver itself must be adapted to the&#160;<br/>CAN Controller for reasons of efficiency.&#160;This yields&#160;the following requirements for a&#160;<br/>universally applicable CAN Driver:&#160;<br/>
&#160;&#160;Independent of&#160;Application&#160;<br/>
&#160;&#160;Driver code optimized for the CAN Controller used&#160;<br/>
&#160;&#160;Uniform interface to the&#160;Application for different CAN Controllers&#160;<br/>
&#160;&#160;Efficient usage of hardware resources, especially RAM and run time&#160;<br/>
&#160;&#160;Support of&#160;special services like&#160;Interaction Layer, Network Management,&#160;Transport&#160;<br/>
Protocol&#160;<br/>
&#160;<br/>
Figure 4-1&#160;&#160;Relationship of the individual Software Components. &#160;They&#160;are customized by&#160;the&#160;Generation&#160;Tool&#160;<br/>
The generic CAN Driver code&#160;is independent of&#160;the Application.&#160;Only&#160;the callback&#160;<br/>functions have to be given by the&#160;Application.&#160;The&#160;Application specific description data are&#160;<br/>stored in dedicated data&#160;structures.&#160;The structure of the description data is fixed; however,&#160;<br/>the contents of the structures&#160;are defined according to the ECU specific behavior by the&#160;<br/>Generation&#160;Tool.&#160;This is done partly automatically based on information in the CAN&#160;<br/>database and partly manually by&#160;user specific settings in the&#160;Generation Tool. The&#160;data&#160;<br/>structures are specific for&#160;the CAN Controller,&#160;they are&#160;linked to the CAN Driver code&#160;<br/>(ROM-capable).&#160;<br/>The data&#160;to&#160;be transmitted or received are exchanged by&#160;default via global data&#160;buffers.&#160;<br/>These data buffers are CAN message based.&#160;They are also created by the Generation&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
21&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=22></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-22_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
Tool.&#160;Additionally, the Generation&#160;Tool creates signal-based access macros and/or&#160;<br/>functions.&#160;This means the&#160;Application does not have to know&#160;the location and the structure&#160;<br/>of the global data buffers.&#160;The names of the access macros/functions are formed from the&#160;<br/>signal names in the CAN database.&#160;The detailed structure&#160;and features of the access&#160;<br/>macros/functions are described in the&#160;documentation of the Generation&#160;Tool.&#160;<br/>The Generation&#160;Tool will not be&#160;discussed in this CAN Driver documentation, since it&#160;is&#160;<br/>irrelevant for the CAN Driver functionality.&#160;But the generated data&#160;structures are highly&#160;<br/>optimized for an efficient usage&#160;of each CAN Controller.&#160;Therefore the usage of the&#160;<br/>Generation&#160;Tool is a must to&#160;customize the CAN Driver code&#160;to the special needs of the&#160;<br/>Application.&#160;<br/>
<b>4.1&#160;&#160;Short Summary&#160;of the Functional Scope&#160;<br/></b>In this section the main tasks of the CAN Driver are summarized very briefly:&#160;<br/>1.&#160;&#160;Initialize the CAN Controller&#160;<br/>
2.&#160;&#160;Transmit a single CAN message&#160;<br/>
3.&#160;&#160;Receive a single CAN messages&#160;<br/>
4.&#160;&#160;Handle Bus-Off &#160;<br/>
5.&#160;&#160;Support sleep mode&#160;<br/>
6.&#160;&#160;Support special services&#160;<br/>
&#160;<br/>
<b>4.1.1&#160;&#160;Initialization&#160;<br/></b>There are&#160;several CAN Driver&#160;service functions for initialization purposes available.&#160;<br/>CanInitPowerOn(..) for the complete initialization of software and hardware after power-on,&#160;<br/>CanResetBusOffStart(..) and CanResetBusOffEnd(..) for the re-initialization of the CAN&#160;<br/>Controller after BusOff. For any other re-initialization the application can call CanInit(..).&#160;<br/>Various initialization data structures can be predefined by the Generation&#160;Tool and&#160;<br/>referenced in the&#160;Application by means&#160;of a specific initialization handle.&#160;<br/>
<b>4.1.2&#160;&#160;Transmission&#160;<br/></b>One of the main services provided by the CAN&#160;Driver is to set up a transmit request in the&#160;<br/>CAN Controller by the service function CanTransmit(..).&#160;The reference to the CAN&#160;<br/>message specific description data is done by&#160;a transmit handle used in the&#160;Application.&#160;<br/>This information like CAN identifier and DLC is set up by the&#160;Generation&#160;Tool based on the&#160;<br/>CAN Database and additional user specific settings. If the CAN Controller is busy because&#160;<br/>all hardware&#160;transmit objects are currently&#160;reserved, the transmit request can be stored&#160;<br/>temporarily in a transmit queue.&#160;The number of hardware transmit objects depends on the&#160;<br/>CAN Controller or CAN Driver configuration.&#160;For details&#160;please&#160;refer to the CAN Controller&#160;<br/>specific documentation&#160;TechnicalReference_CAN_&lt;hardware&gt;.pdf&#160;&#160;[#hw_comObj]. If the&#160;<br/>CAN Controller is ready,&#160;data can be copied by&#160;different mechanism to the hardware&#160;<br/>transmit registers.&#160;The return code of the transmit function informs whether the transmit&#160;<br/>request was accepted by the&#160;CAN Driver or not. If it was rejected by an error and no&#160;<br/>transmit queue is used, the&#160;Application is&#160;responsible for the repetition of the transmit&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
22&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=23></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-23_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
request until the message is&#160;in&#160;the CAN Controller.&#160;A&#160;successful transmission is signaled&#160;<br/>by a confirmation. Special features like offline or passive mode are available to control the&#160;<br/>transmit path of the CAN Driver by&#160;the Network Management&#160;or Diagnostics.&#160;<br/><b>4.1.3&#160;&#160;Reception&#160;<br/></b>If a message on the CAN bus was accepted by&#160;the hardware and software acceptance&#160;<br/>filtering, data can be read by different mechanism and this asynchronous event is notified&#160;<br/>to the application by an indication.&#160;Additionally a special&#160;callback function&#160;<br/>ApplCanMsgReceived() allows the user to access receive data directly in the scope of a&#160;<br/>receive interrupt before the software acceptance filtering.&#160;The algorithm for the software&#160;<br/>acceptance filtering is configurable because in some&#160;Applications a lot of irrelevant CAN&#160;<br/>identifiers are passing the hardware acceptance filter and an efficient software filtering is&#160;<br/>very important.&#160;<br/>
<b>4.1.4&#160;&#160;Bus-Off&#160;<br/></b>The CAN Driver notifies a detected BusOff&#160;state to the&#160;Application by calling a special&#160;<br/>callback function&#160;ApplCanBusOff(). Further processing like re-initialization of the CAN&#160;<br/>Controller and additional customer-specific requirements like disabling transmissions for a&#160;<br/>certain time have to be done by the&#160;Application.&#160;<br/>
<b>4.1.5&#160;&#160;Sleep Mode&#160;<br/></b>Some CAN Controller are supporting a so&#160;called sleep&#160;mode with reduced power&#160;<br/>consumption.&#160;The CAN Driver provides the service&#160;functions CanSleep() and&#160;<br/>CanWakeUp() to enter and leave this special mode on request of the&#160;Application. &#160;<br/>If the CAN Controller is also&#160;wakeable&#160;by the CAN bus,&#160;the callback function&#160;<br/>ApplCanWakeUp() is called if this condition is&#160;detected. In some cases this leads to the&#160;<br/>situation that the CAN controller is initialized (CanWakeUp) before the application will be&#160;<br/>notified. &#160;<br/>In case of&#160;changing the PLL&#160;(SLEEP&#160;=&#160;slow speed /&#160;ACTIVE = normal speed) the&#160;<br/>application must be informed immediately.&#160;Otherwise the “long”&#160;interrupt execution causes&#160;<br/>a watchdog reset.&#160;Therefore the callback function&#160;<a href="TechnicalReference_CANDrivers.html#115">ApplCanPreWakeUp is c</a>alled just after&#160;<br/>the activation of the wakeup interrupt.&#160;The configuration is&#160;done via the&#160;Generation&#160;Tool or&#160;<br/>user configuration file.&#160;<br/>&#160;<br/><b>4.1.6&#160;&#160;Special Features&#160;<br/></b>There is additional support&#160;for special features like&#160;<br/>
&#160;&#160;Status of CAN Driver and CAN Controller&#160;<br/>
&#160;&#160;Interrupt control&#160;<br/>
&#160;&#160;Assertions&#160;<br/>
&#160;&#160;Hardware loop check&#160;<br/>
&#160;&#160;Support of OSEK compliant operating systems&#160;<br/>
&#160;&#160;Multiple-channel CAN Driver&#160;<br/>
&#160;&#160;Polling mode&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
23&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=24></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-24_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;&#160;Handling of&#160;Extended Identifiers&#160;<br/>
&#160;&#160;Stop mode&#160;<br/>
<b>4.2&#160;&#160;Data Structures for CAN Driver Customization&#160;<br/></b>The description data created by the Generation&#160;Tool are split into&#160;initialization structures&#160;<br/>for the CAN Controller as well as transmission and reception structures for CAN&#160;<br/>messages.&#160;They are located in the ROM memory&#160;of the microprocessor.&#160;The receive and&#160;<br/>transmit buffers are mapped in RAM data and will&#160;be referenced by the description data.&#160;<br/>The description data also contains references (pointers) to user-specific functions of the&#160;<br/>Application.&#160;The CAN Driver accesses all the&#160;structures in the description data.&#160;The CAN&#160;<br/>Driver is independent of the&#160;Application but the generated description data depends on the&#160;<br/>particular Application.&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
24&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=25></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-25_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-25_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;<br/>
Figure 4-2&#160;&#160;Description data,&#160;CAN Driver and&#160;Application with their interfaces.&#160;<br/>
<b>4.2.1&#160;&#160;ROM Data&#160;</b><br/>
<b>4.2.1.1&#160;</b><br/>
<b>Initialization Structures&#160;</b><br/>
The CAN Controller is initialized&#160;with&#160;the&#160;description&#160;data stored in the initialization&#160;<br/>structures.&#160;They consist of the register values for the CAN Controller.&#160;They are highly&#160;<br/>dependent on the particular&#160;used CAN Controller.&#160;&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
25&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=26></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-26_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>4.2.1.2&#160;</b><br/>
<b>Transmit Structures&#160;</b><br/>
The structures listed below are used&#160;by the CAN Driver internally. &#160;<br/>ID &#160;<br/>
Identifier of the messages to be transmitted.&#160;The format is CAN&#160;<br/>Controller dependent for efficiency reasons.&#160;<br/>
DLC&#160;&#160;<br/>
Number of data bytes to be transmitted (Data Length Code).&#160;<br/>The format is CAN Controller dependent for efficiency reasons.<br/>
DataPtr &#160;<br/>
Pointer to the CAN&#160;message based&#160;global transmit buffer.&#160;<br/>
UserPreTransmitPtr&#160;&#160;<br/>
Pointer to the user specific pretransmit function&#160;(must be a&#160;<br/>NULL&#160;pointer if not used).&#160;<br/>
UserConfirmationPtr &#160;<br/>
Pointer to the user specific confirmation function&#160;(must be a&#160;<br/>NULL&#160;pointer if not used).&#160;<br/>
ConfirmationOffset/Mask&#160;&#160;Byte offset and bit mask&#160;for the CAN&#160;Driver access to the&#160;<br/>
corresponding confirmation flag.&#160;<br/>
&#160;<br/>
<b>4.2.1.3&#160;</b><br/>
<b>Receive Structures&#160;</b><br/>
The structures listed below are used&#160;by the CAN Driver internally. &#160;<br/>ID&#160;<br/>
Identifier of the messages to be received.&#160;The format is CAN&#160;<br/>Controller dependent for efficiency reasons.&#160;<br/>
DataLen&#160;<br/>
Number of data bytes to be copied.&#160;The value may be different&#160;<br/>from the DLC of the message received.&#160;The driver then only&#160;<br/>copies the number of bytes stored in&#160;this structure.&#160;The other&#160;<br/>bytes are ignored.&#160;<br/>
DataPtr&#160;<br/>
Pointer to the CAN&#160;message based&#160;global receive buffer.&#160;<br/>
UserPrecopyPtr&#160;<br/>
Pointer to the user specific precopy function (must be a NULL&#160;<br/>pointer if not&#160;used).&#160;<br/>
UserIndicationPtr&#160;<br/>
Pointer to the user specific indication&#160;function (must be a NULL&#160;<br/>pointer if not&#160;used).&#160;<br/>
IndicationOffset/Mask&#160;<br/>
Byte offset and bit mask&#160;for the CAN&#160;Driver access to the&#160;<br/>corresponding indication flag.&#160;<br/>
&#160;<br/>
<b>4.2.2&#160;&#160;RAM Data&#160;<br/></b>The RAM data consist of transmit and receive buffers for the CAN messages.&#160;<br/>In the data buffers, the first byte transmitted or&#160;received is located at the least significant&#160;<br/>address of the data array (Note:&#160;Bit 7 is transmitted first). &#160;<br/>For some microprocessors there are memory areas which can be accessed more&#160;<br/>efficiently (e.g. internal RAM or bit addressable segments).&#160;The data&#160;buffers can be&#160;<br/>mapped by&#160;the Generation&#160;Tool.&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
26&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=27></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-27_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>5&#160;&#160;Detailed Description of the&#160;Functional Scope (Standard)&#160;</b><br/>
<b>5.1&#160;</b><br/>
<b>Initialization&#160;</b><br/>
<b>5.1.1&#160;&#160;Power-On Initialization of the CAN Driver&#160;<br/></b>The following service function must be called&#160;once after power-on to initialize the CAN&#160;<br/>Driver:&#160;<br/>void CanInitPowerOn( void );&#160;<br/>&#160;<br/>This call initializes the CAN Controller for each channel and all&#160;CAN Driver variables (local&#160;<br/>and global),&#160;i.e. the CAN Driver is&#160;set to online and active state.&#160;<br/>This service function has to be called for&#160;a proper initialization&#160;before any other CAN&#160;<br/>Driver function and before the global interrupts are enabled.&#160;<br/>
<b>5.1.2&#160;&#160;Re-Initialization of&#160;the CAN Controller&#160;<br/></b>The CAN Controller is completely re-initialized by the service function call:&#160;<br/>void CanInit( CanInitHandle initObject );&#160;<br/>&#160;<br/>The parameter initObject means a handle for a specific initialization structure.&#160;<br/>It is a must to bring the CAN Driver&#160;into offline state before this service function is called.&#160;<br/>By this service function only the CAN Controller and the corresponding internal variables&#160;<br/>will be initialized. Software states like online/offline or active/passive remain unchanged.&#160;<br/>Changes of individual registers of the CAN Controller are only&#160;possible by means of a&#160;<br/>complete re-initialization, i.e. an entire initialization structure must be provided for each&#160;<br/>register change (e.g. bit timing,&#160;acceptance filtering, .. ).&#160;<br/>
<b>5.2&#160;</b><br/>
<b>Transmission&#160;</b><br/>
<b>5.2.1&#160;&#160;Detailed Functional Description&#160;<br/></b>This section shows the transmission of a&#160;CAN message using different methods. For the&#160;<br/>general processing first a flow chart is used.&#160;The gray&#160;decision symbols branch to features&#160;<br/>that can be removed from&#160;the CAN Driver using the configuration options (see&#160;<a href="TechnicalReference_CANDrivers.html#28">Figure 5-1).&#160;<br/></a>In a second step sequence charts are used to&#160;show how the different objects of the CAN&#160;<br/>Driver, description data and&#160;Application program work together. &#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
27&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>&#160;<br/>
<hr/>
<a name=28></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-28_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>STARTING&#160;POINT</b><br/>
<b>Application</b><br/>
<b>Leave Transmit&#160;Interrupt</b><br/>
<b>CanTransmit</b><br/>
<b>Yes</b><br/>
<b>CanTransmitQueuedObj</b><br/>
<b>No</b><br/>
Queue Empty<br/>
<b>Yes</b><br/>
<b>CAN&#160;offline</b><br/>
<b>Use&#160;not</b><br/>
<b>No</b><br/>
<b>Use</b><br/>
<b>Transmit Queue</b><br/>
<b>Configured</b><br/>
<b>Part&#160; offline</b><br/>
<b>check</b><br/>
<b>Not&#160;configured</b><br/>
<b>Yes</b><br/>
<b>CAN&#160;offline</b><br/>
Confirmation Function<br/>
<b>Not configured</b><br/>
<b>Yes</b><br/>
<b>Part&#160;&#160;offline</b><br/>
<b>No</b><br/>
<b>Configured</b><br/>
<b>Confirmation Function&#160;</b><br/>
<b>Defined</b><br/>
<b>No</b><br/>
Confirmation&#160;Flag<br/>
<b>Use Queue</b><br/>
<b>Use</b><br/>
<b>Not configured</b><br/>
<b>Configured</b><br/>
<b>Confirmation Flag</b><br/>
<b>Use not</b><br/>
<b>Defined</b><br/>
Transmit&#160;Buffer Full<br/>
<b>Yes</b><br/>
<b>No</b><br/>
Confirm Transmission<br/>
<b>Use&#160;not</b><br/>
<b>Configured</b><br/>
<b>Pretransmit&#160;Function&#160;</b><br/>
<b>defined</b><br/>
<b>Use</b><br/>
<b>Confirmation of&#160;</b><br/>
<b>Transmission</b><br/>
Pretransmit&#160;Function<br/>
<b>Not&#160;configured</b><br/>
<b>Yes</b><br/>
Confirm&#160;TxObserve<br/>
kCanCopyData<br/>
<b>Use&#160;not</b><br/>
<b>Use</b><br/>
<b>No</b><br/>
<b>Use&#160;TxObserve</b><br/>
<b>Copy&#160;Data</b><br/>
<b>Switches&#160;in the&#160;Generation&#160;Tool for&#160;<br/>optional&#160;features&#160;of the&#160;CAN&#160;Driver</b><br/>
<b>Enter&#160;Transmit&#160;Interrupt</b><br/>
<b>Decisions in&#160;the&#160;code, if&#160;the feature&#160;is&#160;selected.</b><br/>
<b>Initiate&#160;Transmit</b><br/>
<b>Optional or mandatory&#160;functions&#160;of&#160;the CAN&#160;Driver</b><br/>
<b>No</b><br/>
end<br/>
<b>Interrupt Enabled</b><br/>
<b>Mandatory&#160;path through the&#160;CAN&#160;Driver</b><br/>
Queue<br/>
<b>Use</b><br/>
<b>Use TxObserve</b><br/>
<b>Yes</b><br/>
<b>Optional path&#160;through&#160;the CAN&#160;Driver</b><br/>
TxObserve Started<br/>
<b>Use not</b><br/>
<b>Direction of&#160;work&#160;flow</b><br/>
<b>ACKNOWLEDGE</b><br/>
<b>(sent message received)</b><br/>
CAN&#160;Message<br/>
<b>Transmit</b><br/>
&#160;<br/>
Figure 5-1&#160;&#160;Transmission of a CAN message&#160;&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
28 / 149&#160;<br/>
based on template&#160;version 2.1&#160;<br/>
&#160;<br/>
<hr/>
<a name=29></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-29_1.png"/><br/>
&#160;<br/>
The main service function to initiate&#160;a transmit request is &#160;<br/>vuint8 CanTransmit( CanTransmitHandle txObject );&#160;<br/>
&#160;<br/>
The function parameter is a transmit message handle. It represents an index in the&#160;<br/>generated transmit description data.&#160;The return&#160;code contains the following information:&#160;<br/>
kCanTxOk&#160;<br/>
Successful&#160;transmit request.&#160;The message is sent out by the&#160;<br/>CAN Controller without&#160;any further action required. For CAN&#160;<br/>Drivers with transmit queue, this return code is also used if the&#160;<br/>transmit request has been accepted&#160;in the queue, even if it&#160;was&#160;<br/>already in queue.&#160;<br/>
kCanTxFailed&#160;<br/>
CAN transmit request failed. In this&#160;case the calling application&#160;<br/>has to repeat the transmit request later.&#160;<br/>&#160;<br/>
kCanTxPartOffline&#160;<br/>
Error code because CAN Driver’s&#160;transmit path is in partial&#160;<br/>offline mode&#160;for this transmit object.&#160;<br/>
&#160;<br/>The left&#160;path&#160;(see&#160;<a href="TechnicalReference_CANDrivers.html#28">Figure 5-1) time flows</a>&#160;from top to&#160;bottom.&#160;This path shows the program&#160;<br/>flow calling the service function CanTransmit(..). First the CAN Driver checks whether the&#160;<br/>transmit path is switched to offline state. If so&#160;the function returns with an error code.&#160;Then&#160;<br/>the Driver checks (if configured)&#160;the partial offline mode. If the specified message is offline,&#160;<br/>the function will return an error code. &#160;<br/>In the next step the CAN Driver checks the availability&#160;of a hardware transmit object. If no&#160;<br/>object is available the transmit request is stored in the transmit queue&#160;(if configured to be&#160;<br/>used) and the CAN Driver returns to the&#160;Application with the&#160;return code kCanTxOk. If no&#160;<br/>transmit queue is used the CAN Driver&#160;returns with an error code kCanTxFailed.&#160;<br/>If a transmit object is available the CAN identifier and the data length code will be set&#160;in&#160;<br/>accordance to the description data. Now,&#160;if&#160;a pretransmit function is configured, this&#160;<br/>pretransmit function will be&#160;called. Within this&#160;user specific function the&#160;Application may&#160;<br/>copy the data&#160;to be transmitted directly to&#160;the CAN Controller hardware registers. If the&#160;<br/>data is completely copied, the pretransmit function returns kCanNoCopyData&#160;to the CAN&#160;<br/>Driver. &#160;<br/>&#160;<br/>The data has to be copied by the CAN Driver itself, if there is no pretransmit function&#160;<br/>defined or this function returns kCanCopyData. In&#160;this case the CAN Driver copies the data&#160;<br/>from the global data buffer&#160;associated with the message to the CAN Controller hardware&#160;<br/>registers.&#160;<br/>Then the transmission of the CAN message is&#160;started in the CAN Controller and the&#160;<br/>function returns the code kCanTxOk to the&#160;Application.&#160;<br/>Dependent&#160;on the configuration, the&#160;TxObserve function is now started.&#160;<br/>In the right path of the figure&#160;below, the time flows&#160;from bottom to top.&#160;This path shows the&#160;<br/>program flow in the interrupt service routine after a successfully transmission of the&#160;<br/>message to the CAN bus. In the&#160;transmit interrupt routine,&#160;the confirmation actions are&#160;<br/>performed. If configured, first the&#160;TxObservation is&#160;confirmed, then (if configured)&#160;a&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
29&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=30></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-30_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
confirmation function for all messages is called.&#160;Afterwards the confirmation flag is&#160;set and&#160;<br/>then the message-specific confirmation function is called. &#160;<br/>If the CAN Driver is configured to&#160;use a transmit queue, after processing the confirmation&#160;<br/>actions the CAN Driver checks if the transmit&#160;queue is empty.&#160;If so the transmit interrupt&#160;<br/>routine is finished. If there are entries in&#160;the queue the highest priority CAN message is&#160;<br/>removed from the queue and the transmission of this&#160;message is requested.&#160;This is also&#160;<br/>done on interrupt level.&#160;<br/>In the middle of the picture we see the transmit queue which&#160;is used if all hardware&#160;<br/>transmit objects are busy, when CanTransmit(..) is called.&#160;<br/>The next sections describe&#160;the transmission of a CAN message using sequence charts.&#160;<br/>The vertical lines within these diagrams represent program objects like interrupt routines,&#160;<br/>functions (thick lines) or data objects (thin lines).&#160;The horizontal lines represent program&#160;<br/>flow or data access within the program. Flow&#160;control and program instances are described&#160;<br/>using thick&#160;lines, data access is described using&#160;thin lines.&#160;Time flows from the top of a&#160;<br/>chart downwards so that sequence „1“ is performed before sequence „2“.&#160;The description&#160;<br/>of the sequence charts is given in&#160;the tables following the charts. &#160;<br/>&#160;<br/>The first sequence ch<a href="TechnicalReference_CANDrivers.html#30">art in&#160;Figure 5-2 shows the behavior if&#160;</a>a hardware transmit object is&#160;<br/>available, a global data&#160;buffer is&#160;associated to the message and the copy&#160;mechanism of&#160;<br/>the CAN Driver is used. &#160;<br/>&#160;<br/>
CAN&#160;Data<br/>
TX&#160;Interrupt<br/>
Can-<br/>
Driver<br/>
Global&#160;Data<br/>
Conf.<br/>
CAN<br/>
Conf. Flag<br/>
Pretransmit<br/>
Application<br/>
Buffer<br/>
Routine<br/>
Transmit<br/>
Parameters&#160;Buffer<br/>
Function<br/>
1<br/>
2<br/>
3<br/>
4<br/>
&#160;5<br/>
6<br/>
7<br/>
8<br/>9<br/>
10<br/>
&#160;<br/>
Figure 5-2&#160;&#160;Transmission with&#160;an available&#160;transmit object; Using&#160;global data buffer&#160;<br/>
<b>No&#160;</b><br/>
<b>Description&#160;</b><br/>
1&#160;<br/>
The&#160;Application writes the data to the global data&#160;buffer&#160;<br/>
2&#160;<br/>
The&#160;Application calls CanTransmit(..) service function &#160;<br/>
3&#160;<br/>
Function uses description data (CAN identifier,&#160;DLC, etc...)&#160;<br/>
4&#160;<br/>
Global data buffer is read and copied; the transmit process&#160;is started&#160;<br/>
5&#160;<br/>
CanTransmit(..) service function is finished, the return code is&#160;kCanTxOk&#160;<br/>
6&#160;<br/>
The message is successfully sent to&#160;the CAN bus.&#160;Transmit interrupt routine is&#160;<br/>started&#160;<br/>
7&#160;<br/>
Transmit confirmation flag is set (cleared by the&#160;Application)&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
30&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=31></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-31_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
8&#160;<br/>
Confirmation function is called&#160;<br/>
9&#160;<br/>
Confirmation functions returns to transmit interrupt routine&#160;<br/>
10&#160;<br/>
Transmit interrupt routine is left&#160;<br/>
&#160;<br/>The next sequence chart in shows the behavior&#160;if a hardware transmit object is available&#160;<br/>and a pretransmit function is used&#160;to copy the data to be sent.&#160;<br/>&#160;<br/>
&#160;<br/>
CAN&#160;Data<br/>
TX&#160;Interrupt&#160;Can-<br/>
Driver<br/>
Global&#160;Data<br/>
Conf.<br/>
CAN<br/>
Conf.&#160;Flag<br/>
Pretransmit<br/>
Application<br/>
Buffer<br/>
Routine<br/>
Transmit<br/>
Parameters&#160;Buffer<br/>
Function<br/>
1<br/>
2<br/>
3<br/>
4<br/>
5<br/>
6<br/>
7<br/>
8<br/>
9<br/>
10<br/>
11<br/>
&#160;<br/>
Figure 5-3&#160;&#160;Transmission with&#160;an available hardware transmit&#160;object; Using a pretransmit function&#160;to copy&#160;data&#160;<br/>
&#160;<br/>
<b>No&#160;</b><br/>
<b>Description&#160;</b><br/>
1&#160;<br/>
CanTransmit(..) service function is called by the&#160;Application&#160;<br/>
2&#160;<br/>
Function reads the description data (CAN identifier, DLC, etc.)&#160;<br/>
3&#160;<br/>
Call of the pretransmit function&#160;<br/>
4&#160;<br/>
Pretransmit function writes data to the CAN Controller&#160;<br/>
5&#160;<br/>
Pretransmit function returns to CanTransmit(..)&#160;<br/>
6&#160;<br/>
Start transmission; CanTransmit(..) service function is finished and the return code&#160;<br/>is kCanTxOk&#160;<br/>
7&#160;<br/>
The message is successfully sent to&#160;the CAN bus.&#160;Transmit interrupt routine is&#160;<br/>started&#160;<br/>
8&#160;<br/>
Transmit confirmation flag is set (cleared by the&#160;Application)&#160;<br/>
9&#160;<br/>
Confirmation function is called&#160;<br/>
10&#160;<br/>
Confirmation function returns to transmit interrupt routine&#160;<br/>
11&#160;<br/>
Transmit interrupt routine is left&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
31&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=32></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-32_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
The next sequence chart in shows the behavior,&#160;if no hardware transmit object is available.&#160;<br/>This sequence chart is valid only&#160;if the CAN Driver is configured to use a transmit queue.&#160;<br/>The data is&#160;copied by the CAN Driver itself.&#160;<br/>&#160;<br/>
TX&#160;Interrupt<br/>
Can-<br/>
Driver<br/>
Global Data<br/>
Conf.&#160;<br/>
CAN&#160;<br/>
CAN Data<br/>
Conf. Flag<br/>
Application<br/>
Buffer<br/>
Routine<br/>
Transmit<br/>
Parameters<br/>
Buffer<br/>
Pretransmit&#160;Function<br/>
1<br/>
2<br/>3<br/>
4&#160;<br/>
5<br/>
6<br/>
7<br/>
8&#160;<br/>9&#160;<br/>
10&#160;<br/>
&#160;<br/>
Figure 5-4&#160;&#160;Transmit procedure if no&#160;hardware transmit object available&#160;<br/>
<b>No&#160;&#160;Description&#160;<br/></b>1&#160;<br/>
The&#160;Application writes the data to the global data&#160;buffer&#160;<br/>
2&#160;<br/>
The&#160;Application calls CanTransmit() service function. No hardware transmit objects&#160;<br/>available. Request is&#160;stored in the transmit queue.&#160;<br/>
3&#160;<br/>
Function returns kCanTxOk&#160;<br/>
4&#160;<br/>
Transmit interrupt:&#160;A&#160;(previous) CAN message was successfully sent, transmit object&#160;<br/>is available&#160;again&#160;<br/>
5&#160;<br/>
Confirmation flag of the&#160;previous CAN message is set (cleared by the&#160;Application) &#160;<br/>
6&#160;<br/>
Confirmation function of&#160;the previous CAN message is called&#160;<br/>
7&#160;<br/>
Confirmation function return&#160;<br/>
8&#160;<br/>
The transmit queue is checked for requests.&#160;The&#160;pending transmit request&#160;is found.&#160;<br/>The description data are evaluated (CAN identifier, DLC, etc...)&#160;<br/>
9&#160;<br/>
Global data buffer is read and copied; the transmit process&#160;is started&#160;<br/>
10&#160;&#160;Transmit interrupt routine is left&#160;<br/>
&#160;<br/><b>5.2.2&#160;&#160;Transmit Queue&#160;<br/></b>The normal&#160;Tx&#160;object can be configured to use a transmit queue or not.&#160;The&#160;Transmit&#160;<br/>Queue is not available for Full CAN Objects and the Low Level&#160;Transmit Object. If no&#160;<br/>transmit queue is used, the&#160;Application is&#160;responsible to restart a transmit request if it&#160;<br/>wasn’t accepted by the CAN Driver. In case&#160;of using a transmit queue, a transmit request&#160;<br/>is always accepted (if the driver is online). But the transmit queue holds only the transmit&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
32&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=33></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-33_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-33_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
request of a CAN message. It doesn’t store the data to be sent. Please note the same&#160;<br/>message can be queued only once.&#160;The CAN Driver sets a transmit request in the transmit&#160;<br/>queue, if no hardware transmit object is available after CanTransmit(..) is called. On a&#160;<br/>transmit interrupt, i. e. when a message has&#160;been sent successfully, the CAN Driver&#160;<br/>checks whether transmit requests are stored&#160;in the queue. If so, one requests&#160;is removed&#160;<br/>from the queue and the transmit request is executed.&#160;The search algorithm in the queue is&#160;<br/>priority based, there is no FIFO strategy.&#160;This means the CAN identifier with the lowest&#160;<br/>number is removed first from the queue.&#160;<br/>If the CAN Driver is configured to use a transmit queue, the internal data copy mechanism&#160;<br/>will be initiated and/or the pretransmit function will be called in the scope of a transmit&#160;<br/>interrupt after the completion of&#160;a previous&#160;transmit request.&#160;Therefore the user has to&#160;<br/>guarantee the data consistency,&#160;because an&#160;Application write access to the global data&#160;<br/>buffer may be interrupted by such a transmit interrupt. If within this interrupt the associated&#160;<br/>message is requested to be transmitted on the CAN bus, inconsistent data may be sent.&#160;<br/>The&#160;Application must ensure data consistency by one of the following mechanisms:&#160;<br/>
&#160;&#160;Disable Interrupts while writing&#160;data&#160;to the global data buffer&#160;<br/>
&#160;&#160;Use the message based confirmation flag&#160;to manage the data access handling. On&#160;<br/>
startup the access right is on&#160;Application side. Calling CanTransmit(..) this access right&#160;<br/>is given to the CAN Driver.&#160;As soon as the&#160;confirmation flag is set by the CAN Driver,&#160;<br/>the access right is given back to the&#160;Application.&#160;<br/>
&#160;&#160;In polling mode the service function CanTxTask() must be used to transmit queued&#160;<br/>
messages.&#160;The transmission of a CAN message is&#160;only started if the CanTxTask() is&#160;<br/>called. In polling mode every message is&#160;queued in the transmit&#160;queue. To&#160;ensure&#160;that&#160;<br/>every message was send the CanTxTask() may be called cyclic.&#160;<br/>
<b>5.2.3&#160;&#160;Data Copy&#160;Mechanisms&#160;<br/></b>There are two different methods&#160;for the&#160;Application to pass&#160;the data to be transmitted to&#160;<br/>the CAN Driver.&#160;The CAN Driver selects&#160;the method for each message depending on the&#160;<br/>CAN Driver description data. If no pretransmit&#160;function is defined, the usage of a global&#160;<br/>data buffer is a prerequisite and&#160;the CAN Drivers internal data copy mechanism is always&#160;<br/>used. If a pretransmit function is defined,&#160;the data to be transmitted may be stored&#160;<br/>anywhere in the&#160;Applications&#160;memory and the user defined copy mechanism in the&#160;<br/>pretransmit function is used.&#160;<br/>
<b>5.2.3.1&#160;</b><br/>
<b>Internal&#160;</b><br/>
With the internal data copy mechanism, the&#160;Application writes the data to be transmitted to&#160;<br/>a global data buffer associated with the transmit message.&#160;The global data buffer is&#160;<br/>defined by the Generation&#160;Tool.&#160;The access to the global data buffer is done by means of&#160;<br/>access macros and/or functions which are also defined by the Generation&#160;Tool.&#160;After&#160;<br/>passing the data to the global data buffer,&#160;the&#160;Application initiates&#160;the transmit request by&#160;<br/>calling CanTransmit(..) and the data&#160;is copied internally to the CAN Controller hardware&#160;<br/>registers.&#160;<br/>
<b>Important&#160;<br/></b>Data consistency of CAN messages has to be guaranteed by the&#160;Application if&#160;<br/>
&#160;&#160;CanTransmit(..) is called&#160;on a higher&#160;interrupt or task level, or&#160;the transmit queue is&#160;<br/>
used.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
33&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=34></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-34_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-34_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-34_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-34_4.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>5.2.3.2&#160;</b><br/>
<b>User defined (“Pretransmit Function”)&#160;</b><br/>
Using the pretransmit function to pass the data to be transmitted to the CAN bus, the&#160;<br/>Application first initiates the transmit request&#160;by calling CanTransmit(..). Just before the&#160;<br/>message is&#160;put in the CAN chip, the CAN Driver calls a user&#160;defined pretransmit function.&#160;<br/>For each transmit message a separate pretransmit function may be defined. Within this&#160;<br/>user specific function the user&#160;can write the data directly to&#160;the hardware registers of the&#160;<br/>CAN Controller,&#160;but other tasks&#160;can also be performed.&#160;The return code of the pretransmit&#160;<br/>function indicates to the CAN Driver whether&#160;the data are to be copied by the CAN Driver&#160;<br/>internally from the global data buffer to the CAN Controller hardware registers or not (if it&#160;is&#160;<br/>already done within the&#160;pretransmit function).&#160;<br/>&#160;<br/>
<b>Important&#160;<br/></b>Be careful if&#160;a pretransmit function is&#160;used. Interrupts are not disabled during the call&#160;of&#160;<br/>
&#160;&#160;this user&#160;specific function by the CAN Driver, therefore the restrictions&#160;for&#160;security level 0&#160;<br/>
are valid. If the interrupts are not disabled before&#160;and restored after the copy process by&#160;<br/>the&#160;Application, data consistency of a&#160;CAN&#160;messages cannot&#160;be guaranteed if the&#160;<br/>transmit queue is used.&#160;<br/>
<b>5.2.4&#160;&#160;Notification&#160;<br/></b>After the successful transmission of a message on the CAN bus&#160;(i.e. at least one other&#160;<br/>CAN bus node received the CAN message correctly with an acknowledge), the&#160;Application&#160;<br/>can be notified by different confirmation mechanisms:&#160;<br/><b>5.2.4.1&#160;</b><br/>
<b>Data Interface (Confirmation Flag)&#160;</b><br/>
If a confirmation flag is used, this message related flag is set by the CAN Driver, if the&#160;<br/>associated CAN message was sent on the CAN bus.&#160;This is done in the scope of the&#160;<br/>transmit interrupt.&#160;The flag must&#160;be cleared by the&#160;Application.&#160;<br/>&#160;<br/>
<b>Important&#160;<br/></b>Interrupts have to be disabled while&#160;the confirmation flags are being cleared, because of&#160;<br/>
&#160;&#160;the read-modify-write conflict if&#160;this operation is&#160;interrupted by a CAN transmit interrupt&#160;<br/>
routine.&#160;This can result&#160;in the loss of&#160;events. &#160;<br/>
<b>5.2.4.2&#160;</b><br/>
<b>Functional Interface (Confirmation Function for each message)&#160;</b><br/>
In parallel or instead of the data interface a functional interface can be configured, i.e. user&#160;<br/>specific function is called if the associated CAN message was sent on the CAN bus.&#160;This&#160;<br/>is also done in the scope of the transmit interrupt and therefore&#160;special care of the run time&#160;<br/>of this function has to be taken.&#160;<br/><b>5.2.4.3&#160;</b><br/>
<b>Functional Interface (Common Confirmation Function for all messages)&#160;</b><br/>
A&#160;common confirmation function&#160;informs the application via&#160;<a href="TechnicalReference_CANDrivers.html#116">ApplCanTxConfirmation about&#160;<br/></a>a successful transmission of a message.&#160;Any&#160;message is&#160;confirmed via this callback&#160;<br/>function.&#160;<br/>&#160;<br/>
<b>Info</b>&#160;<br/>A&#160;canceled transmission&#160;will provoke a notification if the message was send on the bus.&#160;<br/>
&#160;&#160;If the message had been&#160;deleted out&#160;of the hardware, the application will not be notified.&#160;<br/>
<a href="TechnicalReference_CANDrivers.html#1">More…</a>&#160;<br/>
&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
34&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=35></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-35_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-35_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>5.2.5&#160;&#160;Offline Mode&#160;<br/></b>The CAN Driver's transmit path can be switched to&#160;the offline state, i.e. disabled. In this&#160;<br/>state no CAN messages are sent to the&#160;CAN bus. On each transmit request the CAN&#160;<br/>Driver checks the internal flag which indicates whether the transmission is currently&#160;<br/>disabled and the transmit service function returns an error code.&#160;This flag is&#160;set and reset&#160;<br/>by the following CAN Driver service functions&#160;<br/>void CanOnline( void );&#160;<br/>void CanOffline( void );&#160;<br/>&#160;<br/>These CAN Driver service functions are called by the Network Management or by the&#160;<br/>Application (only if there is no Network Management available on a specific CAN channel).&#160;<br/>&#160;<br/>The&#160;Application can be notified about the mode change (e.g. if the Network Management&#160;<br/>calls&#160;CanOnline()&#160;or&#160;CanOffline()).&#160;This is done with the following callback functions:&#160;<br/>
&#160;<br/>void ApplCanOnline( void );&#160;<br/>void ApplCanOffline( void );&#160;<br/>&#160;<br/><b>5.2.6&#160;&#160;Partial Offline Mode&#160;<br/></b>The partial Offline Mode enables&#160;the application&#160;to prevent the transmission of groups of&#160;<br/>CAN messages. CanTransmit() returns a special code, if the requested message cannot&#160;<br/>be sent because of the active partial offline mode.&#160;The partial&#160;offline mode is implemented&#160;<br/>by the following functions:&#160;<br/>void &#160; CanPartOnline ( vuint8 sendGroup );&#160;<br/>void &#160; CanPartOffline( vuint8 sendGroup );&#160;<br/>vuint8 CanGetPartMode( void );&#160;<br/>&#160;<br/>The partial offline mode can handle up to eight different groups of messages.&#160;The function&#160;<br/>parameter sendGroup decides about this group.&#160;CanPartOffline() switches all messages&#160;of&#160;<br/>one ore more send groups to the offline state.&#160;Earlier calls of CanPartOffline() are not&#160;<br/>affected. CanPartOnline() switches one or&#160;more send groups back to online state. &#160;<br/>Each message might be assigned to one or&#160;more send groups.&#160;The names of the send&#160;<br/>groups are configurable. Each send group can be switched to offline or online by using the&#160;<br/>generated define:&#160;<br/>C_SEND_GRP_&lt;name&gt;&#160;<br/>C_SEND_GRP_ALL&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;can be used to switch&#160;all groups together to&#160;offline or online.&#160;<br/>&#160;<br/>
<b>Example</b>&#160;<br/>The following table shows, which message is assigned to which send group (CANgen&#160;<br/>
&#160;&#160;concept. For&#160;GENy concept, go to the next chapter.).&#160;<br/>
<b>&#160;</b><br/>
<b>send group name&#160;</b><br/>
7 6 5 4&#160;3&#160;User2&#160;User1&#160;User0<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
35&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=36></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-36_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-36_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-36_3.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
MESSAGE1&#160;<br/>
&#160; &#160;&#160;x&#160;&#160;x&#160;<br/>
x&#160;<br/>
&#160;<br/>
MESSAGE2&#160;<br/>
&#160; &#160;&#160;&#160;&#160;x&#160;<br/>
&#160;<br/>
x&#160;<br/>
MESSAGE3&#160;<br/>
&#160; &#160;&#160;x&#160;&#160;x&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
<b>Example</b>&#160;<br/>for a possible program flow:&#160;<br/>
&#160;&#160;CanPartOffline(C_SEND_GRP_User0); &#160;MESSAGE2 is stopped to be send&#160;<br/>
CanPartOffline(C_SEND_GRP_User1); &#160;MESSAGE1 is stopped to be send&#160;<br/>
&#160; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &#160;MESSAGE2 is still stopped to be send&#160;<br/>
status&#160;=&#160;CanGetPartMode();&#160;&#160; &#160; &#160;status is equal to ( C_SEND_GRP_User0&#160;<br/>
| &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;C_SEND_GRP_User1)&#160;<br/>
CanPartOnline(C_SEND_GRP_User0); MESSAGE1 is still stopped to be sent&#160;<br/>
&#160; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &#160;MESSAGE2 can be sent again&#160;<br/>
CanPartOffline(C_SEND_GRP_User0 | C_SEND_GRP_3);&#160;&#160;<br/>
&#160; &#160;MESSAGE1 is stopped to be sent &#160; &#160;&#160;<br/>&#160; &#160;MESSAGE2 is stopped to be sent &#160; &#160;<br/>&#160; &#160;MESSAGE3 is stopped to be sent&#160;<br/>
CanPartOnline(C_SEND_GRP_ALL); &#160;<br/>
&#160; &#160;All send groups are online again.&#160;All &#160; &#160;<br/>&#160; messages can be sent now.&#160;<br/>
<b>Info</b>&#160;<br/>If the offline&#160;mode and partial offline&#160;mode are used in parallel the offline&#160;<br/>
&#160;&#160;mode has ‘higher priority’.&#160;This means if&#160;the offline mode is set the function&#160;<br/>
CanTransmit always returns ‘kCanTxFailed’&#160;independent of the current&#160;<br/>partial offline state.&#160;<br/>
&#160;<br/>
&#160;<br/><b>5.2.6.1&#160;&#160;&#160;Partial Offline Mode with&#160;GENy&#160;<br/></b>In GENy there are &#160;<br/>
&#160;&#160;8 Offline Modes (SendGroups)&#160;<br/>
&#160;&#160;Default name is UserX, but can be changed&#160;as shown&#160;in the illustration below.&#160;There&#160;<br/>
<b>Offline mode 4</b>&#160;is changed to&#160;<b>MyGroup4</b>.&#160;<br/>
&#160;&#160;5 Message Classes for&#160;<br/>
&#160;&#160;Default (0)&#160;<br/>
&#160;&#160;Appl&#160;<br/>
&#160;&#160;Nm&#160;<br/>
&#160;&#160;Tp&#160;<br/>
&#160;&#160;Diag&#160;<br/>
&#160;&#160;Il&#160;<br/>
&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
36&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=37></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-37_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-37_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-37_3.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
All messages are assigned automatically to&#160;a message class using their attribute&#160;<br/>information from&#160;the DBC file. &#160;<br/>
&#160;<br/>
Figure 5-5&#160;&#160;Partial Offline Mode settings in GENy&#160;<br/>
<b>&#160;</b><br/>
<b>Info</b>&#160;<br/>You find this information in the configuration view of the CAN&#160;Driver. &#160;<br/>
&#160;<br/>
<b>&#160;</b><br/>
With the checked checkbox&#160;for OfflineMode4 (Message Class&#160;1 (APPL)&#160;all application&#160;<br/>messages are assigned to the Offline Mode 4. &#160;<br/>If you select an application message, you will find the following: &#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
37&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=38></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-38_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-38_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-38_3.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;<br/>
Figure 5-6&#160;&#160;One Single&#160;Application Message Selected&#160;<br/>
At the Message Class&#160;entry you see this&#160;is&#160;an application message and below you see&#160;<br/>your MyGroup4 and a checked checkbox. I.e.&#160;this message is assigned to MyGroup4.&#160;<br/>
&#160;<br/>
Figure 5-7&#160;&#160;User Defined assignment to Offline Modes&#160;<br/>
For any message you can decide whether to assign the message to another Offline Mode&#160;<br/>or to additionally assign the message to another Offline Mode.&#160;In the example above, the&#160;<br/>messate DummyTransmit (application message)&#160;is not assigned to MyGroup4 anymore.&#160;<br/>Now this message is assigned to USER2. &#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
38&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=39></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-39_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-39_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-39_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-39_4.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;<br/>
Figure 5-8&#160;&#160;Overview&#160;Messages and Offline Modes&#160;<br/>
<b>&#160;</b><br/>
<b>Info</b>&#160;<br/>If you cannot find any information concerning Offline Modes&#160;you should use the&#160;<br/>
&#160;&#160;Customize Grid functionality.&#160;Activate the view below via:&#160;<b>View|Customize Grid</b>&#160;and&#160;<br/>
then select&#160;<b>Offline Modes</b>. &#160;<br/>
&#160;<br/>
<b>&#160;</b><br/>
To&#160;get an overall view of which message is&#160;assigned to which group, or to do the&#160;<br/>necessary assignments having a good overview, select&#160;all&#160;<b>TxMessages</b>&#160;in the tree view&#160;<br/>and activate the Offline Modes via Customize Grid (described at the top of this chapter).&#160;<br/>
<b>5.2.7&#160;&#160;Passive State&#160;<br/></b>The CAN Driver's transmit path can be switched&#160;to the passive state. In passive state no&#160;<br/>transmit request is passed to the CAN bus, i.e. no CAN message is sent. However,&#160;there&#160;<br/>is only the CAN bus activity affected but not&#160;the&#160;Application interface because there is no&#160;<br/>error code returned and the notification is&#160;done in the normal&#160;way,&#160;i.e. the&#160;Application&#160;<br/>software runs in normal operating mode.&#160;This is the main difference to the offline mode.&#160;<br/>The passive state may be used to localize errors in a CAN bus and is realized by the&#160;<br/>following CAN Driver service functions&#160;<br/>void CanSetActive ( void );&#160;<br/>void CanSetPassive( void );&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
39&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=40></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-40_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-40_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-40_3.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;<br/>The passive&#160;state of the CAN Driver is&#160;usually&#160;used during the development phase of the&#160;<br/>CAN bus. If an&#160;Application might&#160;disturb the other nodes, it can be switched to passive&#160;<br/>state temporarily and simulated by an appropriated tool.&#160;This is usually&#160;done by a&#160;<br/>Diagnostics.&#160;<br/>&#160;<br/>
<b>Info</b>&#160;<br/>To use the Passive State efficiently there must be a special support by the network&#160;<br/>
&#160;&#160;designer.&#160;An&#160;external tool must be able to take over the tasks&#160;of the ECU&#160;simultaneously&#160;<br/>
when the ECU is switched to passive state.&#160;<br/>&#160;<br/>The passive state of the&#160;CAN Driver&#160;must not be mixed up with the passive state of&#160;<br/>OSEK&#160;Network Management. If the OSEK&#160;Network Management is put into passive&#160;<br/>state (service functions&#160;SilentNM /&#160;TalkNM) only&#160;Network Management messages are&#160;<br/>affected.&#160;The passive state of the CAN Driver prevents any&#160;CAN&#160;messages (including&#160;<br/>Network Management messages) from&#160;being sent on the CAN bus.&#160;<br/>
&#160;<br/>Also note the following hints for&#160;the usage of the passive state:&#160;<br/>
&#160;&#160;If the passive function is enabled the&#160;corresponding code in CanSetPassive() and&#160;<br/>
CanSetActive() is activated, otherwise only&#160;dummy macros will be provided.&#160;This results&#160;<br/>in less CAN Driver code and an&#160;easy way to switch off this service function without&#160;<br/>changing the&#160;Application software.&#160;<br/>
&#160;&#160;The&#160;Application calls the service function CanSetPassive() to prevent transmission. In&#160;<br/>
case of a transmit queue it is cleared, i.e.&#160;confirmation activities may be lost&#160;during the&#160;<br/>transition from active to passive state.&#160;Beginning with the next CanTransmit() the&#160;<br/>messages are not sent on the CAN bus&#160;until CanSetActive() is called.&#160;<br/>
In case of a transmit queue, the service function CanSetPassive() has to be called in&#160;<br/>the confirmation function of the last message&#160;to be sent on the CAN bus. If there is no&#160;<br/>such request, CanSetPassive() can be called at any time.&#160;<br/>In passive mode, the result seems to be successful, i.e. the code kCanTxOk is returned&#160;<br/>from CanTransmit(), and all&#160;configured flags&#160;(cleared by the&#160;Application) are set and the&#160;<br/>functions are called (Common Confirmation Function, Confirmation Flag and/or&#160;<br/>Confirmation Function).&#160;Tx Observation is not used in passive state.&#160;<br/>
&#160;&#160;To&#160;restart transmission, the service function CanSetActive() has to be called. Starting&#160;<br/>
with the next call of CanTransmit(), the messages are&#160;transmitted again&#160;on the CAN&#160;<br/>bus.&#160;<br/>
<b>Important&#160;<br/></b>If the CAN&#160;Driver is switched from active&#160;to passive state, the transmit queue will be&#160;<br/>
&#160;&#160;cleared and&#160;therefore some confirmations may be lost.&#160;<br/>
&#160;<br/><b>5.2.8&#160;&#160;Tx Observe&#160;<br/></b>This functionality is used to check the transmit path of the CAN Driver by the following&#160;<br/>way:&#160;After a successful transmit request in the&#160;CAN Controller a specific&#160;function is called:&#160;<br/>&#160;void ApplCanTxObjStart( logTxHwObject );&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
40&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=41></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-41_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;<br/>If the message was sent on the CAN network&#160;successfully another callback function is&#160;<br/>called in the scope of the transmit interrupt:&#160;<br/>void ApplCanTxObjConfirmed( logTxHwObject );&#160;<br/>&#160;<br/>This functionality can be used to observe any transmission.&#160;As the CAN Driver is not time&#160;<br/>triggered, the call back functions offer the application a way to start a timer with&#160;<br/>ApplCanTxObjStart and stop this&#160;timer with&#160;ApplCanTxObjConfirmed. In case of exceeding&#160;<br/>a predefined time for transmission, the message can be deleted or any other reaction can&#160;<br/>be done. &#160;<br/>In case of a well working system, these&#160;callback functions are normally called in a&#160;<br/>symmetric way within the maximum specified delay time which&#160;is allowed in the existing&#160;<br/>run time environment after a transmit request until the CAN message is sent to the CAN&#160;<br/>bus successfully. In case of a transmit error a time-out supervision&#160;can be implemented by&#160;<br/>these callback functions and error recovery can be done. If more than one hardware&#160;<br/>transmit object is used, these callback functions can be called in a nested way and so an&#160;<br/>additional counter is necessary.&#160;That counter has to be reset after each re-initialization of&#160;<br/>the CAN Controller.&#160;This can be done&#160;in the following callback function:&#160;<br/>void ApplCanInit( logTxHwObjectFirstUsed,&#160;<br/>
logTxHwObjectFirstUnused);&#160;<br/>
<b>5.2.9&#160;&#160;Cancellation of a Transmission&#160;<br/></b>There are several ways to cancel a requested transmission. &#160;<br/>
<b>5.2.9.1&#160;</b><br/>
<b>Cancel a Transmission via CanInit&#160;</b><br/>
CanInit initializes the CAN&#160;controller hardware and can therefore be used to cancel any&#160;<br/>current transmission. (see&#160;<a href="TechnicalReference_CANDrivers.html#27">Re-Initialization of the CAN Controller). Some cont</a>rollers do not&#160;<br/>stop their transmission immediately,&#160;so it is&#160;possible that the Cancellation via CanInit()&#160;<br/>could lead to an errorframe on the bus.&#160;<br/>
<b>5.2.9.2&#160;</b><br/>
<b>Cancel a Transmission via CanCancelTransmit or&#160;CanCancelMsgTransmit&#160;</b><br/>
Both functions work the same way,&#160;except&#160;that CanCancelTransmit cancels&#160;a transmission&#160;<br/>initiated via CanTransmit and CanCancelMsgTransmit cancels a transmission initiated via&#160;<br/>CanMsgTransmit.&#160;<br/>The call of the confirmation function or the setting of the&#160;confirmation flag&#160;are suppressed,&#160;<br/>if this message is already in the transmit buffer of the CAN Controller. If the transmit queue&#160;<br/>is enabled, a pending transmit request in the queue is canceled. &#160;<br/>These functions also&#160;delete messages in the&#160;hardware transmit buffer if configured. But&#160;<br/>this feature is strongly dependent of the hardware. Some CAN Driver / CAN Controller&#160;<br/>require the call of CanRxTask() / CanTxTask() to be able to continue.&#160;<br/>Using the cancel functions out of the&#160;Tx&#160;observe functionality (see above) the handle for&#160;<br/>the functions must be obtained via the functi<a href="TechnicalReference_CANDrivers.html#114">on&#160;CanTxGetActHandle(CanObjectHandle&#160;<br/></a>logTxHwObject).&#160;The return code decides&#160;whether it was a CanTransmit or a&#160;<br/>CanMsgTransmit which causes a&#160;<a href="TechnicalReference_CANDrivers.html#101">CanCancelTransmit or a&#160;CanCancelMsgTransmit.&#160;<br/></a>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
41&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=42></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-42_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
CanTransmitHandle Hdl;&#160;<br/>
Hdl = CanTxGetActHandle(logTxHwObject);&#160;<br/>
&#160;<br/>
if(Hdl == kCanBufferMsgTransmit)&#160;<br/>
{&#160;<br/>
&#160; CanCancelMsgTransmit(Hdl);&#160;<br/>
}&#160;<br/>
else if(Hdl &lt; kCanBufferMsgTransmit)&#160;<br/>
{&#160;<br/>
&#160; CanCancelTransmit(Hdl);&#160;<br/>
}&#160;<br/>
else if(Hdl &gt; kCanBufferMsgTransmit)&#160;<br/>
{&#160;<br/>
&#160; /* The Tx request was confirmed or cancelled, or no Tx request is pending. */&#160;<br/>
}&#160;<br/>&#160;<br/>
<b>5.2.9.3&#160;</b><br/>
<b>Notification about Cancellation of a message&#160;</b><br/>
The application can be notified each time the transmit request or the pending confirmation&#160;<br/>is cancel. &#160;That means either the message&#160;based confirmation (flag or function) or the&#160;<br/>cancel notification will be executed after&#160;successful call of CanTransmit() or&#160;<br/>CanMsgTransmit(). &#160;<br/>To&#160;enable the notification the flag “CAN Cancel&#160;Notification” in the Generation&#160;Tool must&#160;<br/>be selected. If this flag is set a Callback&#160;function informs the&#160;Application about that a&#160;<br/>message was cancelled.&#160;ApplCanCancelNotification() will be called if the&#160;transmit request&#160;<br/>was initiated via CanTransmit(),&#160;ApplCanMsgCancelNotification() will be&#160;called if the&#160;<br/>request was set up via CanMsgTransmit().&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
42&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=43></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-43_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-43_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>5.2.10&#160;&#160;Overview&#160;of Transmit Objects&#160;<br/></b>The table shows the naming for different RI versions. Some of the features of the column&#160;<br/>are hardware dependent.&#160;<br/>
<b>Names before RI 1.4&#160;</b><br/>
<b>Names RI 1.4&#160;</b><br/>
<b>Names RI 1.5 and later&#160;</b><br/>
Transmit Object&#160;<br/>
Normal&#160;Transmit Object&#160;<br/>
Normal&#160;Transmit Object&#160;<br/>
Direct&#160;Transmit Objects&#160;<br/>
Full CAN&#160;Transmit Object&#160;<br/>
Full CAN&#160;Transmit Object&#160;<br/>
--- Direct&#160;<br/>
Transmit&#160;<br/>
Objects&#160;<br/>
---&#160;<br/>
Dynamic Transmit&#160;Objects&#160;<br/>
Dynamic Transmit&#160;Objects&#160;<br/>
Dynamic Transmit&#160;Objects&#160;<br/>
Low Level Message&#160;Transmit&#160;&#160;Low Level Message&#160;Transmit&#160;<br/>
Low Level Message&#160;Transmit&#160;<br/>
&#160;<br/>
<b>5.2.11&#160;&#160;Normal Transmit Object&#160;<br/></b>A&#160;Normal&#160;Transmit Object is the hardware transmit object supported by all CAN Drivers.&#160;All&#160;<br/>transmit messages that are not assigned to&#160;a Full CAN&#160;Transmit Object will be transmitted&#160;<br/>via this Normal&#160;Transmit Object.&#160;The transmit queue works only&#160;on this object and the&#160;<br/>Dynamic&#160;Transmit Objects can only be transmitted via this object, too.&#160;<br/><b>5.2.12&#160;&#160;Full CAN Transmit Objects&#160;<br/></b>Each Full CAN&#160;Transmit Object has its own&#160;Hardware&#160;Transmit Object.&#160;This means a Full&#160;<br/>CAN&#160;Transmit Object holds exactly one CAN message with a specific CAN identifier and&#160;<br/>DLC.&#160;These CAN messages are statically assigned by the Generation&#160;Tool. Changes&#160;of&#160;<br/>this reference during run time are not possible.&#160;There are two reasons for Full CAN&#160;<br/>Transmit Object:&#160;<br/>1.&#160;&#160;The associated CAN message object is never occupied by another transmit request&#160;<br/>2.&#160;&#160;There is no need to copy the CAN identifier and the DLC.&#160;The message data can also&#160;<br/>
be stored directly in the CAN Controller and the transmit request can be initiated&#160;<br/>directly. &#160;<br/>
<b>Info</b>&#160;<br/>Full CAN objects&#160;are sent via CanTransmit() function.&#160;<br/>
&#160;<br/>
&#160;<br/><b>5.2.13&#160;&#160;Dynamic Transmit Objects&#160;<br/></b>The CAN Driver supports the transmission of CAN messages with dynamic&#160;parameters.&#160;<br/>These messages must&#160;not be specified in the&#160;CAN database.&#160;This feature can be used in&#160;<br/>gateways, for example.&#160;<br/>These dynamic objects can consist of mixed dynamic and static parts. CAN identifier,&#160;DLC&#160;<br/>and data pointer can be selected separately as&#160;dynamic or static.&#160;The selection is common&#160;<br/>for all dynamic objects. Pretransmit functions&#160;and confirmation functions are always static.&#160;<br/>The CAN identifier priority for&#160;dynamic objects&#160;is lost if a&#160;transmit queue is used. Dynamic&#160;<br/>objects have a higher internal priority than static objects, independent&#160;of their current CAN&#160;<br/>identifier.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
43&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=44></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-44_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
Before the&#160;Application can use a dynamic&#160;object, the&#160;Application needs to reserve one.&#160;<br/>This can be done by the following service function:&#160;<br/>CanTransmitHandle CanGetDynTxObj( CanTransmitHandle txHandle);&#160;<br/>&#160;<br/>The next step is to set all dynamic parameters of this object.&#160;This will be&#160;done by calling&#160;<br/>the service functions:&#160;<br/>void CanDynTxObjSetId &#160; &#160; &#160; &#160; &#160; &#160; ( ... );&#160;<br/>void CanDynTxObjSetExtId &#160; &#160; &#160; &#160; &#160;( ... );&#160;<br/>void CanDynTxObjSetDlc &#160; &#160; &#160; &#160; &#160; &#160;( ... );&#160;<br/>void CanDynTxObjSetDataPtr &#160; &#160; &#160; &#160;( ... );&#160;<br/>&#160;<br/>After this, the dynamic object can be transmitted by calling CanTransmit(..) with the handle&#160;<br/>of the dynamic object.&#160;The&#160;Application is allowed to use a dynamic object several times. If&#160;<br/>the&#160;Application doesn’t need the dynamic&#160;objects any more,&#160;it can be&#160;released by the&#160;<br/>service function&#160;<br/>vuint8 CanReleaseDynTxObj( CanTransmitHandle txHandle );&#160;<br/>There are two macros to allow a call of CanReleaseDynTxObj() in a confirmation function.&#160;<br/>Both macros are only&#160;allowed to be called in the context of the user confirmation function&#160;<br/>of this Dynamic Object.&#160;<br/>
<b>CanConfirmStart(txHand&#160;</b>This macro enables release of dynamic objects&#160;in a confirmation&#160;<br/><b>le)&#160;</b><br/>
function.&#160;<br/>txHandle has to be equal to the parameter of the confirmation&#160;<br/>function.&#160;<br/>
<b>CanConfirmEnd()&#160;</b><br/>
This macro restores security mechanism for release of dynamic&#160;<br/>Objects.&#160;<br/>
&#160;<br/>Example:&#160;<br/>
void Confirm_ResDynTxObj ( CanTransmitHandle txHandle )&#160;<br/>{&#160;<br/>
&#160; …&#160;<br/>&#160; CanConfirmStart(txHandle);&#160;<br/>&#160; if (CanReleaseDynTxObj( txHandle )== kCanDynNotReleased)&#160;<br/>
&#160; { //error handling }&#160;<br/>&#160; CanConfirmEnd();&#160;<br/>
&#160; …&#160;<br/>}&#160;<br/>
&#160;<br/>If a dynamic object is&#160;used several times, the&#160;Application has&#160;to take care&#160;to use the&#160;<br/>confirmation flag / function. &#160;<br/>The maximum number of Dynamic&#160;Transmit Objects must be defined&#160;statically in the&#160;<br/>Generation Tool.&#160;<br/>Messages of dynamic transmit objects can not be sent via Full CAN&#160;Transmit Objects.&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
44&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=45></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-45_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>5.2.14&#160;&#160;Priority&#160;of Transmit Objects&#160;<br/></b>&#160;<br/>
<b>Message&#160;ID</b><br/>
<b>Priority</b><br/>
Low&#160;0<br/>
Full&#160;CAN&#160;Transmit&#160;Objects<br/>
High&#160;n<br/>
Normal&#160;Transmit&#160;Object<br/>
Low&#160;Level&#160;Transmit&#160;Object<br/>
(High End)<br/>
&#160;<br/>
Figure 5-9&#160;&#160;Priority&#160;of&#160;Transmit Objects&#160;<br/>
&#160;&#160;<br/>&#160;<br/>
Full CAN Objects have the highest priority and they are sorted according to their ID.&#160;This is&#160;<br/>automatically done by the Generation&#160;Tool.&#160;<br/>There is only one Normal&#160;Transmit Object with&#160;a lower priority than&#160;the Full CAN Objects.&#160;<br/>Dynamic&#160;Transmit Objects are transmitted via the Normal&#160;Transmit Object.&#160;<br/>The Low Level Message&#160;Transmit Object has the lowest priority. &#160;<br/>This priority is only valid, if the hardware&#160;is not able to arbitrate according the IDs.&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
45&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=46></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-46_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>5.3&#160;</b><br/>
<b>Reception&#160;</b><br/>
<b>5.3.1&#160;&#160;Detailed Functional Description&#160;</b><br/>
CAN Message<br/>
<b>Receive</b><br/>
No&#160;Action<br/>
<b>Message&#160;not&#160;accepted</b><br/>
<b>Hardware</b><br/>
<b>Acceptance&#160;Filter</b><br/>
<b>Message&#160;accepted</b><br/>
Interrupt&#160;Request<br/>
<b>No</b><br/>
<b>Interrupt&#160;Enabled</b><br/>
is&#160;stored<br/>
<b>Yes</b><br/>
<b>Enter</b><br/>
<b>Receive&#160;Interrupt</b><br/>
<b>Use</b><br/>
<b>Use&#160;Receive&#160;Function</b><br/>
Receive&#160;Function<br/>
<b>Use&#160;not</b><br/>
<b>No</b><br/>
kCanCopyData<br/>
<b>Yes</b><br/>
<b>Use</b><br/>
<b>Range</b><br/>
<b>Filter</b><br/>
<b>No</b><br/>
Match?<br/>
<b>Yes</b><br/>
Range/Component<br/>
PreCopy&#160;Function<br/>
<b>kCanNoCopyData</b><br/>
<b>Use</b><br/>
<b>UseMessage</b><br/>
<b>Message&#160;not&#160;matched</b><br/>
<b>Software</b><br/>
Message&#160;Not Matched<br/>
<b>NotMatched</b><br/>
<b>Acceptance&#160;Filter</b><br/>
<b>Message&#160;accepted</b><br/>
<b>Use&#160;not</b><br/>
<b>Use</b><br/>
<b>Check DLC</b><br/>
<b>Use&#160;not</b><br/>
<b>Use</b><br/>
<b>Failed</b><br/>
DLC Failed<br/>
<b>UseDlcFailed</b><br/>
DLC Check<br/>
<b>Ok</b><br/>
<b>Use&#160;not</b><br/>
<b>Use</b><br/>
<b>Use&#160;Generic&#160;Precopy</b><br/>
Generic<br/>
<b>Use&#160;not</b><br/>
PreCopy&#160;Function<br/>
<b>No</b><br/>
kCanCopyData<br/>
<b>Yes</b><br/>
<b>Defined</b><br/>
<b>Precopy&#160;defined</b><br/>
<b>Not&#160;defined</b><br/>
Precopy&#160;Function<br/>
<b>No</b><br/>
kCanCopyData<br/>
<b>Switches&#160;in&#160;the&#160;Generation&#160;Tool&#160;for<br/>optional&#160;features&#160;of&#160;the&#160;CAN&#160;Driver</b><br/>
<b>Yes</b><br/>
<b>Decisions&#160;in&#160;the&#160;code,&#160;if&#160;the&#160;feature&#160;is&#160;selected.</b><br/>
<b>Optional&#160;or&#160;mandatory&#160;functions&#160;of&#160;the&#160;CAN&#160;Driver</b><br/>
<b>Copy&#160;Data</b><br/>
<b>Mandatory path&#160;through&#160;the&#160;CAN&#160;Driver</b><br/>
<b>Defined</b><br/>
<b>Indication&#160;Flag&#160;</b><br/>
<b>Optional&#160;path&#160;through&#160;the&#160;CAN&#160;Driver</b><br/>
<b>defined</b><br/>
<b>Direction&#160;of&#160;work&#160;flow</b><br/>
Indication&#160;Flag<br/>
<b>Not&#160;defined</b><br/>
<b>Defined</b><br/>
<b>Indication&#160;Function</b><br/>
<b>defined</b><br/>
Indication&#160;Function<br/>
<b>Not&#160;defined</b><br/>
<b>Leave</b><br/>
<b>Receive&#160;Interrupt</b><br/>
&#160;<br/>
end<br/>
&#160;<br/>
Figure 5-10&#160;Reception of a CAN messages&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
46&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=47></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-47_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;&#160;<br/>
CAN messages are received asynchronously and without any explicit service function call.&#160;<br/>Normally, the CAN Driver is informed by the&#160;CAN&#160;Controller via&#160;interrupt&#160;of the reception of&#160;<br/>a CAN message.&#160;That means the received&#160;CAN identifier has passed the hardware&#160;<br/>acceptance filtering of the CAN Controller and&#160;the entire message is&#160;stored in a receive&#160;<br/>register. In case of a Basic CAN object, the message has to&#160;be retrieved and processed as&#160;<br/>fast as possible. If a feature is only in Basic CAN or Full CAN available if is mentioned in&#160;<br/>the text.&#160;<br/>The gray decision symbols branch to features that can be removed&#160;from the CAN Driver&#160;<br/>using the configuration options&#160;of the Generation&#160;Tool.&#160;Disabled features cannot be used&#160;<br/>for any messages.&#160;The code for these features&#160;is completely removed. If a feature is&#160;<br/>enabled, it can be determined for each message whether it is used or not.&#160;<br/>The receive callback&#160;function&#160;ApplCanMsgReceived(..) is called on every reception of a&#160;<br/>CAN message after the hardware acceptance filter is passed. Within this&#160;function the&#160;<br/>Application may preprocess the received message in any way&#160;(ECU specific dynamic&#160;<br/>filtering mechanisms, gateway functionality,&#160;etc...). If the&#160;function returns kCanCopyData,&#160;<br/>the CAN Driver continues the processing.&#160;If the function returns kCanNoCopyData, the&#160;<br/>CAN Driver&#160;terminates the message reception.&#160;<br/>During the software acceptance filtering (only&#160;available for Basic CAN)&#160;the CAN Driver first&#160;<br/>checks for range specific identifiers. For the&#160;range specific identifiers special precopy&#160;<br/>functions may be defined.&#160;Afterwards the single CAN identifier based filtering is performed.&#160;<br/>The CAN Drivers support different mechanisms like linear search, hash search or an index&#160;<br/>search. In any case the filtering capabilities of the CAN Controller are used.&#160;The&#160;<br/>corresponding receive object has to be determined by comparing the generated CAN&#160;<br/>identifier in the data description tables with&#160;the received CAN identifier in the Basic CAN&#160;<br/>object.&#160;<br/>If the result of the software acceptance filtering is negative (only done for a Basic CAN&#160;<br/>object), the callback&#160;function&#160;ApplCanMsgNotMatched() is called.&#160;Then the receive&#160;<br/>interrupt is terminated immediately after&#160;the CAN Controller hardware is serviced.&#160;<br/>After a CAN identifier match, the DLC will be&#160;checked. In case of a failed DLC check there&#160;<br/>can be a configured callback function to notify the application. &#160;<br/>In case of a successful DLC check the generic&#160;precopy function is called (if configured).&#160;<br/>Generic precopy means that a common function named&#160;ApplCanGenericPrecopy() is&#160;<br/>called for all identifiers. If this function&#160;returns kCanNoCopyData the&#160;CAN Driver&#160;<br/>terminates further processing. If this function returns kCanCopyData, the CAN Driver&#160;<br/>continues to work on the message received. &#160;<br/>After the generic precopy if configured a precopy function separate for each message&#160;<br/>according to the entry in the description data is&#160;called.&#160;Within this user specific function&#160;<br/>any processing of the message received may occur (complete processing of&#160;a message or&#160;<br/>special storage methods like ring buffers, FIFOs, ...). If the precopy function returns&#160;<br/>kCanNoCopyData the CAN Driver terminates further processing.&#160;If the precopy function&#160;<br/>returns kCanCopyData, the CAN Driver continues to work on the message received.&#160;<br/>In the next&#160;step the data is copied to the global data buffer.&#160;The CAN Driver copies only&#160;<br/>the number of bytes from the CAN receive buffer that is stored in the array CanRxDataLen.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
47&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=48></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-48_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-48_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
Then the indication actions defined for this&#160;message are performed.&#160;This means the&#160;<br/>indication flag is&#160;set and/or the indication function is called.&#160;The&#160;Application has&#160;to reset&#160;<br/>the indication flag before or&#160;after data processing.&#160;<br/>In the following sections the processing steps are described using sequence charts.&#160;The&#160;<br/>vertical directed lines&#160;within these diagrams represent program objects&#160;like interrupt&#160;<br/>routines, functions or data objects.&#160;The horizontal lines represent&#160;program flow or data&#160;<br/>access within the program. Within the sequence charts below flow control and program&#160;<br/>instances are described using thick lines, data&#160;access is described using thin lines.&#160;Time&#160;<br/>flows from the top of a chart downwards&#160;so that sequence „1“ is performed before&#160;<br/>sequence „2“.&#160;The description of the sequence charts&#160;is given in the tables following the&#160;<br/>charts. &#160;<br/>&#160;<br/>
CAN Data<br/>
RX Interrupt&#160;Driver<br/>
Global Data&#160;Indication<br/>
ApplCan-<br/>
CAN<br/>
Precopy<br/>
Indication<br/>
Application<br/>
Buffer<br/>
Routine<br/>
Parameters<br/>
Buffer<br/>
Flag<br/>
MsgReceived<br/>
1<br/>
2<br/>3<br/>
4<br/>
5<br/>
6<br/>
7<br/>
8<br/>
&#160;<br/>
Figure 5-11&#160;Reception of a CAN message:&#160;The data is&#160;completely&#160;processed in the precopy function&#160;<br/>
<b>No &#160;&#160;Description&#160;<br/></b>1&#160;<br/>
A&#160;CAN&#160;message has passed the hardware acceptance filtering, the receive interrupt&#160;<br/>routine is triggered&#160;<br/>
2&#160;<br/>
If configured, the&#160;ApplCanMsgReceived() callback function&#160;is&#160;called&#160;<br/>
3&#160;<br/>
The&#160;ApplCanMsgReceived() callback function returns kCanCopyData&#160;<br/>
4&#160;<br/>
Software acceptance filtering and identification&#160;of the received CAN&#160;message&#160;<br/>
5&#160;<br/>
If configured, the precopy function is&#160;called.&#160;The&#160;Application is able to take control over&#160;<br/>the receive process immediately after the software acceptance filtering&#160;and direct access&#160;<br/>to the CAN&#160;Controller receive register is possible.&#160;<br/>
6&#160;<br/>
Within the precopy function the data in the CAN Controller hardware registers are read&#160;<br/>and completely processed.&#160;<br/>
7&#160;<br/>
The precopy function returns kCanNoCopyData. No further processing (copying of data,&#160;<br/>indication&#160;actions) occurs in the CAN Driver&#160;<br/>
8&#160;<br/>
After servicing the CAN&#160;Controller hardware (the receive registers of the CAN Controller&#160;<br/>are released), the receive interrupt routine is&#160;left.&#160;<br/>
&#160;<br/>
<b>Info</b>&#160;<br/>1. If the&#160;ApplCanMsgReceived() callback function&#160;returns kCanNoCopyData, the&#160;<br/>
&#160;&#160;received message is ignored.&#160;This means no further software filtering, no&#160;precopy, no&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
48&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=49></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-49_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
copying of data and no indication actions are performed.&#160;<br/>&#160;<br/>2. If the precopy function returns kCanNoCopyData, no copying of data and no&#160;<br/>indication&#160;actions are performed.&#160;<br/>
&#160;<br/>
RX<br/>
CAN Data<br/>
Driver<br/>
Indication<br/>
ApplCanMsg<br/>
Interrupt<br/>
Global&#160;Data<br/>
CAN<br/>
Buffer<br/>
Parameters<br/>
Flag<br/>
Precopy<br/>
Indication<br/>
Receive<br/>
Application<br/>
Routine<br/>
Buffer<br/>
1<br/>
2<br/>3<br/>
4<br/>
5<br/>6<br/>
7<br/>
8<br/>
9<br/>
10<br/>
11<br/>
&#160;<br/>
Figure 5-12&#160;Reception of a CAN message:&#160;The CAN&#160;Driver internal copying mechanism is used&#160;<br/>
&#160;<br/>
<b>No&#160;&#160;Description&#160;</b><br/>
1&#160;<br/>
A&#160;CAN message has passed the hardware acceptance filtering, the receive interrupt&#160;<br/>routine is triggered&#160;<br/>
2&#160;<br/>
If configured, the&#160;ApplCanMsgReceived(..) callback function is called&#160;<br/>
3&#160;<br/>
The&#160;ApplCanMsgReceived(..) callback function returns kCanCopyData&#160;<br/>
4&#160;<br/>
Software acceptance filtering and identification&#160;of the received CAN&#160;message&#160;<br/>
5&#160;<br/>
If configured, the precopy function is called.&#160;The&#160;Application is able&#160;to take control&#160;<br/>over the receive process immediately after the&#160;software acceptance filtering and the&#160;<br/>direct access to the CAN Controller receive register is possible.&#160;<br/>
6&#160;<br/>
The precopy function returns kCanCopyData.&#160;The CAN Driver continues its normal&#160;<br/>processing.&#160;<br/>
7&#160;<br/>
The received data are copied from the CAN&#160;Controller receive register to the global&#160;<br/>data buffer associated to the CAN&#160;message&#160;<br/>
8&#160;<br/>
If configured, the indication flag is&#160;set (must be reset by the&#160;Application)&#160;<br/>
9&#160;<br/>
If configured, the indication function is called; any user&#160;actions can&#160;be performed&#160;<br/>within this user specific function&#160;<br/>
10&#160;&#160;Indication function returns to the receive interrupt routine&#160;<br/>11&#160;&#160;Receive interrupt routine&#160;is left&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
49&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=50></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-50_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>5.3.2&#160;&#160;Receive Function&#160;<br/></b>Before the software filtering is done,&#160;the&#160;Application optionally may use the&#160;<br/>ApplCanMsgReceived() callback function called by&#160;the CAN Driver. Within this function&#160;the&#160;<br/>Application can define whether to&#160;process the message received or not.&#160;<br/>
<b>5.3.3&#160;&#160;Range-Specific Precopy&#160;Functions&#160;<br/></b>The CAN Driver's receive path&#160;can be configured to filter&#160;special identifier ranges and&#160;<br/>associated precopy functions will&#160;be called directly. Up to four ranges are supported by the&#160;<br/>CAN Driver.&#160;The ranges must be defined by&#160;a start address (e.g. 0x400) and a mask (e.g.&#160;<br/>0x1F, i.e. if&#160;a bit is&#160;set it means&#160;don’t care)&#160;and leads to a specific&#160;range (in our example it&#160;<br/>is from 0x400 to 0x 41F).&#160;The ranges are typically predefined by the Generation&#160;Tool for&#160;<br/>special functions. If these are not used&#160;they are available&#160;for the application:&#160;<br/>&#160;<br/>Range 0&#160;&#160;Network&#160;<br/>
If the usage&#160;of a Network Management is configured&#160;<br/>
Management&#160;<br/>Application&#160;<br/>
Application&#160;specific. May be used by the&#160;Application&#160;<br/>
Range 1&#160;&#160;Diagnostics&#160;<br/>
If extended addressing&#160;mode of the&#160;Transport Protocol is configured&#160;<br/>
Application&#160;&#160;<br/>
Application&#160;specific. May be used by the&#160;Application&#160;<br/>
Range 2&#160;&#160;Special usage&#160;<br/>
Car manufacturer specific&#160;<br/>
Application&#160;&#160;<br/>
Application&#160;specific. May be used by the&#160;Application&#160;<br/>
Range 3&#160;&#160;Application&#160;<br/>
Application&#160;specific. May be used by the&#160;Application&#160;<br/>
&#160;<br/>&#160;<br/>Special capabilities of&#160;some CAN Controllers&#160;with several hardware&#160;acceptance filters may&#160;<br/>also be used for the range specific filtering.&#160;<br/>
<b>5.3.4&#160;&#160;Identifier Search Algorithms&#160;<br/></b>The following software filtering mechanisms&#160;are supported:&#160;All mechanisms but linear are&#160;<br/>optional in the different hardware implementations.&#160;<br/>Linear&#160;Search:&#160;<br/>
The identifier of the incoming&#160;message is compared to all CAN&#160;<br/>identifiers in a table (if&#160;found, the search stops).&#160;The average search&#160;<br/>time is proportional to the number of receive messages.&#160;<br/>
Hash&#160;Search:&#160;<br/>
An optimized search algorithm&#160;with a small known&#160;number of search&#160;<br/>steps.&#160;The Generation tool calculates an optimized search table and&#160;<br/>some parameters used at run time.&#160;The number of search steps can&#160;<br/>be defined by the user.&#160;The less search&#160;steps the bigger the resulting&#160;<br/>hash tables.&#160;<br/>
Table&#160;Search:&#160;&#160;<br/>
This is a kind of hash mechanism.&#160;The last three bits of a CAN&#160;<br/>identifier are used as a selector for the search table.&#160;There are 8&#160;<br/>different tables for each of the&#160;hardware acceptance filters in the&#160;<br/>CAN Controller.&#160;Within the table&#160;a linear search is implemented.&#160;<br/>
Index&#160;Search:&#160;<br/>
A&#160;table with 2048 entries (one entry for each identifier) is used for&#160;<br/>software filtering. Index Search is&#160;used for Standard ID only.&#160;<br/>
&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
50&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=51></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-51_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>5.3.5&#160;&#160;DLC check&#160;<br/></b>The Data&#160;Length Code of a received message&#160;will be compared to the length of the&#160;<br/>Application receive buffer of this message. If the DLC is&#160;smaller than the&#160;Application&#160;<br/>receive buffer,&#160;data will not be copied.&#160;The&#160;length of the received message&#160;buffer is the&#160;<br/>maximum length which is necessary to treat all signals for this ECU.&#160;To&#160;inform the&#160;<br/><a href="TechnicalReference_CANDrivers.html#117">application the callback function&#160;ApplCanMsgDlcFailed</a>&#160;will be&#160;called.&#160;The reception&#160;<br/>process will be terminated afterwards. &#160;<br/>Depending on the OEM the length&#160;of the received data bytes can&#160;be different&#160;at run time. It&#160;<br/>is also possible to compare the length of&#160;the received message with a minimum length&#160;<br/>which can be smaller than the&#160;Application receive buffer.&#160;<br/>The behavior can be configured via generation tool and the database attribute&#160;<br/>GenMsgMinAcceptLength.&#160;<br/>
<b>5.3.6&#160;&#160;Data Copy&#160;Mechanism&#160;<br/></b>There are two different methods&#160;for the&#160;Application to access the data received from the&#160;<br/>CAN bus.&#160;<br/>
<b>5.3.6.1&#160;</b><br/>
<b>Internal&#160;</b><br/>
Using the internal data copy mechanism, the&#160;CAN Driver copies&#160;the contents of the CAN&#160;<br/>controller receive registers to a global data&#160;buffer associated to the receive message.&#160;The&#160;<br/>Application can access the signal values in&#160;the message specific data buffer using access&#160;<br/>macros or functions.&#160;The access macros&#160;are generated by the Generation&#160;Tool using&#160;<br/>information in the CAN database.&#160;The signal access macros always&#160;return&#160;<b>unsigned&#160;<br/>values</b>.&#160;<br/>The&#160;Application itself is responsible for the data consistency of signals in a CAN message&#160;<br/>which cannot be handled in atomic operations because the receive buffer may be&#160;<br/>overwritten asynchronously by a CAN receive&#160;interrupt. Different mechanisms can be used&#160;<br/>to guarantee data consistency:&#160;<br/>&#160;<br/>1.&#160;&#160;Disabling of the CAN receive interrupt.&#160;<br/>
2.&#160;&#160;Read the receive signal. Compare the signal value with the signal in the hardware&#160;<br/>
buffer.&#160;Repeat the read operation if the values differ.&#160;<br/>
3.&#160;&#160;Usage of the message based indication flag:&#160;<br/>
3.1&#160;&#160;Clear the message indication flag&#160;<br/>
3.2&#160;&#160;Read the data (one or more signals of a message)&#160;<br/>
3.3&#160;&#160;Check the message indication flag: If set then return to 3.1&#160;<br/>
&#160;<br/>Depending on the OEM the length&#160;of the received data bytes can be different at run time.&#160;<br/>Instead of copying all needed&#160;bytes (equal to the length of&#160;the global data buffer&#160;<br/>associated to the receive message) the CAN Driver can be configured to copy the number&#160;<br/>of received bytes. In case&#160;the number of received bytes exceed the length of the data&#160;<br/>buffer,&#160;the CAN Driver&#160;takes care to copy&#160;at maximum the length of the data&#160;buffer.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
51&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=52></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-52_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-52_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Info</b>&#160;<br/>The signal access macros are not affected.&#160;The&#160;application&#160;has to make sure, that it&#160;<br/>
&#160;&#160;does not access data via access macros that is not copied&#160;now because of a change of&#160;<br/>
the data length.&#160;<br/>
&#160;<br/><b>5.3.6.2&#160;</b><br/>
<b>User-defined Precopy&#160;Functions&#160;</b><br/>
The user can define specific precopy functions for each receive object in the Generation&#160;<br/>Tool. If defined, the CAN Driver calls this&#160;user-specific function immediately after the&#160;<br/>software filtering. Within this precopy function the&#160;Application can access the data&#160;directly&#160;<br/>in the CAN Controller receive&#160;registers.&#160;The precopy function&#160;indicates this to the CAN&#160;<br/>Driver by the appropriate return code kCanNoCopyData&#160;and the further&#160;processing will be&#160;<br/>terminated immediately.&#160;On the other side the&#160;CAN Driver can be forced to continue with&#160;<br/>normal processing of the message after the precopy function by using the return code&#160;<br/>kCanCopyData.&#160;<br/>The parameter of the precopy function is a pointer to a structure.&#160;This structure includes&#160;<br/>the handle of the received message and&#160;a pointer to the received data.&#160;<br/>A&#160;separate user-specific function may be defined for each receive message. But it is also&#160;<br/>possible to use the same function for different messages.&#160;<br/>If no such function is defined,&#160;a NULL&#160;pointer is written to&#160;the corresponding description&#160;<br/>data by the Generation&#160;Tool.&#160;<br/>The user has to note that these user-specific&#160;functions&#160;are called in the receive interrupt.&#160;<br/>Only short receive actions should be done to&#160;avoid negative influence on the&#160;Application&#160;<br/>task by a long interrupt disable time.&#160;<br/>The precopy mechanism&#160;can be used to handle&#160;only a small number of&#160;receive signals in&#160;<br/>an efficient&#160;way,&#160;if there is a CAN receive&#160;message with 8 bytes but the receiving ECU for&#160;<br/>example only needs the 6th bit of the 7th byte.&#160;The standard copy&#160;routine starts always at&#160;<br/>the beginning of the receive data buffer and copies&#160;all data up to the last byte with&#160;<br/>significant signals for the dedicated node (the 7th byte in the example above).&#160;This results&#160;<br/>in some overhead in RAM and run time, particularly if these signals are mapped in the rear&#160;<br/>part of the message.&#160;The precopy function can therefore be used to implement a user&#160;<br/>specific copy routine and has to return the return code kCanNoCopyData. &#160;<br/>Another example for a precopy&#160;function is a compare mechanism between the CAN&#160;<br/>Controller receive register and&#160;the global&#160;Application buffer.&#160;If both are matching, data&#160;<br/>have not to be copied and the indication is&#160;not necessary, i.e. kCanNoCopyData is&#160;<br/>returned. Otherwise the return code kCanCopyData&#160;leads&#160;to the standard copy&#160;<br/>mechanism&#160;of the CAN Driver&#160;and notification to the&#160;Application using indications.&#160;<br/>The precopy function can also be used to implement receive queues (FIFO, FILO or ring&#160;<br/>buffer).&#160;<br/>
<b>5.3.7&#160;&#160;Notification&#160;<br/></b>After the reception of&#160;a message from the CAN bus and the successful hardware and&#160;<br/>software acceptance filtering, the&#160;Application can be notified by different indication&#160;<br/>mechanisms:&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
52&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=53></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-53_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-53_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>5.3.7.1&#160;</b><br/>
<b>Data Interface (Indication Flag)&#160;</b><br/>
If an indication flag is used, this message related flag is set by the CAN Driver, if the&#160;<br/>associated CAN message was received.&#160;This is&#160;done in the scope of the receive interrupt.&#160;<br/>The flag must be cleared by the&#160;Application.&#160;<br/>&#160;<br/>
<b>Caution&#160;<br/></b>Interrupts have to be disabled during reset of the indication&#160;flags because of the read-<br/>
&#160;&#160;modify-write&#160;conflict&#160;if this operation is interrupted&#160;by a CAN receive interrupt routine.&#160;<br/>
This can result in the loss of events.&#160;<br/>
&#160;<br/><b>5.3.7.2&#160;</b><br/>
<b>Functional Interface (Indication Function)&#160;</b><br/>
In parallel or instead of&#160;the data interface a functional interface can be configured, i.e. a&#160;<br/>user-specific function is called if the associated CAN message was received.&#160;This is also&#160;<br/>done in the scope of the receive interrupt and therefore special care&#160;on the run time of this&#160;<br/>user-specific function has to be taken.&#160;A&#160;special notification mechanism for the&#160;Application&#160;<br/>can be implemented in such an indication function.&#160;<br/>
<b>5.3.8&#160;&#160;Not-Matched Function&#160;<br/></b>If a CAN message has passed the hardware acceptance filtering but is rejected by the&#160;<br/>software acceptance filtering (in case of a&#160;Basic CAN receive object) a special callback&#160;<br/>function will be called (if configured):&#160;<br/>void ApplCanMsgNotMatched( ... );&#160;<br/>&#160;<br/><b>5.3.9&#160;&#160;Overrun Handling&#160;<br/></b>An Overrun appears if a CAN message is lost&#160;in the Basic CAN receive object, because&#160;<br/>the other was not treated yet entirely.&#160;There&#160;are two possibilities how a message could be&#160;<br/>lost. In some cases the old message was overwritten with a new message. In other cases&#160;<br/>a new message couldn’t be received.&#160;<br/>If enabled, the&#160;Application has to provide an overrun callback function:&#160;<br/>void ApplCanOverrun( void );&#160;<br/>&#160;<br/>The overrun handling itself is done by the CAN Driver.&#160;<br/>
<b>5.3.10&#160;&#160;Full CAN Overrun Handling&#160;<br/></b>A&#160;Full CAN Overrun appears if&#160;a CAN message is&#160;lost in the Full CAN receive object,&#160;<br/>because the other was not treated yet entirely.&#160;There are two possibilities how a message&#160;<br/>could be lost. In some cases the old message was overwritten with a new message. In&#160;<br/>other cases a new message couldn’t be received.&#160;<br/>If enabled,&#160;the&#160;Application has&#160;to provide an&#160;overrun callback function&#160;for Full CAN&#160;<br/>objects:&#160;<br/>void ApplCanFullCanOverrun( void );&#160;<br/>&#160;<br/>The overrun handling itself is done by the CAN Driver&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
53&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=54></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-54_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-54_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>5.3.11&#160;&#160;Conditional Message Received&#160;<br/></b>The Conditional Message Received function&#160;ApplCanMsgCondReceived() will be&#160;<br/>conditional called for each reception of a&#160;CAN message.&#160;The condition can be set / reset&#160;<br/>and read by application via CanResetMsgReceivedCondition(),&#160;<br/>CanSetMsgReceivedCondition(), and CanGetMsgReceivedCondition().&#160;The condition is&#160;<br/>automatically set by CanInitPowerOn() and CanSleep().&#160;&#160;<br/>&#160;<br/>
<b>5.4&#160;</b><br/>
<b>Bus-Off Handling&#160;</b><br/>
There are several functions provided by&#160;the CAN Driver to handle a BusOff&#160;state of the&#160;<br/>CAN Controller after severe transmit errors.&#160;For some CAN Controllers a re-initialization&#160;<br/>must be done to satisfy the hardware requirements others are changing automatically to&#160;<br/>the 'Error&#160;Active' state after 128 x 11&#160;recessive&#160;bits on the CAN bus&#160;as it is specified in the&#160;<br/>CAN protocol. Nevertheless it is recommended by&#160;most of the customer specific CAN bus&#160;<br/>specifications to re-initialize the CAN Controller in every&#160;case, because the transmit error&#160;<br/>might be caused by a faulty bit in the CAN Controller registers, e.g. bus&#160;timing registers, in&#160;<br/>case of EMC influences.&#160;The following service functions have to be used by&#160;the&#160;<br/>Application to handle a BusOff&#160;error:&#160;<br/>void CanResetBusOffStart( CanInitHandle initObject );&#160;<br/>void CanResetBusOffEnd( CanInitHandle initObject );&#160;<br/>&#160;<br/>Typically an extension (compared to the CAN protocol specific&#160;requirements) of the error&#160;<br/>recovery time for the CAN bus is&#160;implemented.&#160;This is done by switching the CAN Driver's&#160;<br/>transmit path to off using the service function&#160;CanOffline(). Because of recursive calls of&#160;<br/>some CAN Driver service functions, CanResetBusOffStart(..) and CanResetBusOffEnd(..)&#160;<br/>are only allowed to be called in the offline mode of the CAN Driver, i.e. CanOffline() has to&#160;<br/>be called before.&#160;<br/>Typically the Network Management handles BusOff&#160;errors. In such case there are no&#160;<br/>additional activities necessary&#160;by the&#160;Application. If no Network Management is used, the&#160;<br/>Application has to provide a callback function&#160;<br/>void ApplCanBusOff( void );&#160;<br/>&#160;<br/>This callback function is called&#160;by&#160;the CAN Driver&#160;in case of BusOff.&#160;The error handling as&#160;<br/>described above has to be done in this function. CanOnline has to be called outside of this&#160;<br/>function on task level.&#160;<br/>&#160;<br/>
<b>Important&#160;<br/></b>For CAN controller which has autorecovery after&#160;BusOff detection we don’t recommend&#160;<br/>
&#160;&#160;to use the status polling.&#160;If using status polling with autorecovery it could&#160;happen, that&#160;<br/>
the application doesn’t detect a BusOff because&#160;a transmit request was&#160;detected first&#160;<br/>and the application wasn’t informed about the BusOff.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
54&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=55></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-55_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-55_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>5.5&#160;</b><br/>
<b>Sleep Mode&#160;</b><br/>
Some CAN Controllers support a special power-down mode with reduced power&#160;<br/>consumption which is&#160;typically called sleep mode.&#160;This&#160;mode will be entered by the&#160;<br/>following service:&#160;<br/>vuint8 CanSleep( void );&#160;<br/>
<b>Important&#160;<br/></b>Before entering the sleep mode, some hardware specific preconditions&#160;have to be&#160;<br/>
&#160;&#160;ensured, e.g. the CAN Controller transmit registers have to be empty. It&#160;has to be&#160;<br/>
guaranteed, that the following service functions&#160;are called before CanSleep():&#160;<br/>void CanOffline( void );&#160;<br/>void CanResetBusSleep( CanInitHandle initObject );.&#160;<br/>
&#160;<br/>The return to normal mode will be initiated by&#160;an explicit request of the&#160;Application:&#160;<br/>vuint8 CanWakeUp( void );&#160;<br/>&#160;<br/>Sleep mode is not supported by&#160;all CAN Controllers. If not, both related service functions&#160;<br/>are provided to guarantee&#160;a unified service function interface for all CAN Drivers and to&#160;<br/>make the&#160;Application mostly&#160;hardware independent. However,&#160;the functions&#160;itself have no&#160;<br/>effect on the CAN Controller.&#160;<br/>A&#160;subset of CAN Controllers, which are supporting a sleep mode in principle, are able to&#160;<br/>be awakened by any CAN bus activity, i.e. a&#160;dominant&#160;level on the CAN bus.&#160;This wake-up&#160;<br/>by CAN is&#160;an asynchronous event, normally detected by a special wake-up interrupt.&#160;The&#160;<br/>Application&#160;will be notified by the following callback function:&#160;<br/>void ApplCanWakeUp( void );&#160;<br/>&#160;<br/>This callback function has to&#160;be provided by the&#160;Application.&#160;CanWakeUp() doesn't have to&#160;<br/>be called in this case, because the CAN Controller returns to normal mode automatically&#160;<br/>or initiated by the CAN Driver&#160;before this function call. Other&#160;communication related issues&#160;<br/>like the activation of the bus transceiver hardware used or the return to the online mode&#160;<br/>(see CanOnline()) have to be done in this callback function or as a consequence of this&#160;<br/>event.&#160;<br/>If a CAN Controller&#160;doesn't support a wake-up by the CAN bus, other hardware&#160;<br/>substitutions like an external interrupt based&#160;on the CAN Controller's Rx line have to be&#160;<br/>implemented.&#160;<br/>
The application should check the return value of&#160;CanSleep()&#160;and&#160;CanWakeUp()&#160;&#160;in&#160;<br/>every case to get the status&#160;of the CAN Controller.&#160;If&#160;CanSleep()&#160;returns&#160;kCanFailed&#160;<br/>the CAN controller hasn’t entered into sleep mode. If&#160;CanWakeUp()&#160;returns&#160;kCanFailed&#160;<br/>the CAN controller has not woken up.&#160;The application has to&#160;decide how to react on this&#160;<br/>behavior.&#160;&#160;<br/>If sleep mode is not entered,&#160;no CAN wake-up interrupt will&#160;be generated on detection&#160;of&#160;<br/>any message on the CAN bus.&#160;The callback function&#160;ApplCanWakeUp() will not be called&#160;<br/>and as a consequence the bus transceiver will&#160;not be initialized.&#160;This may lead to a&#160;<br/>deadlock.&#160;Therefore it is necessary to call&#160;CanSleep() successfully to build a wake-up&#160;<br/>capable system. &#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
55&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=56></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-56_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
There is a limit<a href="TechnicalReference_CANDrivers.html#89">ation in the access to the&#160;API&#160;in Sleep mode.&#160;<br/></a>&#160;<br/>The implementation of this&#160;functionality is very hardware dependent. See also CAN&#160;<br/>controller specific documentation&#160;TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_sleep].&#160;<br/>
<b>5.6&#160;</b><br/>
<b>Special Features&#160;</b><br/>
<b>5.6.1&#160;&#160;Status&#160;<br/></b>Some internal software states of the CAN Driver&#160;and hardware&#160;states of the CAN&#160;<br/>Controller can be read by the return code of the following service function:&#160;<br/>vuint8 CanGetStatus( void );&#160;<br/>&#160;<br/>In detail this is the following information:&#160;<br/>
&#160;&#160;CAN Controller is in sleep&#160;mode (CanSleep()&#160;was called)&#160;<br/>
&#160;&#160;CAN Controller is in stop mode ( CanStop() was called )&#160;<br/>
&#160;&#160;CAN Driver&#160;transmit path is in offline mode(CanOffline() was called)&#160;<br/>
&#160;&#160;current error states of the CAN Controller (Error-Active, Warning, Error-Passive or Bus-<br/>
Off)&#160;<br/>
Not all of the CAN protocol specific bus states are supported by each CAN Driver. Please&#160;<br/>refer to the CAN Controller related section&#160;of the CAN Driver documentation for details&#160;<br/>TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_status].&#160;<br/>There are special macros to&#160;provide an easier access on the single information in the&#160;<br/>return code.&#160;These macros are true (not equal to&#160;0) if the specific&#160;condition is valid and&#160;<br/>false (equal to 0) if not.&#160;The parameter of this&#160;macros is the status, i.e. the return code of&#160;<br/>CanGetStatus():&#160;<br/>vuint8 CanHwIsOk &#160; &#160; ( vuint8 status );&#160;<br/>vuint8 CanHwIsWarning( vuint8 status );&#160;<br/>vuint8 CanHwIsPassive( vuint8 status );&#160;<br/>vuint8 CanHwIsBusOff ( vuint8 status );&#160;<br/>vuint8 CanHwIsSleep &#160;( vuint8 status );&#160;<br/>vuint8 CanHwIsWakeUp ( vuint8 status );&#160;<br/>vuint8 CanHwIsStop &#160; ( vuint8 status );&#160;<br/>vuint8 CanHwIsStart &#160;( vuint8 status );&#160;<br/>vuint8 CanHwIsOffline( vuint8 status );&#160;<br/>vuint8 CanHwIsOnline ( vuint8 status );&#160;<br/>&#160;<br/>If the hardware status information isn’t used by the&#160;Application this part of the functionality&#160;<br/>can be disabled.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
56&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=57></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-57_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>5.6.2&#160;&#160;Stop Mode&#160;<br/></b>The function CanStop() switches the CAN controller hardware to a state in which the CAN&#160;<br/>controller doesn’t influence the communication of other nodes on the bus. For example no&#160;<br/>hardware acknowledge is given,&#160;messages can’t be transmitted or received. In this state&#160;<br/>the Can controller can’t be activated by activities on the CAN bus. &#160;<br/>The function CanStart() reactivates&#160;the CAN controller hardware again.&#160;<br/>The implementation of this&#160;functionality is very hardware dependent. See also CAN&#160;<br/>controller specific documentation&#160;TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_stop].&#160;<br/>
<b>5.6.3&#160;&#160;Remote Frames&#160;<br/></b>The CAN Driver ignores remote frames&#160;and doesn’t answer on a remote request. &#160;<br/>
<b>5.6.4&#160;&#160;Interrupt Control&#160;<br/></b>The interrupt control of the CAN Driver is done by the service functions&#160;<br/>void CanGlobalInterruptDisable( void );&#160;<br/>void CanGlobalInterruptRestore( void );&#160;<br/>&#160;<br/>These functions have been moved to VstdLib. Only macros for compatibility reasons are&#160;<br/>still provided&#160;in the CAN Driver: &#160;<br/>#define&#160;CanGlobalInterruptDisable &#160; &#160; &#160;VStdSuspendAllInterrupts&#160;<br/>#define&#160;CanGlobalInterruptRestore &#160; &#160; &#160;VStdResumeAllInterrupts&#160;<br/>
&#160;<br/>...more information see in the technical reference of &#160;the VStdLib.&#160;<br/>(TechnicalReference_VstdLib.pdf).&#160;<br/>
<b>5.6.4.1&#160;</b><br/>
<b>Security&#160;Level&#160;</b><br/>
The security levels&#160;can be used to guarantee the data consistency of a complete CAN&#160;<br/>message during the copy process (this is a must, because the CAN Driver does not know&#160;<br/>anything about the signal structure of the message) and the access to the notification flags&#160;<br/>(indication and confirmation). During these operations&#160;the interrupt lock time is as short as&#160;<br/>possible. Depending on the program scope with access&#160;to CAN message signals,&#160;<br/>indication or confirmation flags&#160;in the&#160;Application the following actions in the CAN Driver&#160;<br/>have to be realized without any interruption:&#160;<br/>
&#160;&#160;Copy process for receive messages (in the scope of the receive interrupt)&#160;<br/>
&#160;&#160;Copy process for transmit messages (in the scope of CanTransmit(..)&#160;or in a pretransmit&#160;<br/>
function)&#160;<br/>
&#160;&#160;Set of indication and confirmation flags&#160;(in the scope of the receive and transmit&#160;<br/>
interrupt)&#160;<br/>
&#160;&#160;Some internal mechanisms for data&#160;consistency.&#160;<br/>
Therefore different security levels are supported:&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
57&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=58></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-58_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-58_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Level&#160;</b><br/>
<b>CAN&#160;Driver&#160;</b><br/>
<b>Restrictions&#160;for the&#160;Application&#160;</b><br/>
<b>prevention&#160;</b><br/>
&#160; &#160; &#160; &#160; &#160;&#160;None&#160;<br/>
No consistency mechanisms at all.&#160;The CAN&#160;<br/>
00&#160;<br/>
driver has to be configured to polling mode.&#160;<br/>CAN interrupts are not allowed.&#160;All CAN driver&#160;<br/>tasks, all calls to service functions, all data and&#160;<br/>flag access must be performed from the same&#160;<br/>level. &#160;<br/>
10&#160;<br/>
No Flag and Copy&#160;&#160;No usage of CAN transmit and receive signals&#160;<br/>Security&#160;<br/>
in the interrupt context. Usage of the&#160;TxQueue&#160;<br/>is allowed in&#160;Tx polling mode only.&#160;<br/>No reset of notification flags in the interrupt&#160;<br/>context&#160;<br/>If a&#160;fully-preemptive operating system is used,&#160;<br/>the access to the transmit data and&#160;<br/>transmission of the data has to be done on the&#160;<br/>same priority level. (data consistency).&#160;<br/>
20 Interrupts&#160;<br/>
are&#160;<br/>
a) Interrupt-Mode:&#160;<br/>
disabled during the&#160;<br/>
No usage of CAN receive signals and no&#160;<br/>
copy process of&#160;<br/>
reset of notification flags in the interrupt&#160;<br/>
transmit messages&#160;<br/>
context&#160;<br/>
b) Polling-Mode&#160;<br/>
Access to CAN receive signals, indication&#160;<br/>and confirmation flags is only allowed at the&#160;<br/>same level or at lower level than CanTask().&#160;<br/>
30&#160;<br/>
Interrupts are&#160;<br/>
No restrictions for the&#160;Application, neither on&#160;<br/>
(default)&#160;&#160;disabled during the&#160;&#160;the usage of CAN receive or transmit signals&#160;<br/>
copy process of&#160;<br/>
nor on the reset of notifications flags, can i.e.&#160;<br/>
transmit and&#160;<br/>
both be done at any time.&#160;<br/>
receive messages&#160;<br/>and during the&#160;<br/>access to the&#160;<br/>notification flags&#160;<br/>
Figure 1:&#160;Security&#160;levels&#160;<br/>
<b>Important&#160;<br/></b>Be careful if&#160;a pretransmit function is&#160;used. Interrupts are not disabled during the call&#160;of&#160;<br/>
&#160;&#160;this user&#160;specific function by the CAN Driver, therefore the restrictions&#160;for&#160;security level&#160;<br/>
10 are valid. If the interrupts are not disabled before and restored after the copy process&#160;<br/>by the&#160;Application, data&#160;consistency of a CAN messages&#160;cannot be guaranteed if the&#160;<br/>transmit queue is used..&#160;<br/>
&#160;<br/><b>5.6.4.2&#160;</b><br/>
<b>Control of CAN interrupts&#160;</b><br/>
The interrupt control of the CAN Interrupts is done by the service functions&#160;<br/>void CanCanInterruptDisable( void );&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
58&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=59></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-59_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-59_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
void CanCanInterruptRestore( void );&#160;<br/>&#160;<br/>These service functions control the CAN Interrupts. CanCanInterruptDisable disables the&#160;<br/>CAN interrupts and CanCanInterruptRestore restores the state of the CAN interrupts&#160;<br/>before the call of CanCanInterruptDisable.&#160;This mechanism is accompanied with a counter&#160;<br/>to recognize the number of calls.&#160;A&#160;“disable” increments the counter and a “restore”&#160;<br/>decrements the counter to allow&#160;nested calls of these functions.&#160;<br/>These functions could only&#160;be called&#160;as pair.&#160;That means&#160;that on a&#160;<br/>CanCanInterruptDisable must&#160;follow a CanCanInterruptRestore. Otherwise the selected&#160;<br/>interrupt(s) are always disabled.&#160;<br/>Additionally&#160;refer to the hardware description for the specific platform&#160;<br/>TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_int] especially concerning the handling of&#160;<br/>the wake-up interrupt. It depends on the hardware whether the wake-up interrupt is&#160;<br/>included or not.&#160;<br/>There are two call back functions for the application. After&#160;the&#160;CanCanInterruptDisable the&#160;<br/>function ApplCanAddCanInterruptDisable is called and after the CanCanInterruptRestore&#160;<br/>the function&#160;ApplCanAddCanInterruptRestore is called.&#160;<br/>Use these two functions to handle&#160;the wake-up interrupt if the hardware treats this interrupt&#160;<br/>separately or if the Driver runs in&#160;Polling Mode disable the polling tasks.&#160;<br/>To&#160;activate the call back functions refer&#160;to the&#160;API description of the functions.&#160;<br/>
<b>5.6.5&#160;&#160;Assertions&#160;<br/></b>To&#160;detect some incorrect internal conditions of the CAN Driver&#160;during development,&#160;<br/>integration and software test, there are different categories&#160;of so called assertions&#160;<br/>configurable:&#160;<br/>&#160;<br/>&#160;&#160;User interface (for example input parameters, reentrance if not allowed)&#160;<br/>
&#160;&#160;Fatal hardware errors&#160;<br/>
&#160;&#160;Generated data&#160;<br/>
&#160;&#160;Internal software errors (for example inconsistent internal states)&#160;<br/>
Each type of assertion can be configured independently.&#160;<br/>These assertions will help in different development phases to deal with unexpected&#160;<br/>problems which cannot&#160;be handled by the CAN Driver&#160;internally. In such case the following&#160;<br/>callback function will be called by the CAN Driver:&#160;<br/>void ApplCanFatalError( vuint8 errorNumber );&#160;<br/>&#160;<br/>This callback function has to be provided by&#160;the&#160;Application.&#160;The function parameter&#160;<br/>errorNumber gives more detailed information about&#160;the kind of error which is occurred. &#160;<br/>Generally, the error number has to be&#160;checked to solve the underlying problem.&#160;<br/>
<b>Important&#160;<br/></b>This callback function must not return to the CAN Driver afterwards.&#160;<br/>
&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
59&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=60></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-60_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;<br/>The recommended usage of the different assertion&#160;categories is explained in the following&#160;<br/>table:&#160;<br/>&#160;<br/>
User Interface&#160;<br/>
Development of&#160;Application software&#160;<br/>
Fatal hardware errors&#160;<br/>
Development of&#160;Application software &#160;<br/>New CAN Controller used&#160;<br/>
Generated Data&#160;<br/>
New version&#160;of the Generation&#160;Tool used&#160;<br/>Test of software changes in the Generation&#160;Tool or CAN Driver&#160;<br/>(Vector internal)&#160;<br/>
Internal software errors&#160;<br/>
Test of software changes in the CAN Driver (Vector internal)&#160;<br/>
&#160;<br/>These checks could be very run-time intensive and should only be activated for the&#160;<br/>development phase of the CAN Driver&#160;<br/>The call back function&#160;<i>ApplCanFatalError()</i>&#160;is called with the following error codes:&#160;<br/>
<b>In case of a user assertion:&#160;<br/></b>kErrorTxDlcTooLarge&#160;<br/>
<i>CanTransmitVarDlc()&#160;</i>or<i>&#160;CanDynTxObjSetDlc()&#160;</i>called&#160;<br/>with DLC &gt;&#160;8.&#160;<br/>
kErrorTxHdlTooLarge service&#160;<br/>
function<i>&#160;</i>called&#160;with transmit&#160;handle too large&#160;<br/>
kErrorIntRestoreTooOften&#160;<br/>
<i>CanCanInterruptRestore()</i>&#160;called too&#160;often&#160;<br/>
kErrorIntDisableTooOften&#160;<br/>
<i>CanCanInterruptDisable()</i>&#160;called too&#160;often&#160;<br/>
kErrorChannelHdlTooLarge service&#160;<br/>
function<i>&#160;</i>called&#160;with channel&#160;handle too large<i>&#160;</i><br/>
kErrorInitObjectHdlTooLarge&#160;<br/>
<i>CanInit()&#160;</i>called with parameter “initObject” too large &#160;&#160;<br/>
kErrorTxHwHdlTooLarge&#160;<br/>
<i>CanTxGetActHandle()</i>&#160;called with logical hardware&#160;<br/>handle too large &#160;<br/>
kErrorHwObjNotInPolling&#160;<br/>
<i>CanTxObjTask(), CanRxFullCANObjTask()&#160;</i>or<i>&#160;<br/>CanRxBasicCANObjTask()</i>&#160;called for&#160;hardware object&#160;<br/>which is configured to interrupt mode.&#160;<br/>
kErrorHwHdlTooSmall&#160;<br/>
<i>CanTxObjTask(), CanRxFullCANObjTask()&#160;</i>or<i>&#160;<br/>CanRxBasicCANObjTask()</i>&#160;called for&#160;hardware object&#160;<br/>handle too small<i>&#160;</i><br/>
kErrorHwHdlTooLarge&#160;<br/>
<i>CanTxObjTask(), CanRxFullCANObjTask()&#160;</i>or<i>&#160;<br/>CanRxBasicCANObjTask()</i>&#160;called for&#160;hardware object&#160;<br/>handle too large<i>&#160;</i><br/>
kErrorAccessedInvalidDynObj&#160;<br/>
<i>CanGetDynTxObj(),CanReleaseDynTxObj()&#160;</i>&#160;or&#160;<br/><i>CanDynTxObjSet...()</i>&#160;is called with wrong transmit&#160;<br/>handle (transmit handle&#160;too large)&#160;<br/>
kErrorAccessedStatObjAsDyn&#160;<br/>
<i>CanGetDynTxObj(),CanReleaseDynTxObj()&#160;</i>&#160;or&#160;<br/><i>CanDynTxObjSet...()</i>&#160;is called with wrong transmit&#160;<br/>handle (transmit handle&#160;belongs to a&#160;static object)&#160;<br/>
kErrorDynObjReleased&#160;<br/>
<i>UserConfirmation()</i>&#160;or&#160;<i>UserPreTransmit()</i>&#160;is called for a&#160;<br/>dynamic object which is&#160;already released.&#160;<br/>
kErrorPollingTaskRecursion&#160;<br/>
CAN Driver&#160;Polling tasks (<i>Can...Task()</i>) are called&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
60&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=61></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-61_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
recursive or interrupt each other.&#160;<br/>
kErrorDisabledChannel&#160;<br/>
Service function called&#160;for disabled&#160;channel on&#160;systems&#160;<br/>with multiple configurations.&#160;<br/>
kErrorDisabledTxMessage&#160;<br/>
<i>CanCancelTransmit() or&#160;CanTransmit()</i>&#160;called with&#160;<br/>txHandle that is not active in the current configuration.&#160;<br/>(Physical multiple ECU)&#160;<br/>
kErrorDisabledCanInt&#160;<br/>
<i>CanSleep()&#160;</i>or<i>&#160;CanWakeUp()</i>&#160;is called with disabled&#160;<br/>CAN Interrupts (via&#160;<i>CanCanInterruptDisable()</i>).&#160;<br/>
kErrorCanSleep&#160;<br/>
<i>CanStop(), CanCanInterruptDisable()&#160;</i>or<i>&#160;<br/>CanCanInterruptRestore()&#160;</i>called during Sleep mode, or&#160;<br/>offline mode&#160;is not active during sleep mode.<i>&#160;</i><br/>
kErrorCanOnline&#160;<br/>
<i>CanSleep()&#160;</i>or<i>&#160;CanStop()&#160;</i>is called without offline&#160;mode<i>.&#160;</i><br/>
kErrorCanStop&#160;<br/>
<i>CanSleep()&#160;</i>is called&#160;during Stop mode or offline&#160;mode&#160;<br/>is not active during Stop mode.<i>&#160;</i><br/>
kErrorWrongMask&#160;<br/>
<i>CanSetTxIdExtHi()</i>&#160;is called with illegal mask (mask&#160;<br/>higher than&#160;0x1F).&#160;<br/>
kErrorWrongId&#160;<br/>
<i>CanDynTxObjSetId() or CanDynTxObjSetExtid()&#160;</i>is&#160;<br/>called with illegal ID (standard ID higher than 0x7ff or&#160;<br/>extended ID higher than&#160;0x1FFFFFFF).&#160;<br/>
<b>In case of a generation assertion:&#160;<br/></b>kErrorTxROMDLCTooLarge&#160;<br/>
Error in generated table of transmit DLCs&#160;<br/>
<b>In case of a hardware assertion:&#160;<br/></b>kErrorTxBufferBusy&#160;<br/>
HW transmit object is busy, but this is not expected&#160;<br/>
<b>In case of a internal assertion:&#160;<br/></b>kErrorTxHandleWrong&#160;<br/>
saved transmit handle has an unexpected value&#160;<br/>
kErrorInternalTxHdlTooLarge&#160;<br/>
internal function called&#160;with parameter tx handle too&#160;<br/>large&#160;<br/>
kErrorRxHandleWrong&#160;<br/>
The variable rx handle has an illegal&#160;value.&#160;<br/>
kErrorTxObjHandleWrong&#160;<br/>
The handle&#160;of the hardware transmit object has an&#160;<br/>illegal value.&#160;<br/>
kErrorReleasedUnusedDynObj&#160;<br/>
<i>CanReleaseDynTxObj()</i>&#160;is called for&#160;an object which is&#160;<br/>already released.&#160;<br/>
kErrorTxQueueToManyHandle&#160;<br/>
The data type of the&#160;Tx Queue cannot handle all tx&#160;<br/>messages.&#160;<br/>
kErrorInternalChannelHdlTooLarge&#160;&#160;Static function<i>&#160;</i>called with channel handle too large or&#160;<br/>
calculated&#160;channel handle too large.&#160;<br/>
kErrorInternalDisabledChannel&#160;<br/>
Static function called for&#160;disabled&#160;channel on systems&#160;<br/>with multiple configurations.&#160;<br/>
kErrorInternalDisabledTxMessage&#160;&#160;Confirmation called with&#160;txHandle that is not active in&#160;<br/>
the current configuration.&#160;(Physical multiple ECU)&#160;<br/>
&#160;<br/>See the CAN Controller specific part&#160;of the CAN Driver documentation&#160;<br/>TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_assert] to&#160;get the list of additional&#160;<br/>hardware specific error numbers for each CAN Driver.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
61&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=62></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-62_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>5.6.6&#160;&#160;Hardware Loop Check&#160;<br/></b>There are two kinds&#160;of handling&#160;loops&#160;in the CAN Driver internally.&#160;The first one uses&#160;a&#160;<br/>counter or other mathematics algorithms to&#160;abort the loop.&#160;The second one uses hardware&#160;<br/>information from the CAN Controller to abort the loop.&#160;<br/>Some of these state transitions have to be done by two steps:&#160;<br/>1. Request&#160;<br/>2. Acknowledge&#160;<br/>In the first step the request for a specific action&#160;(e.g. re-initialization of the CAN Controller)&#160;<br/>is set but generally it cannot&#160;be entered immediately because of&#160;the prerequisite that the&#160;<br/>CAN bus&#160;has to be&#160;in idle&#160;state, i.e. waiting for a recessive CAN bus level. In normal&#160;<br/>operation the described behavior is&#160;non-critical. However,&#160;an exception is a malfunction of&#160;<br/>the hardware. If the hardware&#160;is damaged or disturbed for a longer time, this loop may be&#160;<br/>too long or even endless and is finally stopped by a watchdog reset. Because of this&#160;<br/>restrictive error recovery the complete software functionality is affected, nothing can be&#160;<br/>done to prevent the repetition and additionally it&#160;is not possible to store any&#160;error specific&#160;<br/>diagnostic information, i.e. the problem cannot be checked later.&#160;<br/>To&#160;avoid those kinds of endless&#160;loops, the user can configure&#160;a special loop control.&#160;This&#160;<br/>has to be handled by the&#160;Application. It cannot be done by the CAN Driver&#160;itself because it&#160;<br/>is hardware dependent.&#160;<br/>Therefore the&#160;Application is informed once by the following callback function if such&#160;a&#160;<br/>critical loop is entered:&#160;<br/>void ApplCanTimerStart( vuint8 timerIdentification );&#160;<br/>&#160;<br/>This callback function starts a timer realized by the&#160;Application.&#160;The recommended timer&#160;<br/>handling is&#160;counting downwards to zero because of faster code on most microprocessors.&#160;<br/>The parameter identifies the timer,&#160;i.e. the kind of loop.&#160;It is necessary to identify the loop&#160;<br/>type because the corresponding start value has to&#160;be set. Beside of this, different (not the&#160;<br/>same) loops can be started re-entrant and so the&#160;Application has to provide one timer for&#160;<br/>each kind of loop.&#160;The list of&#160;necessary timers is pre-defined by the CAN Driver and&#160;<br/>depends on the CAN Controller.&#160;Please refer to&#160;CAN Controller specific documentation for&#160;<br/>a detailed list&#160;TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_loop].&#160;<br/>During the loop wait state a second callback&#160;function is called repeatedly to&#160;control the&#160;<br/>break condition for the loop by the&#160;Application:&#160;<br/>vuint8 ApplCanTimerLoop( vuint8 timerIdentification );&#160;<br/>&#160;<br/>This callback function returns the status of the corresponding&#160;timer to the CAN Driver.&#160;The&#160;<br/>return code must be&#160;TRUE (not equal to 0) if&#160;the timer is still running and FALSE (equal to&#160;<br/>0) if the timer has expired. In this case the CAN Driver loop will be&#160;left&#160;immediately.&#160;The&#160;<br/>Application must be aware of a serious problem in the hardware and the following actions&#160;<br/>have to be done:&#160;<br/>
&#160;&#160;Store diagnostics information&#160;<br/>
&#160;&#160;Switch off transmit (CanOffline()) and receive path of the CAN Driver&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
62&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=63></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-63_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-63_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;&#160;Re-initialization of the CAN&#160;Driver (CanInit()).&#160;This may&#160;lead to the next&#160;loop control&#160;<br/>
failure, therefore it has to&#160;be limited and in case of&#160;a permanent severe hardware&#160;<br/>problem a special limp home state has to be foreseen.&#160;<br/>
If the loop is terminated, a third&#160;callback function is provided to&#160;stop the previously started&#160;<br/>loop control timer:&#160;<br/>void ApplCanTimerEnd( vuint8 timerIdentification );&#160;<br/>&#160;<br/>
<b>Important&#160;<br/></b>Be aware of the priorities&#160;of the timer interrupt routine and the CAN interrupt routine. If&#160;<br/>
&#160;&#160;the priority of the timer interrupt is below the CAN Interrupt priority the timer value for the&#160;<br/>
loop check&#160;may not be&#160;changed anymore&#160;while a CAN interrupt routine is running.&#160;<br/>
&#160;<br/><b>5.6.7&#160;&#160;Support of OSEK-Compliant Operating Systems&#160;<br/></b>If an OSEK operating system is used (ISR category 2), the hard-coded interrupt routines&#160;<br/>for receiving, transmitting, error and wake-up are replaced by the ISR macro. In this case&#160;<br/>an OSEK-specific header has to be included&#160;in can_inc.h&#160;to provide this macro.&#160;<br/>
<b>5.6.8&#160;&#160;Multiple-Channel CAN Driver&#160;<br/></b>There are two different kinds of multiple-channel CAN Drivers: Sometimes two CAN&#160;<br/>Controllers are used by one ECU on the same CAN bus, to increase the number of receive&#160;<br/>and transmit objects. Logically,&#160;they can be conceived as a single CAN Controller.&#160;This&#160;<br/><a href="TechnicalReference_CANDrivers.html#65">behavior is described in the chapter Common CAN. &#160; &#160;&#160;more...</a>&#160;<br/>Usually, two (or more) CAN Controllers are&#160;used to serve different CAN networks, for&#160;<br/>example in gateways. &#160;<br/>&#160;<br/><b>5.6.8.1&#160;</b><br/>
<b>Indexed CAN Driver&#160;</b><br/>
Indexed CAN Drivers work on more than one&#160;CAN bus without doubling&#160;of code. Function&#160;<br/>names are equal to single channel (standard) CAN Driver. Function parameter are different&#160;<br/>in many cases. &#160;<br/>Switches in can_cfg.h are&#160;without a suffix but with effect to all CAN channels.&#160;<br/>&#160;<br/>
<b>5.6.9&#160;&#160;Standard Polling Mode&#160;<br/></b>In polling mode no interrupts are&#160;used. Instead of interrupts the&#160;Application has&#160;to call&#160;<br/>cyclic service functions in the CAN Driver,&#160;to work on transmit and receive messages as&#160;<br/>well as other asynchronous events.&#160;This cyclic service function is&#160;<br/>void CanTask ( void );&#160;<br/>&#160;<br/>and calls all needed service functions for transmission, reception, error and wake-up which&#160;<br/>can also be polled separately by the following service functions:&#160;<br/>void CanRxBasicCANTask &#160;( void );&#160;<br/>void CanRxFullCANTask &#160;&#160;( void );&#160;<br/>void CanTxTask &#160; &#160; &#160;( void );&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
63&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=64></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-64_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
void CanErrorTask &#160;&#160;( void );&#160;<br/>void CanWakeUpTask &#160;( void ); &#160;<br/>&#160;<br/>The transmission and the reception of CAN messages can be served by interrupt or by&#160;<br/>polling separately. Several configurations for polling are available:&#160;<br/>
&#160;&#160;Full CAN Receive objects&#160;(for Full CAN Controllers only)&#160;<br/>
&#160;&#160;Basic CAN Receive Objects&#160;<br/>
&#160;&#160;Transmit objects &#160;<br/>
&#160;&#160;Errors&#160;<br/>
&#160;&#160;Wake-Up&#160;<br/>
&#160;<br/><b>5.6.9.1&#160;</b><br/>
<b>Application Hints&#160;</b><br/>
Concerning&#160;the transmit polling&#160;the handling&#160;depends on the configuration of transmit&#160;<br/>queue and the confirmation notification:&#160;<br/>
&#160;&#160;No transmit queue but confirmation flags and/or&#160;confirmation functions are configured:&#160;<br/>
The CanTxTask() has to be called cyclically as&#160;fast as the confirmation notification is&#160;<br/>needed or before CanTransmit() is called to&#160;release the CAN Controller hardware&#160;<br/>transmit register.&#160;<br/>
&#160;&#160;Transmit queue is configured: CanTransmit()&#160;puts only a transmit request into the&#160;<br/>
transmit queue. CanTxTask() transmits the messages on the CAN bus and does the&#160;<br/>confirmation as well.&#160;Therefore CanTxTask() has&#160;to be called as&#160;fast as confirmation is&#160;<br/>needed and the messages should be transmitted. &#160;<br/>
<b>5.6.10&#160;&#160;Handling of different identifier types&#160;<br/></b>Every Vector CAN Driver supports per default&#160;only&#160;the standard mode using 11&#160;bits for a&#160;<br/>CAN identifier.&#160;In addition to this standard mode, some Vector CAN Drivers&#160;also support&#160;<br/>the feature of extended mode using 29 bits&#160;for a CAN identifier.&#160;<br/>Depending on the selected mode (standard or&#160;extended CAN identifiers) the Generation&#160;<br/>Tool switches to the correct&#160;initialization structures used for the corresponding mode.&#160;The&#160;<br/>type and number of supported&#160;search algorithms depends on&#160;the mode. Four different&#160;<br/>CAN Driver&#160;configurations are possible:&#160;<br/>&#160;<br/>&#160;&#160;Standard mode (only 11&#160;bit CAN identifier)&#160;<br/>
&#160;&#160;Extended mode for the normal receive path&#160;of single CAN messages (only&#160;29 bit CAN&#160;<br/>
identifier)&#160;<br/>
&#160;&#160;Mixed mode (11 bit and 29 bit CAN&#160;identifier mixed on one CAN bus)&#160;<br/>
&#160;&#160;For indexed drivers a bus&#160;dependent mode (11 bit CAN identifier on one and 29 bit CAN&#160;<br/>
identifier on the other CAN bus).&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
64&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=65></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-65_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-65_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>5.6.11&#160;&#160;Copying Mechanisms&#160;<br/></b><a href="TechnicalReference_CANDrivers.html#102">CanCopyToCan or CanCopyFrom</a>Can are hardware/compiler dependent functions that&#160;are&#160;<br/>provided to optimize copying of data&#160;from/to the CAN hardware buffer.&#160;<br/>
<b>Info</b>&#160;<br/>CanCopyFromCan should only be used within&#160;a precopy function. CanCopyToCan&#160;<br/>
&#160;&#160;should only&#160;be used within a pretransmit function.&#160;<br/>
&#160;<br/><b>5.6.12&#160;&#160;Common CAN&#160;<br/></b>Common CAN is a special feature which is available only&#160;on request and on systems with&#160;<br/>2 or more CAN controllers.&#160;The idea of this&#160;feature is&#160;to map different HW channels into&#160;<br/>one application channel.&#160;<br/>When Common CAN is activated additional receive FullCAN messages can be configured&#160;<br/>on a channel.&#160;This is realized by&#160;using a second CAN controller for the same channel.&#160;The&#160;<br/>first CAN controller (CAN&#160;A) supports&#160;Tx,&#160;Rx Full CAN and Rx Basic CAN.&#160;The second&#160;<br/>CAN controller (CAN B) supports&#160;Rx Full CAN. Both CAN controllers have to be connected&#160;<br/>to the same CAN bus.&#160;The&#160;API is always ‘Multiple Receive Channel’.&#160;<br/>&#160;<br/>To&#160;enable the Common CAN feature activate&#160;the corresponding checkbox in the channel&#160;<br/>settings.&#160;<br/>&#160;<br/>First select the messages handled in Full&#160;CAN objects.&#160;Then select the “Hardware&#160;<br/>Channel” to be used to receive the full CAN message.&#160;<br/>&#160;<br/>Please note that the messages received on CAN B of the Common CAN must be filtered&#160;<br/>out with the Basic CAN mask.&#160;<br/>&#160;<br/>&#160;<br/><b>5.6.13&#160;&#160;Multiple ECU&#160;<br/></b>The feature Multiple ECU is usually used for&#160;nodes that exist more than once in a car with&#160;<br/>only a few differences.&#160;At power&#160;up the application decides which node should be realized,&#160;<br/>e.g. left&#160;passenger door,&#160;or right driver door. &#160;<br/>To&#160;reduce the memory consumption messages&#160;that are sent exclusively from one node&#160;<br/>can be overlapped with the exclusively sent messages from the other nodes.&#160;The result of&#160;<br/>this overlapping is that all these messages&#160;share a common memory location for the&#160;<br/>transmit data.&#160;<br/>&#160;<br/>
<b>5.6.14&#160;&#160;Signal Access Macros&#160;<br/></b>Signal access macros are function like macros, to access signals within a message.&#160;They&#160;<br/>can be used by the application for an easy access to signals.&#160;The generation of signal&#160;<br/>value access macros can be enabled or disabled. If enabled, the Generation&#160;Tool&#160;<br/>generates access macros using the signal names from the communication data base with&#160;<br/>respect to prefixes or post-fixes defined in the Names tab.&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
65&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=66></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-66_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-66_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;<br/>
Figure 5-13&#160;Name of signal access macros&#160;<br/>
For each signal an access macro is formed from&#160;the signal name in the CAN database, a&#160;<br/>signal variable prefix (access via signal structures or byte/word commands), a signal&#160;<br/>prefix, a signal postfix, and&#160;a signal variable postfix. Prefixes&#160;and postfixes can be&#160;<br/>configured&#160;by the user in the&#160;generator program.&#160;To&#160;assure better readability,&#160;it is&#160;<br/>advisable not to use all four prefixes and postfixes simultaneously.&#160;<br/>
The access macros for the CAN receive buffer get an extended prefix&#160;CAN_. Within&#160;<br/>
Precopy and Pretransmit routines these macros serve to access the CAN controller's CAN&#160;<br/>receive and transmit buffer on a signal basis.&#160;<br/>&#160;<br/>
<b>5.6.15&#160;&#160;CAN RAM Check&#160;<br/></b>The CAN driver supports a check of the CAN controller’s mailboxes.&#160;The CAN controller&#160;<br/>RAM check is called internally&#160;every time the&#160;function CanInit() is called.&#160;The CAN driver&#160;<br/>verifies that no used mailboxes&#160;is corrupt.&#160;A&#160;mailbox is considered corrupt if a predefined&#160;<br/>pattern is written to the appropriate mailbox registers&#160;and the read operation does not&#160;<br/>return the expected pattern. If a corrupt mailbox is found the function&#160;<br/>ApplCanCorruptMailbox() is called.&#160;This function tells&#160;the application which mailbox is&#160;<br/>corrupt. &#160;<br/>After the check of all mailboxes the CAN driver calls&#160;the callback function&#160;<br/>ApplCanMemCheckFailed() if at least one&#160;corrupt mailbox was&#160;found.&#160;The application&#160;<br/>must decide if the CAN&#160;driver disables&#160;communication or&#160;not by means of the callback&#160;<br/>function’s return value. If the application has&#160;decided to disable the&#160;communication there is&#160;<br/>no possibility to enable the communication again until the next&#160;call to CanInitPowerOn().&#160;<br/>The CAN RAM check functionality&#160;itself can be activated via Generation&#160;Tool.&#160;This include&#160;<br/>the callback&#160;ApplCanMemCheckFailed().&#160;The callback&#160;ApplCanCorruptMailbox() can only&#160;<br/>be activated via a user configuration file. &#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
66&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=67></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-67_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>6&#160;&#160;Detailed Description of the&#160;Functional Scope (High End extension)&#160;</b><br/>
<b>6.1&#160;&#160;Transmission&#160;</b><br/>
<b>6.1.1&#160;&#160;Low-Level Message Transmit&#160;<br/></b>Using a multiple channel CAN&#160;Driver the routing of complete CAN messages from one&#160;<br/>CAN Bus to&#160;another one is&#160;supported by the function&#160;<br/>vuint8 CanMsgTransmit(...);&#160;<br/>This function has a parameter with a pointer to&#160;a CAN Message Buffer. So it is possible to&#160;<br/>route the whole buffer from one&#160;CAN chip to the other&#160;one.&#160;To&#160;prevent a conflict with the&#160;<br/>functional messages, this function uses an own send buffer (If an additional buffer is&#160;<br/>available in the CAN Controller). &#160;<br/>A&#160;special confirmation function and an initialization callback function are called.&#160;<br/>void ApplCanMsgTransmitConf(...); within confirmation interrupt&#160;<br/>
void ApplCanMsgTransmitInit(...); within CanInit&#160;<br/>These functions can be used by&#160;the application to implement&#160;a data&#160;queue mechanism.&#160;<br/>There is no internal transmit queue for this transmit object available.&#160;<br/>&#160;<br/>CanMsgTransmit() can also&#160;be used for dynamic transmission.&#160;Therefore the CAN driver&#160;<br/>supports macros to write standard ID or&#160;extended ID, DLC and data to the structure:&#160;<br/>&#160;<br/>CanMsgTransmitSetStdId (...)&#160;<br/>
CanMsgTransmitSetExtId (...)&#160;<br/>CanMsgTransmitSetDlc (...)&#160;<br/>
CanMsgTransmitSetData (...)&#160;<br/>&#160;<br/>
<b>6.2&#160;&#160;Reception&#160;</b><br/>
<b>6.2.1&#160;&#160;Multiple Basic CAN&#160;<br/></b>To&#160;improve efficiency of the&#160;hardware filtering and reduce the interrupt load produced by&#160;<br/>reception of unwanted messages, the number of Hardware Basic CAN objects can be&#160;<br/>changed in the Generation&#160;Tool. Each Hardware&#160;Basic&#160;CAN object has it’s own filter.&#160;<br/>Increasing the number of Basic CAN objects&#160;will reduce the&#160;number of available Full CAN&#160;<br/>objects&#160;(Rx and&#160;Tx).&#160;<br/>This feature is only available for Full CAN controllers.&#160;<br/>
<b>6.2.2&#160;&#160;Rx Queue&#160;<br/></b>The Rx Queue is a data&#160;queue which stores receive messages if the application does not&#160;<br/>want to process them within the interrupt context. In some applications it may happen that&#160;<br/>the run time in the receive interrupt becomes too long.&#160;This leads to long interrupt&#160;<br/>latencies&#160;and possible loss&#160;of messages.&#160;The&#160;Rx Queue may&#160;help&#160;in these cases. If&#160;the&#160;<br/>Rx Queue is configured the received messages&#160;are copied into this&#160;queue in the interrupt&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
67&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=68></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-68_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-68_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
context.&#160;The handling of the&#160;queued messages is done on task level. Messages which are&#160;<br/>received by means of&#160;a RangePrecopy can also be copied into the queue or handled in&#160;<br/>the interrupt context.&#160;<br/>In order to&#160;handle the queued messages the application has to call cyclically a CAN Driver&#160;<br/>function which checks for queued messages and processes them.&#160;<br/>If Precopy and Indication functions are used for application messages, be aware that they&#160;<br/>are not called in interrupt context any more.&#160;<br/>By using the Rx Queue the runtime in the Rx interrupt is&#160;decreased.&#160;The average runtime&#160;<br/>of the application is increased because of the overhead&#160;for handling the queue.&#160;<br/>
<b>Please note&#160;<br/></b>In case a range is configured to be&#160;handled via the Rx Queue, the return code of the&#160;<br/>
&#160;&#160;RangePrecopy for this range is ignored.&#160;<br/>
<b>6.2.2.1&#160;&#160;Handling in Receive Interrupt&#160;<br/></b>During the receive interrupt the CAN Driver calls the callback function&#160;<br/>ApplCanPreRxQueue() after the range or search&#160;algorithm match in order to let the&#160;<br/>application decide whether&#160;the received message is processed within the interrupt or&#160;has&#160;<br/>to be entered into the Rx queue.&#160;The function&#160;ApplCanPreRxQueue() is only called if&#160;<br/>configured.&#160;Otherwise all received messages&#160;are handled by the Rx queue. If the Rx&#160;<br/>Queue is full the CAN Driver&#160;notifies the application by calling the callback function&#160;<br/>ApplCanRxQueueOverrun() (if configured) and discards the received message.&#160;After the&#160;<br/>message was copied into the Rx queue the Rx interrupt is terminated.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
68&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=69></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-69_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
Receive message<br/>
(hardware filtering)<br/>
Hardware&#160;Level<br/>
Enter<br/>
<b>Rx Interrupt Level Start</b><br/>
Receive&#160;Interrupt<br/>
ApplCanMsgReceived<br/>
(CanRxInfoStructPtr)<br/>
SW Range<br/>
entered<br/>
yes<br/>
no<br/>
Queue<br/>
yes<br/>
configured<br/>
no<br/>
Normal&#160;receive-interrupt<br/>
Range&#160;Precopy<br/>
ApplCanPreRxQueue<br/>
with&#160;SW&#160;message&#160;search<br/>
Indexed,<br/>
Function<br/>
(CanRxInfoStructPtr)<br/>
Hash,<br/>Linear<br/>
ApplCanPreRxQueue<br/>
(CanRxInfoStructPtr)<br/>
Return<br/>
kCanCopyData<br/>
Return<br/>
yes<br/>
yes<br/>
kCanCopyData<br/>
no<br/>
<b>Write FIFO</b><br/>
<b>Write FIFO</b><br/>
Handle<br/>
Handle<br/>
normal receive-interrupt<br/>
no<br/>
Id<br/>
Id<br/>
with Message&#160;Precopy,<br/>
DLC<br/>
DLC<br/>
data copy&#160;mechanism,<br/>
Data<br/>
Data<br/>
Indication&#160;Function&#160;/&#160;Flags<br/>
yes<br/>
<b>Exit</b><br/>
<b>Rx&#160;Interrupt&#160;Level&#160;End</b><br/>
&#160;<br/>
Figure 6-1&#160;&#160;Handling of the&#160;Rx queue&#160;within the receive routine.&#160;<br/>
<b>6.2.2.2&#160;&#160;Handling on Task Level&#160;<br/></b>In order to process the messages pending in the Rx queue the application has to call the&#160;<br/>function CanHandleRxMsg().&#160;This function&#160;processes all messages in the queue.&#160;The&#160;<br/>processing of the messages is&#160;done in the same way&#160;like in&#160;the Rx interrupt.&#160;That means&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
69&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=70></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-70_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
for each message the Generic Precopy and the UserPrecopy are called.&#160;After that the&#160;<br/>message data&#160;are copied into the RAM buffer and than the Indication Flag is set and the&#160;<br/>UserIndication function is called.&#160;The last step is to delete the processed message from&#160;<br/>the Rx queue.&#160;<br/>
CanHandleRxMsg()<br/>
<b>Task Level Start</b><br/>
<b>Read&#160;FIFO</b><br/>
Handle<br/>
Id<br/>
DLC<br/>
Data<br/>
SW Range<br/>
no<br/>
entered<br/>
yes<br/>
normal&#160;receive-interrupt<br/>
Range Precopy<br/>
with Message&#160;Precopy,<br/>
Function<br/>
data&#160;copy&#160;mechanism<br/>
<b>Clear FIFO</b><br/>
<b>Clear FIFO</b><br/>
Handle<br/>
Handle<br/>
Id<br/>
Id<br/>
DLC<br/>
DLC<br/>
Data<br/>
Data<br/>
Indication&#160;Function&#160;/&#160;Flags<br/>
<b>Exit</b><br/>
<b>Task Level End</b><br/>
&#160;<br/>
Figure 6-2&#160;&#160;Handling of the&#160;Rx queue on task&#160;level.&#160;<br/>
<b>6.2.2.3&#160;&#160;Resetting the Rx Queue &#160;&#160;<br/></b>The CAN Driver provides&#160;the function CanDeleteRxQueue() to delete all messages&#160;<br/>pending in the Rx Queue&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
70&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=71></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-71_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>6.3&#160;&#160;Special Features&#160;</b><br/>
<b>6.3.1&#160;&#160;Individual Polling&#160;<br/></b>Each mailbox (BasicCAN Rx, FullCAN Rx, FullCAN Tx,&#160;low&#160;level Tx&#160;and&#160;normal Tx)&#160;can&#160;be&#160;<br/>selected to be polled or&#160;treat in interrupt context.&#160;This also provides the possibility to use&#160;<br/>interrupt mode on one channel&#160;and polling mode on the other.&#160;<br/>The polling tasks of the standard&#160;polling mode are still&#160;available.&#160;The CAN Driver provides&#160;<br/>additional service functions to&#160;poll each mailbox individual.&#160;<br/>void CanRxBasicCANObjTask &#160;( ... );&#160;<br/>void CanRxFullCANObjTask &#160;&#160;( ... );&#160;<br/>void CanTxObjTask &#160; &#160; &#160;&#160;( ... );&#160;<br/>These functions have the number&#160;of the mailbox and the hardware channel as parameter.&#160;<br/>For both parameters, symbolic names are generated.&#160;<br/>
CanTask(),&#160;&#160;CanErrorTask()&#160;and&#160;CanWakeUpTask()&#160;are available in this polling&#160;<br/>
mode, too.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
71&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=72></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-72_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>7&#160;&#160;Feature List (Standard and High End)&#160;</b><br/>
This general feature list describes the overall feature set of Vector CAN Drivers. Not all of&#160;<br/>these features are mandatory&#160;for all CAN Drivers. Please&#160;refer to the CAN Controller&#160;<br/>dependent CAN Driver manual for details&#160;TechnicalReference_CAN_&lt;hardware&gt;.pdf&#160;<br/>[#hw_feature].&#160;<br/>&#160;<br/>&#160;<br/><b>CAN Driver&#160;Functionality&#160;<br/></b>&#160;<br/>
<b>Standard&#160;</b><br/>
<b>HighEnd&#160;</b><br/>
<b>Functions&#160;</b><br/>
<b>Initialization&#160;</b><br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
Power-On Initialization&#160;<br/>
 &#160;<br/>
 &#160;<br/>
CanInitPowerOn&#160;<br/>
Re-Initialization&#160;<br/>
 &#160;<br/>
 &#160;<br/>
CanInit&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
<b>Transmission&#160;</b><br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
Transmit Request&#160;<br/>
 &#160;<br/>
 &#160;<br/>
CanTransmit&#160;<br/>
Transmit Request Queue&#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
Internal data copy mechanism&#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
Pretransmit functions&#160;<br/>
 &#160;<br/>
 &#160;<br/>
UserPreTransmit&#160;<br/>
Common confirmation function&#160;<br/>
 &#160;<br/>
 &#160;<br/>
ApplCanTxConfirmation&#160;<br/>
Confirmation flag&#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
Confirmation function&#160;<br/>
 &#160;<br/>
 &#160;<br/>
UserConfirmation&#160;<br/>
Offline Mode&#160;<br/>
 &#160;<br/>
 &#160;<br/>
CanOnline, CanOffline&#160;<br/>
Partial Offline&#160;Mode&#160;<br/>
CanOnline, CanPartOffline,&#160;<br/>
 &#160;<br/>
 &#160;<br/>
CanGetPartMode&#160;<br/>
Passive-Mode&#160;<br/>
CanSetActive,&#160;<br/>
 &#160;<br/>
 &#160;<br/>
CanSetPassive&#160;<br/>
Tx Observe mode&#160;<br/>
ApplCanInit,&#160;<br/>
 &#160;<br/>
 &#160;<br/>
ApplCanTxObjStart,&#160;<br/>ApplCanTxObjConfirmed&#160;<br/>
Dynamic&#160;TxObjects&#160;<br/>
ID&#160;<br/>
 &#160;<br/>
 &#160;<br/>
CanDynTxSet(Ext)Id&#160;<br/>
&#160;<br/>
DLC&#160;<br/>
 &#160;<br/>
 &#160;<br/>
CanDynTxSetDlc&#160;<br/>
&#160;<br/>
Data-Ptr&#160;<br/>
 &#160;<br/>
 &#160;<br/>
CanDynTxSetDataPtr&#160;<br/>
Full CAN&#160;Tx&#160;Objects&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
Cancellation in Hardware&#160;<br/>
CanCancelTransmit,&#160;<br/>
&#160;<br/>
&#160;<br/>
CanCancelMsgTransmit&#160;<br/>
Low Level Message&#160;Transmit&#160;<br/>
&#160;<br/>
 &#160;<br/>
CanMsgTransmit&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
<b>Reception&#160;</b><br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
Receive function&#160;<br/>
 &#160;<br/>
 &#160;<br/>
ApplCanMsgReceived&#160;<br/>
Search algorithms&#160;<br/>
Linear&#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
Table&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
Index&#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
&#160;<br/>
Hash&#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
72&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=73></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-73_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
Range specific precopy functions&#160;<br/>
ApplCanRangeXxxPrecopy&#160;<br/>
4&#160;<br/>
4&#160;<br/>
Xxx .. 0,1,2,3&#160;<br/>
DLC check&#160;<br/>
 &#160;<br/>
 &#160;<br/>
ApplCanMsgDlcFailed&#160;<br/>
Internal data copy mechanism&#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
Generic precopy function&#160;<br/>
 &#160;<br/>
 &#160;<br/>
ApplCanGenericPrecopy&#160;<br/>
Precopy function&#160;<br/>
 &#160;<br/>
 &#160;<br/>
UserPrecopy&#160;<br/>
Indication flag&#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
Indication function&#160;<br/>
 &#160;<br/>
 &#160;<br/>
UserIndication&#160;<br/>
Message not matched function&#160;<br/>
 &#160;<br/>
 &#160;<br/>
ApplCanMsgNotMatched&#160;<br/>
Overrun Notification&#160;<br/>
 &#160;<br/>
 &#160;<br/>
ApplCanOverrun&#160;<br/>
Full-CAN overrun notification&#160;<br/>
&#160;<br/>
&#160;<br/>
ApplCanFullCanOverrun&#160;<br/>
Multiple Basic CAN&#160;<br/>
&#160;<br/>
 &#160;<br/>
&#160;<br/>
Rx Queue&#160;<br/>
CanHandleRxMsg,&#160;<br/>
&#160;<br/>
 &#160;<br/>
CanDeleteRxQueue&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
<b>Bus off&#160;</b><br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
Notification function&#160;<br/>
 &#160;<br/>
 &#160;<br/>
ApplCanBusOff&#160;<br/>
Nested Recovery functions&#160;<br/>
CanResetBusOffStart,&#160;<br/>
 &#160;<br/>
 &#160;<br/>
CanResetBusOffEnd&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
<b>Sleep Mode&#160;</b><br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
Mode Change&#160;<br/>
&#160;<br/>
&#160;<br/>
CanSleep, CanWakeUp&#160;<br/>
Preparation&#160;<br/>
 &#160;<br/>
 &#160;<br/>
CanResetBusSleep&#160;<br/>
Notification function&#160;<br/>
&#160;<br/>
&#160;<br/>
ApplCanWakeUp&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;<br/>
<b>Special Feature&#160;</b><br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
<b>&#160;</b><br/>
Status&#160;<br/>
 &#160;<br/>
 &#160;<br/>
CanGetStatus&#160;<br/>
Security Level&#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
Assertions&#160;<br/>
 &#160;<br/>
 &#160;<br/>
ApplCanFatalError&#160;<br/>
Hardware loop check&#160;<br/>
ApplCanTimerStart&#160;<br/>
 &#160;<br/>
 &#160;<br/>
ApplCanTimerLoop&#160;<br/>ApplCanTimerEnd&#160;<br/>
Stop Mode&#160;<br/>
&#160;<br/>
&#160;<br/>
CanStart, CanStop&#160;<br/>
Support of OSEK operating system&#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
Standard Polling Mode&#160;<br/>
Tx &#160;<br/>
 &#160;<br/>
 &#160;<br/>
CanTxTask&#160;<br/>
&#160;<br/>
Rx(Full CAN objects)&#160;<br/>
&#160;<br/>
&#160;<br/>
CanRxFullCANTask&#160;<br/>
&#160;<br/>
Rx(Basic CAN&#160;objects)&#160;<br/>
 &#160;<br/>
 &#160;<br/>
CanRxBasicCANTask&#160;<br/>
&#160;<br/>
Error&#160;<br/>
 &#160;<br/>
 &#160;<br/>
CanErrorTask&#160;<br/>
&#160;<br/>
Wakeup&#160;<br/>
&#160;<br/>
&#160;<br/>
CanWakeUpTask&#160;<br/>
Individual Polling&#160;<br/>
CanTxObjTask,&#160;<br/>
&#160;<br/>
 &#160;<br/>
CanRxFullCANObjTask,&#160;<br/>CanRxBasicCANObjTask&#160;<br/>
Multi-channel&#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
Support extended ID addressing mode&#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
Support mixed ID addressing mode&#160;<br/>
 &#160;<br/>
 &#160;<br/>
&#160;<br/>
Support access to error counters&#160;<br/>
CanRxActualErrorCounter&#160;<br/>
 &#160;<br/>
 &#160;<br/>
CanTxActualErrorCounter&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
73&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=74></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-74_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
Copy functions&#160;<br/>
CanCopyFromCan,&#160;<br/>
 &#160;<br/>
 &#160;<br/>
CanCopyToCan&#160;<br/>
CAN RAM&#160;check&#160;<br/>
 &#160;<br/>
 &#160;<br/>
ApplCanMemCheckFailed&#160;<br/>
Figure 2:&#160;Feature&#160;List&#160;<br/>
 &#160;&#160;feature is&#160;supported in&#160;general (exceptions might be&#160;possible if a CAN controller&#160;is not able to&#160;support a&#160;<br/>
feature.&#160;<br/>
&#160;<br/>
feature&#160;is not&#160;implemented for each&#160;hardware&#160;because different CAN controller&#160;doesn’t&#160;support this&#160;<br/>feature.&#160;<br/>
&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
74&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=75></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-75_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>8&#160;&#160;Description of the&#160;API (Standard)&#160;</b><br/>
The complete Standard CAN Driver&#160;API is described in this section.&#160;<br/>
<b>8.1&#160;</b><br/>
<b>API Categories&#160;</b><br/>
Depending on the number of&#160;supported channels, i.e. the number of connected CAN&#160;<br/>networks to one ECU, the&#160;API&#160;of the CAN Driver is realized as &#34;Single Channel&#34; or&#160;<br/>&#34;Multiple Channel&#34; with additional&#160;channel specific information.&#160;<br/>
<b>8.1.1&#160;&#160;Single Receive Channel (SRC)&#160;<br/></b>A&#160;“Single Receive Channel” CAN Driver supports one CAN channel.&#160;<br/>
<b>8.1.2&#160;&#160;Multiple Receive Channel (MRC)&#160;<br/></b>A&#160;&#34;Single Receive Channel&#34; CAN&#160;Driver is typically&#160;extended for multiple channels by&#160;<br/>adding an index to the function parameter list (e.g. CanOnline() becomes to&#160;<br/>CanOnline(channel)) or by using the&#160;handle as a channel indicator (e.g.&#160;<br/>CanTransmit(txHandle)).&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
75&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=76></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-76_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>8.2&#160;</b><br/>
<b>Data Types&#160;</b><br/>
The following general data types are defined by the CAN Driver:&#160;<br/>&#160;<br/>
vbittype &#160;<br/>
canbittype&#160;<br/>
Single bit information&#160;<br/>
vuint8 &#160;<br/>
canuint8&#160;<br/>
unsigned 8&#160;bit (byte) value&#160;<br/>
vuint16 &#160;<br/>
canuint16&#160;<br/>
unsigned 16&#160;bit (word) value&#160;<br/>
vuint32 &#160;<br/>
canuint32&#160;<br/>
unsigned 32&#160;bit (dword) value&#160;<br/>
vsint8&#160;<br/>
cansint8&#160;<br/>
signed 8 bit&#160;(byte) value&#160;<br/>
vsint16 &#160;<br/>
cansint16&#160;<br/>
signed 16 bit (word) value&#160;<br/>
vsint32 &#160;<br/>
cansint32&#160;<br/>
signed 32 bit (dword) value&#160;<br/>
&#160;<br/>There are special data types to reference specific generated data structures:&#160;<br/>
CanInitHandle Initialization&#160;<br/>
parameters&#160;<br/>
CanReceiveHandle Receive&#160;<br/>
parameters&#160;<br/>
CanTransmitHandle Transmit&#160;<br/>
parameters&#160;<br/>
CanChannelHandle&#160;<br/>
Channel parameters ( only available in indexed CAN Drivers )&#160;<br/>
&#160;<br/>
<b>Some data&#160;types are referencing the CAN Controller registers&#160;</b><br/>
CanChipDataPtr&#160;<br/>
Receive and transmit data register of&#160;the CAN Controller&#160;<br/>
CanChipMsgPtr&#160;<br/>
Complete receive and transmit message objects&#160;including&#160;CAN&#160;<br/>identifier and DLC&#160;<br/>
<b>Some data&#160;types are only&#160;available in Single Receive Channel and Multiple Receive&#160;<br/>Channel CAN Drivers&#160;</b><br/>
typedef volatile struct&#160;<br/>
Structure with transmit information.&#160;<br/>
{&#160;<br/>
&#160;<br/>
&#160; CanChipDataPtr &#160; &#160;&#160;&#160;&#160;pChipData;&#160;<br/>
pChipData is the pointer&#160;to the transmit data bytes&#160;<br/>
&#160; CanTransmitHandle &#160;Handle;&#160;<br/>
in the CAN controller.&#160;<br/>
} CanTxInfoStruct;&#160;<br/>
Handle of the transmit message.&#160;<br/>
&#160;<br/>typedef volatile struct&#160;<br/>
Structure with receive information:&#160;<br/>
{&#160;<br/>
Channel from which the precopy is&#160;called.&#160;<br/>
&#160; CanChannelHandle &#160;&#160;Channel;&#160;<br/>
pChipMsgObj is the pointer to the CAN Controller&#160;<br/>
&#160; CanChipMsgPtr &#160; &#160;&#160;&#160;&#160;pChipMsgObj;&#160;<br/>
Receive Register. If there are several receive&#160;<br/>objects&#160;with&#160;different memory addresses available,&#160;<br/>
&#160; CanChipDataPtr &#160; &#160;&#160;&#160;&#160;pChipData;&#160;<br/>
pChipMsgObj contains the pointer to&#160;the dedicated&#160;<br/>
&#160; CanReceiveHandle &#160;&#160;Handle;&#160;<br/>
receive object to get some information like CAN&#160;<br/>
} tCanRxInfoStruct;&#160;<br/>
identifier or&#160;DLC of the received message directly&#160;<br/>out of the CAN Controller registers.&#160;<br/>
&#160;<br/>
pChipData is the pointer&#160;to the received data bytes.<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
76&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=77></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-77_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-77_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
Handle of the received message.&#160;<br/>
CanRxInfoStructPtr&#160;<br/>
Pointer to structure with&#160;receive information.&#160;<br/>
&#160;<br/>&#160;<br/>
<b>8.3&#160;</b><br/>
<b>Constants&#160;</b><br/>
This information is stored in ROM.&#160;<br/>
<b>8.3.1&#160;&#160;Version Number&#160;<br/></b>kCanMainVersion and kCanSubVersion contains the&#160;BCD coded version of the CAN&#160;<br/>Driver:&#160;<br/>&#160;<br/>kCanMainVersion&#160;<br/>
Main version of the CAN Driver (BCD coded in a vuint8 constant&#160;<br/>variable)&#160;<br/>
kCanSubVersion&#160;<br/>
Sub version of the CAN&#160;Driver (BCD coded in a&#160;vuint8 constant&#160;<br/>variable)&#160;<br/>
kCanBugFixVersion&#160;Release version of the&#160;CAN Driver&#160;(BCD coded&#160;in a vuint8&#160;<br/>
constant variable)&#160;<br/>
&#160;<br/>
<b>Example</b>&#160;<br/>A&#160;version number 2.31.00 is coded as&#160;0x02 in kCanMainVersion, 0x31 in&#160;<br/>
&#160;&#160;kCanSubVersion and 0x00 in kCanBugFixVersion.&#160;<br/>
&#160;<br/>
<b>8.4&#160;</b><br/>
<b>Macros&#160;</b><br/>
<b>8.4.1&#160;&#160;Conversion between Logical and&#160;Hardware Representation of CAN&#160;</b><br/>
<b>Parameter DLC&#160;</b><br/>
These macros are used to convert the CAN protocol specific parameter DLC between the&#160;<br/>logical presentation (DLC: 0..8) and the CAN Controller dependent, internal register layout&#160;<br/>of different CAN Controllers.&#160;<br/>They are normally used by the Generation&#160;Tool&#160;for the initialization&#160;of the node specific&#160;<br/>control structures but they&#160;are available also&#160;for the&#160;Application, if necessary.&#160;<br/>The MK_... macros are converting from the&#160;logical to the CAN&#160;Controller dependent&#160;<br/>representation:&#160;<br/>MK_TX_DLC(dlc)&#160;<br/>
Conversion of transmit&#160;DLC, if associated CAN message has&#160;<br/>standard identifier&#160;<br/>
&#160;<br/>The following macro is only allowed to be&#160;used if extended CAN identifiers are used:&#160;<br/>MK_TX_DLC_EXT(dlc)&#160;&#160;Conversion of transmit DLC if associated CAN message has an&#160;<br/>
extended identifier&#160;<br/>
&#160;<br/>The XT_... macro is converting from&#160;the CAN Controller dependent to the logical&#160;<br/>presentation:&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
77&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=78></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-78_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
XT_TX_DLC(dlc)&#160;<br/>
Conversion of transmit DLC independent of identifier type&#160;<br/>
&#160;<br/><b>8.4.2&#160;&#160;Direct Access to the CAN Controller Registers&#160;<br/></b>These macros are defined by the CAN Driver&#160;to provide the access on CAN protocol&#160;<br/>specific parameters like CAN identifier and DLC&#160;currently available in the CAN Controller.&#160;<br/>To&#160;assign these information to a previously received message they are only valid in the&#160;<br/>callback function&#160;ApplCanMsgReceived() or in user specific precopy functions. Only in this&#160;<br/>scope there is a clear reference on receive messages possible and data in the CAN&#160;<br/>Controller receive registers are still locked.&#160;They are referencing either on the CAN&#160;<br/>Controller register or on the software shadow buffer of the CAN&#160;Driver, if used.&#160;The&#160;<br/>parameter rxStruct is only available for Single Receive Channel&#160;and Multiple Receive&#160;<br/>Channel Drivers and is the pointer to&#160;the receive information structure.&#160;<br/>CanRxActualId(rxStruct)&#160;<br/>
Read identifier in logical&#160;presentation&#160;(0h..7FFh for&#160;<br/>standard identifier or 0h..1FFFFFFFh for extended&#160;<br/>identifier).&#160;<br/>In case of mixed identifier, the macro&#160;<br/>CanRxActualIdType can be used to&#160;decide whether&#160;<br/>the CAN identifier is&#160;in standard or extended&#160;<br/>format.&#160;<br/>
CanRxActualIdType(rxStruct)&#160;Read the format type of the CAN identifier&#160;<br/>
&#160;kCanIdTypeStd&#160;&#160;standard&#160;<br/>
format&#160;<br/>
&#160;kCanIdTypeExt&#160;&#160;extended&#160;<br/>
format&#160;<br/>
CanRxActualDLC(rxStruct)&#160;<br/>
Read DLC in logical presentation (0..8)&#160;<br/>
CanRxActualData(rxStruct,i)&#160;Read Data in logical presentation. i is the position&#160;<br/>
of the byte (0..7).&#160;<br/>
CanRxActualErrorCounter(&#160;<br/>
Read current status of the receive error counter. In&#160;<br/>
channel)&#160;<br/>
use of microcontrollers&#160;without an readable error&#160;<br/>counter, this macro returns always 0.&#160;<br/>
CanTxActualErrorCounter(&#160;<br/>
Read current status of the transmit error counter.&#160;In&#160;<br/>
channel)&#160;<br/>
use of microcontrollers&#160;without an readable error&#160;<br/>counter, this macro returns always 0.&#160;<br/>
&#160;<br/>The following macros are only available&#160;if extended CAN identifiers are used:&#160;<br/>CanRxActualIdExtHi(&#160;<br/>
Read the bit 24 to 29 of the extended identifier in&#160;<br/>
rxStruct)&#160;<br/>
logical presentation&#160;<br/>
CanRxActualIdExtMidHi(&#160;<br/>
Read the bit 16 to 23 of the extended identifier in&#160;<br/>
rxStruct)&#160;<br/>
logical presentation&#160;<br/>
CanRxActualIdExtMidLo(&#160;<br/>
Read the bit 8 to 15 of the extended identifier in&#160;<br/>
rxStruct)&#160;<br/>
logical presentation&#160;<br/>
CanRxActualIdExtLo(&#160;<br/>
Read the bit 0 to 7 of the&#160;extended identifier in&#160;<br/>
rxStruct)&#160;<br/>
logical presentation&#160;<br/>
&#160;<br/>To&#160;write CAN protocol specific parameters&#160;like CAN identifier and DLC the to the CAN&#160;<br/>controller there are some macros available.&#160;The parameter txStruct is only available for&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
78&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=79></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-79_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
Single Receive Channel and Multiple Receive&#160;Channel Drivers&#160;and is&#160;the pointer to the&#160;<br/>transmit information structure.&#160;<br/>CanTxWriteActId(txStruct,&#160;<br/>
Write the parameter id in standard format and in&#160;<br/>
id)&#160;<br/>
logical presentation to the hardware.&#160;<br/>
CanTxWriteActDLC(rxStruct,&#160;&#160;Write the DLC in logical&#160;presentation&#160;(0..8)&#160;<br/>dlc)&#160;<br/>&#160;<br/>The following macro is only available&#160;if extended CAN identifiers are used:&#160;<br/>CanTxWriteActExtId(&#160;<br/>
Write the parameter id in extended format and in&#160;<br/>
txStruct,id)&#160;<br/>
logical presentation to the hardware.&#160;<br/>
&#160;<br/><b>8.4.3&#160;&#160;Interpretation of the CAN Status&#160;<br/></b>The following macros are used to decode the return code of CanGetStatus() (TRUE&#160;<br/>means not equal to zero):&#160;<br/>CanHwIsOk(state)&#160;<br/>
This macro returns&#160;TRUE, if the status of the CAN&#160;<br/>Controller is Error-Active.&#160;<br/>
CanHwIsWarning(state)&#160;This macro returns&#160;TRUE, if the status of the CAN&#160;<br/>
Controller is Warning (at least one error counter is equal or&#160;<br/>higher than&#160;96).&#160;<br/>
CanHwIsPassive(state)&#160;This macro returns&#160;TRUE, if the status of the CAN&#160;<br/>
Controller is Error-Passive.&#160;<br/>
CanHwIsBusOff(state)&#160;&#160;This macro returns&#160;TRUE, if the status of the CAN&#160;<br/>
Controller is Bus-Off.&#160;This information is only temporary.&#160;The&#160;<br/>time when this status&#160;changes from&#160;TRUE to FALSE&#160;<br/>depends on&#160;the CAN controller. &#160;This could be after the CAN&#160;<br/>controller has resynchronized on the&#160;bus regardless of the&#160;<br/>Busoff recovery by the&#160;Application.&#160;This could&#160;also be after&#160;<br/>CanResetBusoffStart() is called&#160;or after&#160;<br/>CanResetBusoffEnd() is called.&#160;&#160;<br/>Hint: &#160;Busoff&#160;detection has to be performed with&#160;<br/>ApplCanBusoff().&#160;<br/>
CanHwIsWakeup(state)&#160;&#160;This macro returns&#160;TRUE, if the CAN Controller is not in&#160;<br/>
sleep mode.&#160;<br/>
CanHwIsSleep(state)&#160;<br/>
This macro returns&#160;TRUE, if the CAN Controller is in sleep&#160;<br/>mode.&#160;<br/>
CanHwIsStart(state)&#160;<br/>
This macro returns&#160;TRUE, if the CAN Controller is not in&#160;<br/>stop mode.&#160;<br/>
CanHwIsStop(state)&#160;<br/>
This macro returns&#160;TRUE, if the CAN Controller is in stop&#160;<br/>mode.&#160;<br/>
CanIsOnline(state)&#160;<br/>
This macro returns&#160;TRUE, if the CAN Driver is online.&#160;<br/>
CanIsOffline(state)&#160;<br/>
This macro returns&#160;TRUE, if the CAN Driver is offline.&#160;<br/>
&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
79&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=80></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-80_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
Not all CAN Controllers&#160;support all of the hardware dependent states. Please refer to the&#160;<br/>CAN Controller specific documentation&#160;TechnicalReference_CAN_&lt;hardware&gt;.pdf&#160;<br/>[#hw_status] for details.&#160;<br/>
<b>8.4.4&#160;&#160;Access to low&#160;level&#160;transmit structure&#160;<br/></b>These macros are defined by the CAN driver&#160;to&#160;fill the set the data&#160;to be transmitted with&#160;<br/>CanMsgTransmit():&#160;<br/>CanMsgTransmitSetStdId(&#160;&#160;Write the parameter id in standard format and in logical&#160;<br/>
tCanMsgTransmitStruct&#160;<br/>
presentation&#160;to the structure txData.&#160;<br/>
*txData, vuint16 id)&#160;<br/>CanMsgTransmitSetExtId(&#160;&#160;Write the parameter id in extended format and in logical&#160;<br/>
tCanMsgTransmitStruct&#160;<br/>
presentation&#160;to the structure txData.&#160;<br/>
*txData, vuint32 id)&#160;<br/>CanMsgTransmitSetDlc(&#160;<br/>
Write the DLC in logical&#160;presentation&#160;(0..8)&#160;<br/>
tCanMsgTransmitStruct&#160;<br/>*txData, vuint8 dlc)&#160;<br/>CanMsgTransmitSetData(&#160;<br/>
Write the data bytes to be transmitted to the structure&#160;<br/>
tCanMsgTransmitStruct&#160;<br/>
txData. nrDataBytes specifies the number of bytes to be&#160;<br/>
*txData, vuint8&#160;<br/>
copied (e.g.&#160;same as the DLC, max.&#160;8). txDataBytes&#160;<br/>
nrDataByte, vuint8&#160;<br/>
points to the&#160;current location where the data has to be&#160;<br/>
*txDataBytes)&#160;<br/>
copied from.&#160;<br/>
&#160;<br/>
<b>8.5&#160;</b><br/>
<b>Functions&#160;</b><br/>
This chapter contains a description of the CAN Driver functions (services, callbacks and&#160;<br/>user specifics) and the appropriate parameters&#160;and return codes.&#160;The function declarations&#160;<br/>are given in C syntax as explained below:&#160;<br/>vuint8 CanTransmit( CanTransmitHandle txObject );&#160;<br/>
&#160;&#160;vuint8 is the type of the return code&#160;<br/>
&#160;&#160;CanTransmit is the name of the function&#160;<br/>
&#160;&#160;CanTransmitHandle is the type of the function parameter&#160;<br/>
&#160;&#160;txObject is the function parameter.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
80&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=81></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-81_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-81_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-81_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-81_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-81_5.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>8.5.1&#160;&#160;Service Functions&#160;</b><br/>
<b>8.5.1.1&#160;&#160;CanInitPowerOn&#160;</b><br/>
<b>CanInitPowerOn</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanInitPowerOn</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanInitPowerOn()&#160;initializes&#160;the CAN&#160;Controller and the&#160;CAN Drivers internal&#160;<br/>
variables.&#160;The CAN Driver is always&#160;set&#160;to online mode and active&#160;operating state.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;&#160;This&#160;service function has to be called before any&#160;other CAN Driver&#160;function.&#160;The interrupts have to&#160;<br/>
be disabled&#160;during this&#160;service function is called.&#160;<br/>
&#160;&#160;For indexed&#160;CAN Drivers&#160;every channel is initialized&#160;with kCanInitObj0.&#160;<br/>&#160;<br/>
<b>8.5.1.2&#160;</b><br/>
<b>CanInit&#160;</b><br/>
<b>CanInit</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanInit</b>&#160;( CanInitHandle initObject )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanInit</b>&#160;( CanChannelHandle channel, CanInitHandle &#160;&#160;&#160;<br/>&#160; &#160; &#160; &#160; initObject&#160;)&#160;<br/>
<b>Parameter&#160;</b><br/>
initObject&#160;<br/>
Handle of an&#160;initialization&#160;structure.&#160;The generated&#160;macros should be&#160;<br/>used: &#160;<br/>kCanInitObjX&#160;&#160;(with X = 1 ... Number&#160;of generated initialization structures)&#160;<br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>Initialization of&#160;the CAN Controller&#160;hardware. It is used&#160;to cancel pending transmit&#160;requests in the CAN&#160;<br/>Controller transmit register&#160;and to change the&#160;baud rate or the hardware acceptance filters.&#160;<br/>Online/Offline&#160;mode and&#160;Active/Passive state will not be&#160;changed.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
81&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=82></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-82_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-82_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-82_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-82_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-82_5.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-82_6.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-82_7.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;&#160;During the call of&#160;CanInit(..), the CAN Driver&#160;has to be in offline&#160;mode.&#160;<br/>
&#160;&#160;CanInit(..)&#160;is not reentrant and therefore must not be called recursively.&#160;<br/>
&#160;&#160;CanInit(..)&#160;must not be&#160;interrupted by&#160;CanReset...(..),&#160;CanSleep(..),&#160;CanWakeUp(..)&#160;<br/>
or by any CAN interrupt service routine&#160;and vice versa.&#160;<br/>
&#160;&#160;CanInit(..)&#160;must not interrupt the confirmation&#160;interrupt and must not be called in the&#160;<br/>
confirmation&#160;or indication function.&#160;<br/>
&#160;<br/>
<b>8.5.1.3&#160;&#160;CanTransmit&#160;</b><br/>
<b>CanTransmit</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
vuint8&#160;<b>CanTransmit&#160;</b>( CanTransmitHandle txObject )&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
txObject&#160;<br/>
Handle of the transmit object&#160;<br/>
<b>Return code&#160;</b><br/>
kCanTxOk &#160;<br/>
The transmit&#160;request was&#160;accepted&#160;by the CAN&#160;Driver&#160;&#160;<br/>
kCanTxFailed&#160;<br/>
Error code because one of the following conditions:&#160;<br/>
&#160;&#160;Transmit request could not&#160;be passed to&#160;the CAN Controller because&#160;<br/>
the transmit registers are busy (only if &#160;there is&#160;no transmit queue&#160;<br/>used)&#160;<br/>
&#160;&#160;CAN Driver's&#160;transmit path&#160;is in offline mode&#160;<br/>
&#160;&#160;Special hardware conditions of the CAN Controller (e.g. the sleep&#160;<br/>
mode was entered; failed synchronization&#160;on the CAN bus)&#160;<br/>
kCanTxPartOffline&#160;<br/>
Error code because the transmit path&#160;of the CAN driver is in&#160;partial&#160;<br/>offline mode for this transmit object.&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanTransmit(..)&#160;checks if a transmit register in the CAN Controller is&#160;<br/>available. If so, the transmit process is&#160;initiated in the CAN Controller and&#160;kCanTxOk&#160;is&#160;returned. If not&#160;<br/>
and if there is no transmit queue&#160;configured, the function call returns with the error code&#160;<br/>kCanTxFailed&#160;or&#160;kCanTxPartOffline. For a CAN Driver&#160;with&#160;a configured transmit queue; the&#160;<br/>transmit request is marked&#160;in the queue&#160;and&#160;kCanTxOk&#160;is&#160;returned. Only the transmit request is&#160;saved&#160;<br/>
but not the associated data.&#160;As soon as&#160;one of&#160;the CAN Controller transmit registers becomes&#160;<br/>available (successful transmission of the previous&#160;transmit request), the next transmit request&#160;with the&#160;<br/>highest priority&#160;(lowest CAN identifier)&#160;in&#160;the transmit queue&#160;will be&#160;serviced.&#160;<br/>By the parameter&#160;txObject&#160;all information for transmission (CAN identifier,&#160;DLC, location&#160;and length&#160;<br/>
of data, etc...) can be taken from the CAN Driver&#160;description data.&#160;They will be copied to the CAN&#160;<br/>Controller and the transmit&#160;process is&#160;started.&#160;The message will be actually transmitted on the CAN&#160;<br/>bus after a successful arbitration of the&#160;CAN protocol.&#160;<br/>After a successful transmission a&#160;CAN&#160;message (at least one other CAN bus node gives an&#160;<br/>acknowledge) the confirmation notification (a flag will be set or&#160;a user specific function will be called)&#160;<br/>are executed&#160;in the scope&#160;of the&#160;CAN transmit interrupt routine.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
82&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=83></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-83_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;&#160;CanTransmit(..)&#160;supports&#160;the&#160;Network Management which can enable or disable the CAN&#160;<br/>
Driver's transmit path by means of&#160;the CAN Driver&#160;service functions&#160;CanOnline()&#160;and&#160;<br/>CanOffline(). No distinction is made&#160;between&#160;Network Management and&#160;Application messages.&#160;<br/>
In the offline mode, the transmit request&#160;is rejected with an error&#160;code.&#160;<br/>
&#160;&#160;For CAN Controllers with priority controlled transmit queue (hardware or&#160;software) the sequence of&#160;<br/>
transmission may deviate from the call sequence of&#160;CanTransmit(..)&#160;because the transmit&#160;<br/>
queues are handled&#160;according to priorities (lowest CAN identifier first) and not according to the&#160;<br/>chronological&#160;order of the entries&#160;in the queue (FIFO).&#160;<br/>
&#160;&#160;The generated handles&#160;should be used to reference the transmit objects.&#160;The names&#160;consist of the&#160;<br/>
message symbol, a prefix&#160;and a postfix. Fixed rules&#160;are used to build these names. For more&#160;<br/>details&#160;please&#160;refer to the user manual of the Generation&#160;Tool&#160;<br/>
&#160;<br/>
<b>8.5.1.4&#160;</b><br/>
<b>CanTask&#160;</b><br/>
<b>CanTask</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanTask</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanTask()&#160;does&#160;polling of error events, receive objects, transmit objects&#160;and&#160;<br/>
wake-up events&#160;in the CAN Controller&#160;according to&#160;the configured&#160;polling mode.&#160;In multiple channel&#160;<br/>drivers the&#160;CanTask()&#160;handles&#160;all channels.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;CanTask()&#160;must not run on higher priority than other CAN functions.&#160;<br/>
&#160;&#160;CanTask()&#160;is available, if&#160;any polling mode is&#160;configured for the CAN Driver&#160;&#160;<br/>
&#160;&#160;CanTask()&#160;is also available for some&#160;CAN Controllers&#160;if cancellation in hardware is configured.&#160;<br/>
See more about that in the CAN Controller specific&#160;documentation&#160;<br/>TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_cancel] &#160;.&#160;<br/>
&#160;<br/>
<b>8.5.1.5&#160;&#160;CanTxTask&#160;</b><br/>
<b>CanTxTask</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanTxTask</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanTxTask</b>&#160;( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
83&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=84></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-84_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanTxTask()&#160;does polling of transmit objects&#160;in the CAN Controller.&#160;<br/>
Confirmation&#160;functions will&#160;be called and&#160;confirmation&#160;flags will be&#160;set. If the transmit queue is&#160;<br/>configured, this service function additionally transmits&#160;the queued messages.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;CanTxTask()&#160;is available,&#160;if the general&#160;polling mode&#160;or&#160;the transmit polling mode is&#160;configured.&#160;<br/>
&#160;&#160;CanTxTask()&#160;is also available for some&#160;CAN Controllers if cancellation in hardware is&#160;configured.&#160;<br/>
See more about that in the CAN Controller specific&#160;documentation&#160;<br/>TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_cancel] &#160;.&#160;<br/>
&#160;<br/>
<b>8.5.1.6&#160;</b><br/>
<b>CanRxFullCANTask&#160;</b><br/>
<b>CanRxFullCanTask</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanRxFullCANTask</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanRxFullCANTask</b>&#160;( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanRxFullCanTask()&#160;does polling of Full CAN receive objects&#160;(if available)&#160;<br/>
according to the configured&#160;polling mode.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;CanRxFullCanTask()&#160;must not run on&#160;higher priority than other&#160;CAN functions.&#160;<br/>
&#160;&#160;CanRxFullCanTask()&#160;is available if the Full CAN receive polling mode is&#160;configured.&#160;<br/>&#160;<br/>
<b>8.5.1.7&#160;</b><br/>
<b>CanRxBasicCANTask&#160;</b><br/>
<b>CanRxBasicCANTask</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanRxBasicCANTask</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanRxBasicCANTask</b>&#160;( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanRxBasicCANTask()&#160;does&#160;polling of Basic CAN&#160;receive objects&#160;according to&#160;<br/>
the configured&#160;polling mode.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
84&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=85></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-85_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;CanRxBasicCANTask()&#160;must not run on higher priority than other CAN functions.&#160;<br/>
&#160;&#160;CanRxBasicCANTask()&#160;is available if the Basic CAN&#160;receive polling mode is&#160;configured.&#160;<br/>&#160;<br/>&#160;<br/><b>8.5.1.8&#160;</b><br/>
<b>CanErrorTask&#160;</b><br/>
<b>CanErrorTask</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanErrorTask</b>&#160;( void )&#160;<br/>
&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanErrorTask</b>&#160;( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanErrorTask()&#160;does polling&#160;of error events in the CAN&#160;Controller.&#160;In case of a&#160;<br/>BusOff, the callback&#160;function&#160;ApplCanBusOff()&#160;is&#160;called by this&#160;service function.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;CanErrorTask()&#160;is available if the error polling is enabled.&#160;<br/>&#160;<br/>
<b>8.5.1.9&#160;</b><br/>
<b>CanWakeUpTask&#160;</b><br/>
<b>CanWakeUpTask</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanWakeUpTask</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanWakeUpTask</b>&#160;( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanWakeUpTask()&#160;does polling of the wake-up events in&#160;the CAN Controller&#160;<br/>
according to the enabled polling mode. In case of&#160;a wake-up event on the CAN bus, the callback&#160;<br/>function&#160;ApplCanWakeUp()&#160;will be called by this service function.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;CanWakeUpTask()&#160;is available if the wakeup&#160;polling is&#160;enabled.&#160;<br/>
&#160;&#160;A&#160;wake-up by the CAN bus is not supported by&#160;all CAN Controllers. Please refer&#160;to the CAN&#160;<br/>
controller specific documentation&#160;TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_sleep].&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
85&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=86></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-86_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;<br/>
<b>8.5.1.10&#160;&#160;CanOnline&#160;</b><br/>
<b>CanOnline</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanOnline</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanOnline</b>&#160;( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanOnline()&#160;enables&#160;the CAN Driver's&#160;transmit path for all subsequent transmit&#160;<br/>requests&#160;of&#160;CanTransmit(..).&#160;This is&#160;prerequisite to&#160;transmit any CAN message.&#160;<br/>The current status of the transmit&#160;path can be queried&#160;by&#160;CanGetStatus().&#160;<br/>For indexed&#160;CAN Driver, this functionality is related to the specified CAN&#160;channel.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>If a Network&#160;Management is used, the service function&#160;CanOnline()&#160;may only be used&#160;by the&#160;<br/>
Network Management.&#160;<br/>It is only allowed to call&#160;CanOnline()&#160;on&#160;Task level. No other&#160;CAN Driver&#160;service function&#160;is allowed&#160;<br/>
to be interrupted by&#160;CanOnline().&#160;<br/>&#160;<br/>
<b>8.5.1.11&#160;&#160;CanOffline&#160;</b><br/>
<b>CanOffline</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanOffline</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanOffline</b>&#160;( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanOffline()&#160;disables the&#160;CAN Driver's&#160;transmit&#160;path for all subsequent&#160;<br/>transmit requests&#160;of&#160;CanTransmit(..).&#160;<br/>While the transmit path is&#160;blocked, transmit requests&#160;by&#160;CanTransmit(..)&#160;are rejected with an&#160;<br/>
error.&#160;This&#160;can be determined by evaluating the return&#160;code.&#160;<br/>The current status of the transmit&#160;path can be queried&#160;by CanGetStatus(). &#160;<br/>For indexed&#160;CAN Driver, this functionality is related to the specified CAN&#160;channel.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
86&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=87></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-87_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-87_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-87_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-87_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-87_5.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-87_6.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-87_7.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
If the CAN Driver is configured to use a transmit&#160;queue, all queue entries&#160;will be&#160;cleared, i.e. transmit&#160;<br/>requests&#160;will&#160;be lost.&#160;<br/>If a Network&#160;Management is used, the service functions&#160;CanOffline()&#160;may only be used by&#160;the&#160;<br/>
Network Management.&#160;<br/>&#160;<br/>
<b>8.5.1.12&#160;&#160;CanPartOnline&#160;</b><br/>
<b>CanPartOnline</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanPartOnline</b>&#160;( vuint8 sendGroup )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanPartOnline</b>&#160;( CanChannelHandle channel, vuint8 &#160;&#160;&#160;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;sendGroup&#160;)&#160;<br/>
<b>Parameter&#160;</b><br/>
sendGroup&#160;<br/>
Send group or&#160;groups&#160;to be&#160;switched&#160;to online.&#160;<br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanPartOnline()&#160;enables&#160;the&#160;CAN Driver's&#160;transmit path&#160;for the selected send&#160;<br/>
groups. &#160;<br/>The current status of the partial offline mode can be&#160;queried by&#160;CanGetPartMode().&#160;<br/>For indexed&#160;CAN Driver, this functionality is related to the specified CAN&#160;channel.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;<br/>&#160;<br/>
<b>8.5.1.13&#160;&#160;CanPartOffline&#160;</b><br/>
<b>CanPartOffline</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanPartOffline</b>&#160;( vuint8 sendGroup )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanPartOffline</b>&#160;( CanChannelHandle channel, vuint8 &#160;&#160;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160;sendGroup&#160;)&#160;<br/>
<b>Parameter&#160;</b><br/>
sendGroup&#160;<br/>
Send group or&#160;groups&#160;to be&#160;switched&#160;to offline.&#160;<br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;</b><br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
87&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=88></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-88_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-88_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-88_3.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
The service function&#160;CanPartOffline()&#160;disables the CAN&#160;Driver's transmit path for the selected&#160;<br/>
send&#160;groups. &#160;<br/>While the transmit path is&#160;blocked for a selected&#160;group, transmit requests of a message assigned to&#160;<br/>this group by&#160;CanTransmit(..)&#160;are rejected&#160;with&#160;kCanPartOffline.&#160;This can&#160;be determined by&#160;<br/>
evaluating the return code.&#160;<br/>The current status of the partial offline mode can be&#160;queried by&#160;CanGetPartMode().&#160;<br/>For indexed&#160;CAN Driver, this functionality is related to the specified CAN&#160;channel.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;A&#160;queued message will&#160;be still&#160;send&#160;after the function&#160;CanPartOffline()&#160;was called.&#160;<br/>&#160;<br/>
<b>8.5.1.14&#160;&#160;CanGetPartMode &#160;</b><br/>
<b>CanGetPartMode</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
vuint8&#160;<b>CanGetPartMode</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
vuint8&#160;<b>CanGetPartMode</b>&#160;( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
vuint8&#160;<br/>
Send groups&#160;which are in partial offline&#160;mode. &#160;<br/>
&#160;&#160;C_SEND_GRP_NONE&#160;(if the partial&#160;mode is inactive)&#160;<br/>
&#160;&#160;C_SEND_GRP_ALL&#160;(if the partial&#160;mode is active for all groups.)&#160;<br/>
NOTE: predefined macros can be used to check for all or&#160;none&#160;<br/>send groups.&#160;<br/>
For indexed&#160;CAN Driver, this functionality is related to the specified CAN&#160;<br/>channel. &#160;<br/><a href="TechnicalReference_CANDrivers.html#35">See also&#160;5.2.6&#160;Partial Offline Mode&#160;</a>page&#160;<a href="TechnicalReference_CANDrivers.html#35">35&#160;</a><br/>
<b>Functional Description&#160;<br/></b>Reads the&#160;current partial offline status&#160;of the CAN Driver.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;<br/>&#160;<br/>
<b>8.5.1.15&#160;&#160;CanGetStatus&#160;</b><br/>
<b>CanGetStatus</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
vuint8&#160;<b>CanGetStatus</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
vuint8&#160;<b>CanGetStatus</b>&#160;( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
88&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=89></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-89_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-89_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-89_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-89_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-89_5.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-89_6.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-89_7.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-89_8.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-89_9.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Return code&#160;</b><br/>
vuint8&#160;<br/>
Software status of the CAN Driver.&#160;The&#160;following information is&#160;coded in&#160;<br/>the return code:&#160;<br/>
&#160;&#160;CAN Driver is&#160;offline (CanOffline()&#160;was called)&#160;<br/>If extended status is enabled, this function also returns the hardware&#160;<br/>status&#160;of the CAN Controller.&#160;The following additional&#160;information are&#160;<br/>coded in the return code:&#160;<br/>
&#160;&#160;Warning level,&#160;Error-Active/-Passive state and Bus-Off of the CAN&#160;<br/>
Controller&#160;<br/>
&#160;&#160;CAN Controller is in&#160;sleep&#160;mode (CanSleep()&#160;was&#160;called)&#160;<br/>
&#160;&#160;CAN Controller is in&#160;stop&#160;mode (CanStop()&#160;was&#160;called)&#160;<br/>There are&#160;special macros&#160;to get this information in the return code.&#160;<br/>These macros&#160;are&#160;TRUE&#160;(not equal to 0)&#160;if the specific&#160;condition is valid&#160;<br/>and&#160;FALSE&#160;(equal to 0) if not.&#160;The parameter of these macros&#160;is the&#160;<br/>status, i.e. the return code&#160;of&#160;CanGetStatus():&#160;<br/>&#160;&#160;CanHwIsWarning(..), CanHwIsPassive(..),&#160;<br/>
CanHwIsBusOff(..),&#160;<br/>
&#160;&#160;CanHwIsOk(..)&#160;<br/>
&#160;&#160;CanHwIs Sleep(..), CanHwIsWakeup(..)&#160;<br/>
&#160;&#160;CanHwIsStop(..), CanHwIsStart(..)&#160;<br/>
&#160;&#160;CanIsOffline(..), CanIsOnline(..)&#160;<br/>For indexed&#160;CAN Driver, this functionality is related to the specified CAN&#160;<br/>channel.&#160;<br/>
<b>Functional Description&#160;<br/></b>Reads the&#160;current status&#160;of the&#160;CAN Driver and the&#160;CAN Controller.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;<br/>&#160;<br/>
<b>8.5.1.16&#160;&#160;CanSleep&#160;</b><br/>
<b>CanSleep</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
vuint8&#160;<b>CanSleep</b>&#160;(void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
vuint8&#160;<b>CanSleep</b>&#160;( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;<br/></b>Result of the sleep request:&#160;<br/>
kCanFailed&#160;<br/>
Sleep mode&#160;not entered&#160;&#160;<br/>
kCanOk&#160;<br/>
Sleep mode&#160;entered&#160;<br/>
kCanNotSupported&#160;<br/>
The function&#160;CanSleep&#160;is not supported&#160;by this driver&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanSleep()&#160;puts&#160;the CAN Controller into&#160;sleep mode.&#160;This&#160;reduces the&#160;power&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
89&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=90></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-90_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-90_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-90_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-90_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-90_5.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-90_6.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-90_7.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-90_8.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-90_9.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
consumption&#160;of the CAN Controller&#160;and enables the&#160;wake up behavior if the CAN Controller supports&#160;<br/>this functionality.&#160;For indexed CAN&#160;Driver, this functionality is related to the specified CAN channel.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;&#160;This functionality is not supported for all&#160;CAN Controllers. In such case the function is provided&#160;by&#160;<br/>
the CAN Driver but without any effect on the CAN Controller.&#160;This is&#160;done to enable the&#160;Application&#160;<br/>to realize an&#160;orthogonal&#160;software structure.&#160;<br/>
&#160;&#160;If it is supported by the CAN Controller,&#160;on a&#160;wake-up&#160;by the CAN bus, the callback function&#160;<br/>
ApplCanWakeUp()&#160;is called.&#160;<br/>
&#160;&#160;If a message&#160;is currently transmitted or&#160;received&#160;during the call of this service function, a direct&#160;<br/>
wake-up interrupt occurs or the CAN Driver remains in this function until the sleep mode is entered.&#160;<br/>This behavior of the CAN Controller has to be considered&#160;in implementing the&#160;Application or the&#160;<br/>Network Management. (This behavior is&#160;hardware dependent and described more detailed in the&#160;<br/>CAN controller specific&#160;documentation&#160;TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_sleep])&#160;<br/>
&#160;&#160;If the sleep mode is not entered, no&#160;CAN wake-up&#160;interrupt occurs on&#160;the detection&#160;of any&#160;<br/>
message on the CAN bus.&#160;The callback&#160;function&#160;ApplCanWakeUp()&#160;will not be called and in&#160;<br/>
consequence the bus transceiver&#160;will&#160;not&#160;be initialized.&#160;This leads to&#160;CAN bus errors.&#160;Therefore it is&#160;<br/>necessary to call a set of functions to realize a&#160;wake-up capable system.&#160;The order of the function&#160;<br/>calls is very important.&#160;<a href="TechnicalReference_CANDrivers.html#1">more…&#160;</a><br/>
&#160;&#160;During the call of&#160;CanSleep()&#160;the CAN Driver&#160;has to be offline.&#160;<br/>
&#160;&#160;CanSleep()&#160;must not be interrupted by&#160;CanInit(),&#160;CanReset...(),&#160;CanWakeUp()&#160;or any&#160;<br/>
CAN interrupt routine and vice versa.&#160;<br/>
&#160;&#160;CanSleep(..)&#160;is not reentrant and therefore must not be called&#160;recursively.&#160;<br/>
&#160;&#160;It isn’t allowed to call&#160;CanSleep()&#160;out of any callback function.&#160;<br/>
&#160;&#160;CAN Interrupts&#160;should be disabled during the call of&#160;CanSleep().&#160;To&#160;disable the Can Interrupts&#160;<br/>
the function&#160;CanCanInterruptDisable()&#160;should not be used. If&#160;this function&#160;is used no&#160;CAN&#160;<br/>
wake-up interrupt occurs on&#160;the detection&#160;of&#160;any message on the&#160;CAN bus.&#160;The callback function&#160;<br/>ApplCanWakeUp()&#160;will not be called.&#160;<br/>
&#160;&#160;In Sleep mode the service&#160;functions&#160;CanGetStatus(),&#160;CanWakeUp(),&#160;CanTransmit(),&#160;<br/>
CanTask() and all Can...Task()&#160;are allowed to be called.&#160;<br/>
&#160;<br/>
<b>8.5.1.17&#160;&#160;CanWakeUp&#160;</b><br/>
<b>CanWakeUp</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
vuint8&#160;<b>CanWakeUp</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
vuint8&#160;<b>CanWakeUp</b>&#160;( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;<br/></b>Result&#160;of&#160;the wakeup&#160;request&#160;<br/>
kCanFailed&#160;<br/>
wakeup&#160;was&#160;not&#160;successful&#160;<br/>
kCanOk&#160;<br/>
Sleep mode&#160;left&#160;<br/>
kCanNotSupported&#160;<br/>
The function&#160;CanWakeUp&#160;is not supported by this driver.&#160;<br/>
<b>Functional Description&#160;</b><br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
90&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=91></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-91_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-91_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-91_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-91_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-91_5.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-91_6.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-91_7.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-91_8.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-91_9.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
The service function&#160;CanWakeUp()&#160;enters the&#160;normal operating&#160;mode of the&#160;CAN Controller.&#160;<br/>For indexed&#160;CAN Driver, this functionality is related to the specified CAN&#160;channel.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;&#160;This functionality is not supported for all&#160;CAN Controllers. In such case the function is provided&#160;by&#160;<br/>
the CAN Driver but without any effect on the CAN Controller.&#160;This is&#160;done to enable the&#160;Application&#160;<br/>to realize an&#160;orthogonal&#160;software structure.&#160;<br/>
&#160;&#160;During the call of&#160;CanWakeUp()&#160;the CAN Driver&#160;has to be offline.&#160;<br/>
&#160;&#160;No wake-up interrupt is generated&#160;by the call of&#160;CanWakeUp().&#160;<br/>
&#160;&#160;CanWakeUp()&#160;must not be&#160;interrupted by&#160;CanInit(),&#160;CanReset...(),&#160;CanSleep()&#160;or any&#160;<br/>
CAN interrupt routine and vice versa.&#160;<br/>
&#160;&#160;CanWakeUp(..)&#160;is not reentrant and therefore must not be called recursively.&#160;<br/>&#160;<br/>
<b>8.5.1.18&#160;&#160;CanStart&#160;</b><br/>
<b>CanStart</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
vuint8&#160;<b>CanStart</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
vuint8&#160;<b>CanStart</b>&#160;( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;<br/></b>Result of the stop request&#160;<br/>
kCanFailed&#160;<br/>
Restart of the&#160;CAN controller was not&#160;successful.&#160;<br/>
kCanOk&#160;<br/>
Stop mode left&#160;<br/>
kCanNotSupported&#160;<br/>
The function&#160;CanStart()&#160;is not supported by this driver.&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanStart()&#160;enters the normal&#160;operating&#160;mode of the CAN Controller.&#160;<br/>CanStart()&#160;may not be called in sleep&#160;mode.&#160;<br/>For indexed&#160;CAN Driver, this functionality is related to the specified CAN&#160;channel.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;&#160;This functionality is not supported for all&#160;CAN Controllers. In such case the function is provided&#160;by&#160;<br/>
the CAN Driver but without any effect on the CAN Controller.&#160;This is&#160;done to enable the&#160;Application&#160;<br/>to realize an&#160;orthogonal&#160;software structure.&#160;<br/>
&#160;&#160;During the call of&#160;CanStart()&#160;the CAN Driver&#160;has to be offline.&#160;<br/>
&#160;&#160;CanStart()&#160;must not be interrupted by&#160;CanInit(),&#160;CanReset...(),&#160;CanWakeUp()&#160;or any&#160;<br/>
CAN interrupt routine and vice versa.&#160;<br/>
&#160;&#160;CanStart(..)&#160;is not reentrant and therefore must not be called&#160;recursively.&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
91&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=92></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-92_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-92_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-92_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-92_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-92_5.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-92_6.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-92_7.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-92_8.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-92_9.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>8.5.1.19&#160;&#160;CanStop&#160;</b><br/>
<b>CanStop</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
vuint8&#160;<b>CanStop</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
vuint8&#160;<b>CanStop</b>&#160;( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;<br/></b>Result of the stop request:&#160;<br/>
kCanFailed&#160;<br/>
Stop mode not entered&#160;<br/>
kCanOk&#160;<br/>
Stop mode entered&#160;<br/>
kCanNotSupported&#160;<br/>
The function&#160;CanStop&#160;is not supported&#160;by this driver.&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanStop()&#160;puts the CAN&#160;Controller into stop or hold mode.&#160;This does&#160;not&#160;<br/>
reduces the power consumption of the CAN Controller.&#160;The&#160;stop mode can only be left&#160;by calling&#160;<br/>CanStart().&#160;CanStop()&#160;must not be&#160;called in sleep mode.&#160;<br/>For indexed&#160;CAN Driver, this functionality is related to the specified CAN&#160;channel.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;&#160;This functionality is not supported for all&#160;CAN Controllers. In such case the function is provided&#160;by&#160;<br/>
the CAN Driver but without any effect on the CAN Controller.&#160;This is&#160;done to enable the&#160;Application&#160;<br/>to realize an&#160;orthogonal&#160;software structure.&#160;<br/>
&#160;&#160;During the call of&#160;CanStop()&#160;the CAN&#160;Driver&#160;has to be offline.&#160;<br/>
&#160;&#160;CanStop()&#160;must not be interrupted by&#160;CanInit(),&#160;CanReset...(),&#160;CanWakeUp()&#160;or any&#160;<br/>
CAN interrupt routine and vice versa.&#160;<br/>
&#160;&#160;CanStop(..)&#160;is not reentrant and therefore must not be called recursively.&#160;<br/>&#160;<br/>
<b>8.5.1.20&#160;&#160;CanGlobalInterruptDisable&#160;</b><br/>
<b>CanGlobalInterruptDisable</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanGlobalInterruptDisable</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanGlobalInterruptDisable()&#160;disables&#160;interrupts, either by changing the&#160;<br/>
global interrupt control flag of the microprocessor&#160;or the interrupt level of the interrupt controller.&#160;In the&#160;<br/>later case, the interrupt level is configurable.&#160;All levels where the&#160;CAN&#160;API (CAN&#160;interrupt, Flags,&#160;<br/>service functions) is used&#160;have to be disabled.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
92&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=93></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-93_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Particularities and Limitations&#160;<br/></b>&#160;&#160;This function&#160;has been moved to VstdLib. For more information refer to&#160;Application note-ISC-2-<br/>
1050_VstdLibIntegration.pdf&#160;<br/>
&#160;<br/>
<b>8.5.1.21&#160;&#160;CanGlobalInterruptRestore&#160;</b><br/>
<b>CanGlobalInterruptRestore</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanGlobalInterruptRestore</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanGlobalInterruptRestore()&#160;restores the initial interrupt state which was&#160;<br/>saved temporarily by&#160;CanGlobalInterruptDisable(). If&#160;CanGlobalInterruptDisable()&#160;is&#160;<br/>
called in a nested way,&#160;the initial&#160;interrupt state is not restored until&#160;<br/>CanGlobalInterruptRestore()&#160;has been called&#160;as many times.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;&#160;This function&#160;has been moved to VstdLib. For more&#160;information refer to&#160;Application note&#160;AN-ISC-2-<br/>
1050_VstdLibIntegration.pdf&#160;&#160;<br/>
&#160;<br/>
<b>8.5.1.22&#160;&#160;CanCanInterruptDisable&#160;</b><br/>
<b>CanCanInterruptDisable</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanCanInterruptDisable</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanCanInterruptDisable</b>&#160;( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanCanInterruptDisable()&#160;disables all&#160;CAN interrupts of one CAN channel,&#160;<br/>
either by changing the&#160;CAN interrupt control flags of&#160;the interrupt controller or of&#160;the CAN controller.&#160;In&#160;<br/>case of separately implemented wake-up interrupt&#160;routines they have to be disabled by the&#160;<br/>application.&#160;Therefore the&#160;callback function&#160;ApplCanAddCanInterruptDisable()&#160;can be&#160;<br/>
activated.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
93&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=94></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-94_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;&#160;The CAN Drivers differ in the implementation of&#160;this&#160;service function. Please refer to the CAN&#160;<br/>
Controller specification documentation&#160;TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_int]&#160;for&#160;<br/>details.&#160;<br/>
&#160;&#160;This&#160;service function is not&#160;allowed to be called during Sleep-Mode.&#160;<br/>&#160;<br/>
<b>8.5.1.23&#160;&#160;CanCanInterruptRestore&#160;</b><br/>
<b>CanCanInterruptRestore</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanCanInterruptRestore</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanCanInterruptRestore</b>&#160;( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanCanInterruptRestore()&#160;restores&#160;the initial interrupt&#160;state which&#160;was&#160;<br/>saved temporarily by&#160;CanCanInterruptDisable(). If&#160;CanCanInterruptDisable()&#160;is called in&#160;<br/>a nested way,&#160;the initial interrupt state is&#160;not restored until&#160;CanCanInterruptRestore()&#160;has been&#160;<br/>
called as&#160;many times.&#160;In case&#160;of separately implemented wake-up&#160;interrupt routines they have to be&#160;<br/>restored&#160;by the application.&#160;Therefore the callback function&#160;ApplCanAddCanInterruptRestore()&#160;<br/>can be&#160;activated.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;&#160;The CAN Drivers differ in the implementation of&#160;this&#160;service function. Please refer to the CAN&#160;<br/>
Controller specification documentation&#160;TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_int]&#160;for&#160;<br/>details.&#160;<br/>
&#160;&#160;This&#160;service function is not&#160;allowed to be called during Sleep-Mode.&#160;<br/>&#160;<br/>
<b>8.5.1.24&#160;&#160;CanSetPassive&#160;</b><br/>
<b>CanSetPassive</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanSetPassive</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanSetPassive</b>&#160;( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanSetPassive(..)&#160;switches&#160;the CAN Driver to the passive state.&#160;<br/>For indexed&#160;CAN Driver, this functionality is related to the specified CAN&#160;channel.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
94&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=95></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-95_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-95_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-95_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-95_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-95_5.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Particularities and Limitations&#160;<br/></b>&#160;&#160;If the CAN Driver is configured to use a transmit queue, all queue entries&#160;will be&#160;cleared, i.e.&#160;<br/>
transmit requests&#160;and&#160;subsequent confirmations will&#160;be lost.&#160;<br/>
&#160;&#160;The passive state of the CAN Driver&#160;will&#160;have an&#160;effect only if it is&#160;enabled by the CAN Driver&#160;<br/>
configuration. Nevertheless this service function&#160;is available at any time&#160;<br/>
&#160;<br/>
<b>8.5.1.25&#160;&#160;CanSetActive&#160;</b><br/>
<b>CanSetActive</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanSetActive</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanSetActive</b>&#160;( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanSetActive()&#160;switches&#160;the CAN Driver back to the active state.&#160;<br/>For indexed&#160;CAN Driver, this functionality is related to the specified CAN&#160;channel.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;&#160;The passive state of the CAN Driver&#160;will&#160;have an&#160;effect only if it is&#160;enabled by the CAN Driver&#160;<br/>
configuration. Nevertheless this service function&#160;is available at any time.&#160;<br/>
&#160;<br/>
<b>8.5.1.26&#160;&#160;CanResetBusOffStart&#160;</b><br/>
<b>CanResetBusOffStart</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanResetBusOffStart</b>&#160;( CanInitHandle initObject )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanResetBusOffStart</b>&#160;( CanChannelHandle channel, &#160;&#160;&#160;&#160;&#160;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;CanInitHandle&#160;initObject&#160;)&#160;<br/>
<b>Parameter&#160;</b><br/>
initObject&#160;<br/>
Handle of an&#160;initialization&#160;structure.&#160;The generated&#160;macros should be&#160;<br/>used: &#160;<br/>kCanInitObjX&#160;(with X = 1 ... Number of generated initialization structures)&#160;<br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;</b><br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
95&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=96></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-96_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-96_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-96_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-96_4.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
This&#160;service function starts&#160;error recovery&#160;of the CAN Controller directly after BusOff. Usually a re-<br/>initialization of&#160;the CAN Controller is done.&#160;The correct handling of&#160;a BusOff&#160;depends on the used&#160;<br/>CAN Controller. Please refer to the CAN&#160;Controller specification&#160;documentation&#160;<br/>TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_busoff] for details.&#160;<br/>For indexed&#160;CAN Driver, this functionality is related to the specified CAN&#160;channel.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;During the call of&#160;CanResetBusOffStart(..), the&#160;CAN Driver has to be in offline mode.&#160;<br/>
&#160;&#160;CanResetBusOffStart(..)&#160;is not reentrant and therefore must not be called recursively.&#160;<br/>
&#160;&#160;CanResetBusOffStart()&#160;must not be&#160;interrupted by&#160;CanInit(),&#160;CanResetBusOffEnd(),&#160;<br/>
CanResetBusSleep(),&#160;CanSleep(),&#160;CanWakeUp()&#160;or by any CAN interrupt service&#160;routine&#160;<br/>
and vice versa.&#160;<br/>
&#160;&#160;This&#160;service function can be realized as&#160;a preprocessor macro.&#160;<br/>&#160;<br/>
<b>8.5.1.27&#160;&#160;CanResetBusOffEnd&#160;</b><br/>
<b>CanResetBusOffEnd</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanResetBusOffEnd</b>&#160;( CanInitHandle initObject )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanResetBusOffEnd</b>&#160;( CanChannelHandle channel, &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160;&#160;CanInitHandle&#160;initObject&#160;)&#160;<br/>
<b>Parameter&#160;</b><br/>
initObject&#160;<br/>
Handle of an&#160;initialization&#160;structure.&#160;The generated&#160;macros should be&#160;<br/>used: &#160;<br/>kCanInitObjX&#160;(with X = 1 ... Number of generated initialization structures)&#160;<br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>Completes&#160;the error recovery after BusOff. For most&#160;of the CAN Drivers this service function&#160;has no&#160;<br/>effect.&#160;<br/>For indexed&#160;CAN Driver, this functionality is related to the specified CAN&#160;channel.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;During the call of&#160;CanResetBusOffEnd(..), the CAN Driver&#160;has to be in offline&#160;mode.&#160;<br/>
&#160;&#160;CanResetBusOffEnd(..)&#160;is not reentrant and therefore must not be called recursively.&#160;<br/>
&#160;&#160;CanResetBusOffEnd()&#160;must not be interrupted by&#160;CanInit(),&#160;CanResetBusOffStart(),&#160;<br/>
CanResetBusSleep(),&#160;CanSleep(),&#160;CanWakeUp()&#160;or by any CAN interrupt service&#160;routine&#160;<br/>
and vice versa.&#160;<br/>
&#160;&#160;This&#160;service function can be realized as&#160;a preprocessor macro.&#160;<br/>&#160;<br/>
<b>8.5.1.28&#160;&#160;CanResetBusSleep&#160;</b><br/>
<b>CanResetBusSleep</b><br/>
<b>Prototype&#160;</b><br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
96&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=97></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-97_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-97_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-97_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-97_4.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
Single Receive Channel&#160;<br/>
void&#160;<b>CanResetBusSleep</b>&#160;( CanInitHandle initObject )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanResetBusSleep</b>&#160;( CanChannelHandle channel, &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160;&#160;CanInitHandle&#160;initObject&#160;)&#160;<br/>
<b>Parameter&#160;</b><br/>
initObject&#160;<br/>
Handle of an&#160;initialization&#160;structure.&#160;The generated&#160;macros should be&#160;<br/>used: &#160;<br/>kCanInitObjX&#160;&#160;(with X = 1 ... Number&#160;of generated initialization structures)&#160;<br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;&#160;(with X = 0 ...&#160;Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>This&#160;service function aborts pending transmit requests in the CAN&#160;Controller before the&#160;sleep&#160;mode of&#160;<br/>the CAN Controller is&#160;entered.&#160;This&#160;can&#160;be done&#160;by different ways, depending on&#160;CAN Controller&#160;<br/>specific features:&#160;<br/>
&#160;&#160;Complete re-initialization of&#160;the CAN&#160;Controller (using&#160;the service function&#160;CanInit()&#160;)&#160;<br/>
&#160;&#160;Cancel of the&#160;transmit requests&#160;<br/>Please&#160;refer to the CAN Controller&#160;specific documentation for details.&#160;<br/>For indexed&#160;CAN Driver, this functionality is related to the specified CAN&#160;channel.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;During the call of&#160;CanResetBusSleep(..), the CAN Driver has to&#160;be in offline mode.&#160;<br/>
&#160;&#160;CanResetBusSleep(..)&#160;is not reentrant and therefore must not be called recursively.&#160;<br/>
&#160;&#160;CanResetBusSleep()&#160;must not be interrupted by&#160;CanInit(),&#160;CanResetBusOffStart(),&#160;<br/>
CanResetBusOffEnd(),&#160;CanSleep(),&#160;CanWakeUp()&#160;or by any CAN interrupt service routine&#160;<br/>
and vice versa.&#160;<br/>
&#160;&#160;This&#160;service function can be realized as&#160;a preprocessor macro.&#160;<br/>&#160;<br/>
<b>8.5.1.29&#160;&#160;CanGetDynTxObj&#160;</b><br/>
<b>CanGetDynTxObj</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
CanTransmitHandle&#160;<b>CanGetDynTxObj</b>&#160;( CanTransmitHandle&#160;<br/>
Multiple Receive Channel&#160;<br/>
txObject )&#160;<br/>
<b>Parameter&#160;</b><br/>
txObject&#160;<br/>
Handle of the dynamic&#160;transmit object.&#160;<br/>
<b>Return code&#160;</b><br/>
CanTransmitHandle&#160;<br/>
Handle of the&#160;dynamic transmit object or&#160;kCanNoTxDynObjAvailable&#160;<br/>
if no dynamic transmit object is available&#160;or the specific&#160;dynamic&#160;object&#160;<br/>is already used.&#160;<br/>
<b>Functional Description&#160;</b><br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
97&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=98></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-98_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
Reserves&#160;a dynamic transmit object.&#160;<br/>To&#160;use dynamic transmit&#160;objects&#160;an&#160;Application must&#160;reserve a dynamic transmit object from&#160;the CAN&#160;<br/>Driver.&#160;<br/>Before transmission, the&#160;Application must set all configured dynamic parameters of the dynamic&#160;<br/>transmit object.&#160;<br/>The&#160;Application can use a dynamic transmit object for one or&#160;many&#160;transmissions, but finally it must&#160;<br/>release the dynamic transmit object by calling&#160;CanReleaseDynTxObj(..).&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service function&#160;is only available, if&#160;dynamic transmit objects&#160;are configured.&#160;<br/>
&#160;&#160;The generated handles&#160;should be used to reference the transmit objects.&#160;The names&#160;consist of the&#160;<br/>
message symbol, a prefix&#160;and a postfix. Fixed rules&#160;are used to build these names. For more&#160;<br/>details&#160;please&#160;refer to the online help of the Generation&#160;Tool.&#160;<br/>
&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
98&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=99></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-99_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-99_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-99_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-99_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-99_5.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-99_6.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-99_7.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>8.5.1.30&#160;&#160;CanReleaseDynTxObj&#160;</b><br/>
<b>CanReleaseDynTxObj</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
vuint8&#160;<b>CanReleaseDynTxObj</b>&#160;( CanTransmitHandle txObject )&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
txObject&#160;<br/>
Handle of the&#160;dynamic transmit object which&#160;was returned by&#160;<br/>CanGetDynTxObj(..)&#160;<br/>
<b>Return code&#160;</b><br/>
kCanDynReleased&#160;<br/>
Dynamic&#160;object is released&#160;<br/>
kCanDynNotReleased&#160;<br/>
Dynamic&#160;transmit object couldn’t be released because the object is still&#160;<br/>in the transmit queue or in the transmit&#160;register of the&#160;CAN Controller.&#160;<br/>CanReleaseDynTxObj(..)&#160;has to be&#160;called later again.&#160;<br/>
<b>Functional Description&#160;<br/></b>Release a dynamic transmit object, which was reserved before&#160;by calling&#160;CanGetDynTxObj(..).&#160;<br/>The dynamic&#160;transmit object is referenced by&#160;txObject.&#160;<br/>After a transmission of one or more messages is finished, the&#160;Application has to&#160;release the reserved&#160;<br/>resource, because the number of dynamic&#160;transmit objects&#160;is limited&#160;and the&#160;Application&#160;should&#160;not&#160;<br/>keep reserved dynamic transmit objects&#160;for a longer time.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service function&#160;is only available, if&#160;dynamic transmit objects&#160;are configured.&#160;<br/>
&#160;&#160;The parameter&#160;txObject&#160;was&#160;reserved before by a&#160;call to&#160;CanGetDynTxObj(..).&#160;<br/>&#160;<br/>
<b>8.5.1.31&#160;&#160;CanDynTxObjSetId&#160;</b><br/>
<b>CanDynTxObjSetId</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanDynTxObjSetId</b>&#160;( CanTransmitHandle txObject, vuint16&#160;<br/>
Multiple Receive Channel&#160;<br/>
id )&#160;<br/>
<b>Parameter&#160;</b><br/>
txObject&#160;<br/>
Handle of the&#160;dynamic transmit object which&#160;was returned by&#160;<br/>CanGetDynTxObj(..).&#160;<br/>
id&#160;<br/>
CAN identifier in standard format&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>Sets&#160;the CAN identifier in standard format of a dynamic transmit object.&#160;The dynamic transmit&#160;object is&#160;<br/>referenced by&#160;txObject.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;&#160;This&#160;service function&#160;is only available, if&#160;dynamic transmit objects&#160;are configured.&#160;<br/>
&#160;&#160;The parameter txObject was reserved before by&#160;a call&#160;to CanGetDynTxObj(..).&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
99&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=100></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-100_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-100_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-100_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-100_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-100_5.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-100_6.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-100_7.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-100_8.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-100_9.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-100_10.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>8.5.1.32&#160;&#160;CanDynTxObjSetExtId&#160;</b><br/>
<b>CanDynObjSetExtId</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanDynTxObjSetExtId</b>&#160;( CanTransmitHandle txObject, &#160;&#160;&#160;<br/>
Multiple Receive Channel&#160;<br/>
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;vuint16&#160;idExtHi,&#160;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;vuint16&#160;idExtLo)&#160;<br/>
<b>Parameter&#160;</b><br/>
txObject&#160;<br/>
Handle of the&#160;dynamic transmit object which&#160;was returned by&#160;<br/>CanGetDynTxObj(..)&#160;<br/>
idExtHi&#160;<br/>
Upper 16 bit&#160;of the CAN identifier in extended format&#160;<br/>
idExtLo&#160;<br/>
Lower 16 bit&#160;of the CAN identifier in extended format&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>Sets&#160;the CAN identifier in extended format of a dynamic transmit object.&#160;The dynamic transmit&#160;object&#160;<br/>is&#160;referenced by txObject&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;&#160;This&#160;service function&#160;is only available, if&#160;dynamic transmit objects&#160;are configured.&#160;<br/>
&#160;&#160;The parameter txObject&#160;was&#160;reserved before by a call to&#160;CanGetDynTxObj(..).&#160;<br/>&#160;<br/>
<b>8.5.1.33&#160;&#160;CanDynTxObjSetDlc&#160;</b><br/>
<b>CanDynTxObjSetDlc</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanDynTxObjSetDlc</b>&#160;( CanTransmitHandle txObject,&#160;<br/>
Multiple Receive Channel&#160;<br/>
&#160; &#160; &#160; &#160; &#160; &#160; &#160;&#160;vuint8&#160;dlc&#160;)&#160;<br/>
<b>Parameter&#160;</b><br/>
txObject&#160;<br/>
Handle of the&#160;dynamic transmit object which&#160;was returned by&#160;<br/>CanGetDynTxObj(..)&#160;<br/>
dlc&#160;<br/>
Data&#160;Length&#160;Code&#160;of the dynamic transmit object&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>Sets&#160;the Data&#160;Length Code&#160;of a dynamic transmit object.&#160;The dynamic transmit&#160;object is referenced by&#160;<br/>txObject.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service function&#160;is only available, if&#160;dynamic transmit objects&#160;are configured.&#160;<br/>
&#160;&#160;The parameter txObject&#160;was&#160;reserved before by a call to&#160;CanGetDynTxObj(..).&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
100&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=101></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-101_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-101_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-101_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-101_4.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>8.5.1.34&#160;&#160;CanDynTxObjSetDataPtr&#160;</b><br/>
<b>CanDynTxObjSetDataPtr</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanDynTxObjSetDataPtr</b>&#160;( CanTransmitHandle txObject, &#160;<br/>
Multiple Receive Channel&#160;<br/>
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;&#160;vuint8&#160;*pData&#160;)&#160;<br/>
<b>Parameter&#160;</b><br/>
txObject&#160;<br/>
Handle of the&#160;dynamic transmit object which&#160;was returned by&#160;<br/>CanGetDynTxObj(..)&#160;<br/>
*pData&#160;<br/>
Data&#160;reference of the application&#160;specific&#160;data buffer referenced&#160;by the&#160;<br/>dynamic transmit object&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>Sets&#160;the data&#160;pointer of a dynamic transmit object.&#160;The dynamic&#160;transmit object is&#160;referenced by&#160;<br/>txObject.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;service function&#160;is only available, if&#160;dynamic transmit objects&#160;are configured.&#160;<br/>
&#160;&#160;The parameter txObject&#160;was&#160;reserved before by a call to&#160;CanGetDynTxObj(..).&#160;<br/>&#160;<br/>
<b>8.5.1.35&#160;&#160;CanCancelTransmit&#160;</b><br/>
<b>CanCancelTransmit</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanCancelTransmit</b>&#160;( CanTransmitHandle txObject )&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
txObject&#160;<br/>
Handle of the transmit object&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The call of the confirmation&#160;function resp. setting of&#160;the confirmation flag associated with txObject are&#160;<br/>suppressed, if&#160;this message is already in&#160;the transmit buffer of the CAN controller. &#160;<br/>If the transmit queue is&#160;enabled, a pending transmit request in the queue is&#160;canceled.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>The function call of&#160;CanCancelTransmit()&#160;must&#160;not interrupt the transmit ISR,&#160;CanTransmit()&#160;or&#160;<br/>the&#160;CanTxTask().&#160;<br/>Though a transmission is&#160;canceled it will be sent if the request has been already&#160;in the hardware&#160;<br/>object. Only if activated and highly dependent on hardware and vehicle manufacturer the transmit&#160;<br/>request can be&#160;deleted in the&#160;hardware transmit object, too.&#160;<br/>&#160;<br/>
<b>8.5.1.36&#160;&#160;CanCopyFromCan&#160;</b><br/>
<b>CanCopyFromCan</b><br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
101&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=102></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-102_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-102_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-102_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-102_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-102_5.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-102_6.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-102_7.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-102_8.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-102_9.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-102_10.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-102_11.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-102_12.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-102_13.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanCopyFromCan&#160;</b>(void *dst, CanChipDataPtr src, vuint8&#160;<br/>
Multiple Receive Channel&#160;<br/>
len)&#160;<br/>
<b>Parameter&#160;</b><br/>
dst&#160;<br/>
Pointer to the&#160;destination in default memory.&#160;This&#160;pointer is available in&#160;<br/>the Precopy Function.&#160;<br/>
src&#160;<br/>
Pointer to the&#160;source&#160;CAN&#160;buffer or temporary buffer&#160;<br/>
len&#160;<br/>
number of bytes which have to be copied&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>This function&#160;copies data&#160;from the CAN&#160;data buffer to the RAM.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>This function&#160;can only be used&#160;within precopy functions.&#160;<br/>&#160;<br/><b>8.5.1.37&#160;&#160;CanCopyToCan&#160;</b><br/>
<b>CanCopyToCan</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanCopyToCan&#160;</b>( CanChipDataPtr dst, void *src, vuint8&#160;<br/>
Multiple Receive Channel&#160;<br/>
len)&#160;<br/>
<b>Parameter&#160;</b><br/>
dst&#160;<br/>
Pointer to the&#160;destination CAN buffer or&#160;temporary buffer.&#160;This&#160;pointer is&#160;<br/>available in the Pretransmit&#160;Function.&#160;<br/>
src&#160;<br/>
Pointer to the source&#160;in default memory.&#160;&#160;<br/>
len&#160;<br/>
number of bytes which have to be copied&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>This function&#160;copies data&#160;from the RAM into the CAN&#160;data buffer.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>This function&#160;can only be used&#160;within pretransmit functions.&#160;<br/>&#160;<br/><b>8.5.1.38&#160;&#160;CanTxGetActHandle&#160;</b><br/>
<b>CanTxGetActHandle</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
CanTransmitHandle&#160;<b>CanTxGetActHandle</b>&#160;(CanObjectHandle&#160;<br/>
Multiple Receive Channel&#160;<br/>
logTxHwObject)&#160;<br/>
<b>Parameter&#160;</b><br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
102&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=103></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-103_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
logTxHwObject&#160;<br/>
Handle of the&#160;CAN hardware transmit object. For indexed drivers this is&#160;<br/>a unique number over&#160;all CAN channels.&#160;<br/>
<b>Return code&#160;</b><br/>
txObject&#160;<br/>
Handle of the&#160;transmit object which is&#160;currently in the hardware transmit&#160;<br/>object. In case of enabled&#160;LowLevelMessageTransmit,&#160;this could also be&#160;<br/>a handle of such a message &#160;<br/>kCanBufferMsgTransmit:&#160;CanCancelMsgTransmit&#160;<br/>kCanTxHandleNotUsed:&#160;Handle is not valid&#160;<br/>
<b>Functional Description&#160;<br/></b>This&#160;service functions returns the handle&#160;of the&#160;transmit message, which has been&#160;transmitted in a&#160;<br/>certain CAN&#160;hardware transmit object.&#160;The return value can be used as a&#160;parameter for&#160;<br/>CanCancelTransmit().&#160;If the return value is&#160;kCanBufferMsgTransmit,&#160;<br/>CanCancelMsgTransmit()&#160;has to be&#160;called in stead of&#160;CanCancelTransmit().&#160;<br/>CanCancelTransmit()&#160;ignores invalid handle and&#160;kCanBufferMsgTransmit.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>This function&#160;is only allowed to be called&#160;in or after&#160;ApplCanTxObjStart()&#160;and before&#160;<br/>ApplCanTxObjConfirmed()&#160;of a certain CAN buffer.&#160;<br/>&#160;<br/><b>8.5.1.39&#160;&#160;CanResetMsgReceivedCondition&#160;</b><br/>
<b>CanResetMsgReceivedCondition</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanResetMsgReceivedCondition&#160;</b>( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanResetMsgReceivedCondition&#160;</b>( CanChannelHandle&#160;<br/>channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX &#160;&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanResetMsgReceivedConditional()&#160;disables the&#160;calling of&#160;<br/>ApplCanMsgCondReceived().&#160;<br/>For indexed&#160;CAN Driver, this functionality is related to the specified CAN&#160;channel.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;<br/>&#160;<br/><b>8.5.1.40&#160;&#160;CanSetMsgReceivedCondition&#160;</b><br/>
<b>CanSetMsgReceivedCondition</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanSetMsgReceivedCondition&#160;</b>( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanSetMsgReceivedCondition&#160;</b>( CanChannelHandle channel&#160;<br/>)&#160;<br/>
<b>Parameter&#160;</b><br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
103&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=104></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-104_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX &#160;&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanSetMsgReceivedConditional()&#160;enables the calling&#160;of&#160;<br/>ApplCanMsgCondReceived().&#160;<br/>For indexed&#160;CAN Driver, this functionality is related to the specified CAN&#160;channel.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;<br/>&#160;<br/><b>8.5.1.41&#160;&#160;CanGetMsgReceivedCondition&#160;</b><br/>
<b>CanGetMsgReceivedCondition</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanGetMsgReceivedCondition&#160;</b>( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanGetMsgReceivedCondition&#160;</b>( CanChannelHandle channel&#160;<br/>)&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX &#160;&#160;(with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanGetMsgReceivedConditional()returns the status&#160;of the condition for&#160;<br/>calling&#160;ApplCanMsgCondReceived().&#160;<br/>For indexed&#160;CAN Driver, this functionality is related to the specified CAN&#160;channel.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
104&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=105></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-105_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-105_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-105_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-105_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-105_5.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-105_6.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>8.5.2&#160;&#160;User Specific Functions&#160;<br/></b>The user specific functions listed in this&#160;section are called by&#160;the CAN Driver&#160;and provided&#160;<br/>by the&#160;Application when certain events occur.&#160;The user can define user specific functions&#160;<br/>specifically&#160;for each message.&#160;The names in this section are only placeholders.&#160;The name&#160;<br/>could be set in the generation tool.&#160;The type of&#160;the particular user&#160;specific message must&#160;<br/>agree with the function types listed here.&#160;<br/>
<b>8.5.2.1&#160;</b><br/>
<b>UserPrecopy&#160;</b><br/>
<b>UserPrecopy</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
vuint8&#160;<b>UserPrecopy</b>&#160;( CanRxInfoStructPtr rxStruct )&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
rxStruct&#160;<br/>
Pointer to the receive&#160;structure&#160;<br/>
<b>Return code&#160;</b><br/>
kCanCopyData&#160;<br/>
Received data&#160;will be copied using the&#160;CAN Driver 's internal copy&#160;<br/>mechanism&#160;<br/>
kCanNoCopyData&#160;<br/>
CAN Driver doesn’t copy data&#160;and doesn’t perform indication&#160;<br/>
<b>Functional Description&#160;<br/></b>User specific&#160;function of the CAN Driver, which is&#160;called in the receive interrupt of a CAN message&#160;<br/>before&#160;copying the data from&#160;the CAN&#160;Controller receive register&#160;to the application specific global data&#160;<br/>buffer.&#160;<br/>Depending on the function's return&#160;code, the CAN&#160;Driver will either&#160;terminate the&#160;processing of&#160;the&#160;<br/>received message (kCanNoCopyData) or resume normal processing (kCanCopyData).&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;&#160;For each&#160;CAN message a&#160;separate precopy function&#160;may be defined.&#160;<br/>&#160;<br/>
<b>8.5.2.2&#160;</b><br/>
<b>UserIndication&#160;</b><br/>
<b>UserIndication</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>UserIndication</b>( CanReceiveHandle rxObject)&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
rxObject&#160;<br/>
Handle of the&#160;received&#160;message&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>User specific&#160;function&#160;which is called in the receive interrupt of a CAN message&#160;after data has been&#160;<br/>copied and the CAN Controller receive register&#160;have&#160;been released.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;&#160;For each&#160;CAN message a&#160;separate indication function may be defined.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
105&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=106></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-106_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-106_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-106_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-106_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-106_5.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-106_6.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;<br/>
<b>8.5.2.3&#160;</b><br/>
<b>UserPreTransmit&#160;</b><br/>
<b>UserPreTransmit</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
vuint8 &#160;<b>UserPreTransmit</b>( CanTxInfoStruct txStruct )&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
txStruct&#160;<br/>
Transmit&#160;structure&#160;<br/>
Return code&#160;<br/>
kCanCopyData &#160;<br/>
After the return of this&#160;user&#160;specific&#160;function, the CAN&#160;Driver&#160;copies&#160;the&#160;<br/>data to be transmitted from&#160;the application specific&#160;global data buffer&#160;<br/>associated to&#160;the corresponding message to the CAN Controller transmit&#160;<br/>register&#160;<br/>
kCanNoCopyData&#160;<br/>
The CAN Driver does not copy data but&#160;starts&#160;the transmit request&#160;in the&#160;<br/>CAN Controller immediately&#160;<br/>
<b>Functional Description&#160;<br/></b>User specific&#160;function&#160;which is called before the message is&#160;copied&#160;from the application&#160;specific&#160;data&#160;<br/>buffer to the transmit register of the CAN Controller.&#160;This is done in&#160;the scope of the&#160;Tx interrupt or the&#160;<br/>CanTxTask()&#160;via&#160;CanTransmit(..).&#160;The usage of&#160;the internal&#160;copy&#160;mechanism of the CAN Driver&#160;<br/>
is controlled by the return&#160;code.&#160;<br/>A&#160;possible usage is the acquiring&#160;and&#160;copying of existing data which are spread in&#160;the&#160;Application.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;For each&#160;CAN message a&#160;separate pretransmit function may be defined.&#160;<br/>&#160;<br/>
<b>8.5.2.4&#160;</b><br/>
<b>UserConfirmation&#160;</b><br/>
<b>UserConfirmation</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>UserConfirmation</b>( CanTransmitHandle txObject )&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
txObject&#160;<br/>
Handle of the transmit object&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>User specific&#160;function&#160;which is called in the scope of the CAN transmit interrupt routine or the&#160;<br/>CanTxTask()&#160;after the&#160;message has&#160;been sent on the CAN bus successfully&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;For each&#160;CAN message a&#160;separate&#160;confirmation function may be defined.&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
106&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=107></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-107_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>8.5.3&#160;&#160;Callback Functions&#160;<br/></b>Callback functions are called by the CAN Driver on certain events and have to be provided&#160;<br/>by the&#160;Application. In contrast to the user specific&#160;functions in the section before the&#160;<br/>callback functions are not message related but&#160;only event related.&#160;Their name can also&#160;be&#160;<br/>reconfigured.&#160;<br/>
<b>8.5.3.1&#160;&#160;ApplCanBusOff&#160;</b><br/>
<b>ApplCanBusOff</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanBusOff</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>ApplCanBusOff</b>&#160;( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160; (with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>This&#160;callback function is&#160;called if the CAN Controller&#160;enters BusOff&#160;state.&#160;The function is&#160;called&#160;in the&#160;<br/>error interrupt,&#160;CanTask()&#160;or&#160;CanErrorTask().&#160;<br/><b>Particularities and Limitations&#160;<br/></b>If no Network Management&#160;is used&#160;which provides&#160;a&#160;BusOff&#160;error&#160;handling, the&#160;Application has to do&#160;<br/>the subsequent error handling (usually the re-initialization of the CAN Controller)&#160;by&#160;the CAN&#160;Driver&#160;<br/>service function&#160;CanResetBusOffStart()&#160;and&#160;CanResetBusOffEnd()&#160;itself.&#160;<br/>&#160;<br/>
<b>8.5.3.2&#160;</b><br/>
<b>ApplCanWakeUp&#160;</b><br/>
<b>ApplCanWakeUp</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanWakeUp</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>ApplCanWakeUp</b>&#160;( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;&#160;(with X = 0 ...&#160;Number of&#160;generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>This&#160;callback function is&#160;called if a wake-up condition&#160;on the CAN bus is detected during sleep mode&#160;<br/>of the CAN Controller.&#160;The&#160;function is&#160;called in the wakeup interrupt, in the&#160;CanTask()&#160;or in the&#160;<br/>CanWakeupTask().&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
107&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=108></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-108_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;&#160;If the CAN Controller was&#160;put into sleep&#160;mode by calling the service function&#160;CanSleep(), and&#160;<br/>
afterwards there is a dominant level at the receive input of the CAN Controller,&#160;CAN Controller&#160;<br/>generates a wake-up interrupt.&#160;The CAN Driver&#160;calls the callback function&#160;ApplCanWakeUp()&#160;to&#160;<br/>
handle further wake-up&#160;call&#160;activities, e.g. starting the&#160;Network Management.&#160;<br/>
&#160;&#160;The&#160;Application must assure that the CAN transmit&#160;path is restored to its normal operating state,&#160;<br/>
typically by the activation of&#160;the bus transceiver.&#160;<br/>
&#160;&#160;This wake-up&#160;functionality is not supported by all&#160;CAN Controllers. If there is no power-down mode&#160;<br/>
of the CAN Controller or if the microprocessor&#160;cannot detect an external&#160;wake-up condition by&#160;the&#160;<br/>CAN bus, this callback function will never be called.&#160;<br/>
&#160;<br/>
<b>8.5.3.3&#160;</b><br/>
<b>ApplCanOverrun&#160;</b><br/>
<b>ApplCanOverrun</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanOverrun</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>ApplCanOverrun</b>&#160;( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;&#160;(with X = 0 ...&#160;Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>This&#160;callback function is&#160;called if an overrun in a&#160;Basic CAN receive object was detected. It indicates a&#160;<br/>possible loss&#160;of receive data.&#160;The function&#160;is called in&#160;the error interrupt, in the receive interrupt, in the&#160;<br/>CanTask(),&#160;in the&#160;CanRxTask(),&#160;or in the&#160;CanErrorTask().&#160;<br/><b>Particularities and Limitations&#160;<br/></b>The overrun is&#160;completely handled by the CAN Driver.&#160;This callback function only&#160;notifies the&#160;<br/>Application about such a&#160;condition.&#160;<br/>&#160;<br/>
<b>8.5.3.4&#160;</b><br/>
<b>ApplCanFullCanOverrun&#160;</b><br/>
<b>ApplCanFullCanOverrun</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanFullCanOverrun</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>ApplCanFullCanOverrun</b>&#160;( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;&#160;(with X = 0 ...&#160;Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>This&#160;callback function is&#160;called if an overrun of a&#160;Full CAN receive object&#160;was detected.&#160;It&#160;indicates a&#160;<br/>possible loss&#160;of receive data.&#160;The function&#160;is called in&#160;the error interrupt, in the receive interrupt, in the&#160;<br/>CanTask(), in&#160;the&#160;CanRxTask()&#160;or in the&#160;CanErrorTask().&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
108&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=109></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-109_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-109_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-109_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-109_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-109_5.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-109_6.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-109_7.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-109_8.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-109_9.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Particularities and Limitations&#160;<br/></b>&#160;&#160;The overrun is&#160;completely handled by the CAN Driver.&#160;This callback function only&#160;notifies the&#160;<br/>
Application about an overrun.&#160;<br/>
&#160;<br/>
<b>8.5.3.5&#160;</b><br/>
<b>ApplCanMsgReceived&#160;</b><br/>
<b>ApplCanMsgReceived</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
vuint8&#160;<b>ApplCanMsgReceived</b>( CanRxInfoStructPtr rxStruct )&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
rxStruct&#160;<br/>
Pointer to receive information structure&#160;<br/>
<b>Return code&#160;</b><br/>
kCanCopyData&#160;<br/>
Receive processing&#160;will be continued&#160;<br/>
kCanNoCopyData&#160;<br/>
Receive processing&#160;will be terminated&#160;<br/>
<b>Functional Description&#160;<br/></b>This&#160;callback function is&#160;called on every reception of a CAN message when the hardware acceptance&#160;<br/>filter is passed.&#160;The function&#160;is called in the receive interrupt, in the&#160;CanTask()&#160;or in the&#160;<br/>CanRxTask().&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;&#160;The callback&#160;function may&#160;be used for gateway functionality or any&#160;other purpose.&#160;<br/>
&#160;&#160;There are preprocessor macros&#160;available&#160;to read the CAN identifier,&#160;the Data&#160;Length Code&#160;and&#160;the&#160;<br/>
data in the CAN Controller receive&#160;register.&#160;<br/>
&#160;<br/>
<b>8.5.3.6&#160;</b><br/>
<b>ApplCanRangePrecopy&#160;</b><br/>
<b>ApplCanRangePrecopy</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
vuint8&#160;<b>ApplCanRangePrecopy</b>( CanRxInfoStructPtr rxStruct)&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
rxStruct&#160;<br/>
Pointer to the receive&#160;structure&#160;<br/>
<b>Return code&#160;</b><br/>
kCanCopyData&#160;<br/>
The CAN receive interrupt routine is&#160;continued with verifying a match to&#160;<br/>the next range and ID search.&#160;<br/>
kCanNoCopyData&#160;<br/>
The CAN receive interrupt routine is&#160;terminated immediately after&#160;the&#160;<br/>CAN Controller is&#160;serviced&#160;<br/>
<b>Functional Description&#160;</b><br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
109&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=110></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-110_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
This precopy&#160;function is&#160;not called on a&#160;specific message CAN identifier but on a complete CAN&#160;<br/>identifier range.&#160;The function is called in the receive interrupt, in the&#160;CanTask(),&#160;in the&#160;<br/>CanRxTask()&#160;or in&#160;CanHandleRxMsg().&#160;The return code&#160;is not taken into account, if the range is&#160;<br/>
handled via the RX Queue.&#160;In this case,&#160;the handling of the received message will be terminated after&#160;<br/>calling the range specific precopy function.&#160;<br/>The name of this function&#160;is only a placeholder.&#160;The name could be&#160;set in the generation tool.&#160;<br/>Up to four ranges&#160;with individual precopy&#160;functions can be specified per CAN channel.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;Ranges&#160;are normally used&#160;for Network&#160;Management or&#160;Transport Protocol services&#160;only&#160;<br/>
&#160;&#160;In case a range configured&#160;to be handled&#160;via the&#160;Rx Queue, the return code of this function is&#160;<br/>
ignored.&#160;<br/>
&#160;<br/>
<b>8.5.3.7&#160;</b><br/>
<b>ApplCanAddCanInterruptDisable&#160;</b><br/>
<b>ApplCanAddCanInterruptDisable</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanAddCanInterruptDisable&#160;</b>( CanChannelHandle&#160;<br/>
Multiple Receive Channel&#160;<br/>
channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160; (with X = 0 ... Number of generated channel index)&#160;<br/>In case of Single Receive&#160;Channel&#160;channel&#160;is always 0.&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>Disabling of additional&#160;CAN interrupts&#160;(like separately implemented&#160;Wake-Up interrupts and Polling&#160;<br/>Tasks)&#160;can be added to the standard mechanism of the CAN by this callback function.&#160;The function is&#160;<br/>called on interrupt and task level.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;ApplCanAddCanInterruptDisable()&#160;is only called if configured&#160;<br/>&#160;<br/>
<b>8.5.3.8&#160;</b><br/>
<b>ApplCanAddCanInterruptRestore&#160;</b><br/>
<b>ApplCanAddCanInterruptRestore</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanAddCanInterruptRestore&#160;</b>( CanChannelHandle&#160;<br/>
Multiple Receive Channel&#160;<br/>
channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160; (with X = 0 ... Number of generated channel index)&#160;<br/>In case of Single Receive&#160;Channel&#160;channel&#160;is always 0.&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;</b><br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
110&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=111></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-111_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-111_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-111_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-111_4.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
Complementary callback function for&#160;ApplCanAddCanInterruptDisable().The function&#160;is called&#160;<br/>
on interrupt and task level.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;ApplCanAddCanInterruptRestore()&#160;is only called if configured.&#160;<br/>&#160;<br/>
<b>8.5.3.9&#160;</b><br/>
<b>ApplCanFatalError&#160;</b><br/>
<b>ApplCanFatalError</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanFatalError&#160;</b>( vuint8 errorNumber )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>ApplCanFatalError&#160;</b>( CanChannelHandle channel, vuint8&#160;<br/>errorNumber )&#160;<br/>
<b>Parameter&#160;</b><br/>
errorNumber&#160;<br/>
Error identification:&#160;There is a predefined list with supported assertion&#160;<br/>checks for each CAN Driver.&#160;All the&#160;function parameters&#160;starting with&#160;<br/>kError.... Please&#160;refer to chapter&#160;<a href="TechnicalReference_CANDrivers.html#59">Assertions&#160;a</a>nd the&#160;CAN Controller&#160;<br/>Specific documentation&#160;TechnicalReference_CAN_&lt;hardware&gt;.pdf&#160;<br/>[#hw_assert] for details.&#160;<br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160; (with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>If assertions&#160;are configured, the callback function&#160;ApplCanFatalError(..)&#160;is called in case of&#160;<br/>
invalid user conditions (Application interface, reentrance), inconsistent generated data, hardware&#160;<br/>errors or internal errors (queue).&#160;An error number&#160;is passed by the parameter.&#160;The function is&#160;called on&#160;<br/>interrupt and&#160;task level.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;This&#160;callback function does&#160;not have to return to the CAN Driver.&#160;<br/>&#160;<br/>
<b>8.5.3.10&#160;&#160;ApplCanMsgNotMatched&#160;</b><br/>
<b>ApplCanMsgNotMatched</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanMsgNotMatched&#160;</b>( CanRxInfoStructPtr rxStruct )&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
rxStruct&#160;<br/>
Pointer to the receive&#160;structure&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>This&#160;callback function is&#160;called if a CAN message passes&#160;the hardware acceptance filter, but&#160;not the&#160;<br/>software filter (inclusive the&#160;identifier specific predefined ranges).&#160;The function&#160;is called in the&#160;receive&#160;<br/>interrupt, in the&#160;CanTask()&#160;or in the&#160;CanRxTask().&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
111&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=112></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-112_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-112_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-112_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-112_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-112_5.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-112_6.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-112_7.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-112_8.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-112_9.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Particularities and Limitations&#160;<br/></b>&#160;<br/>&#160;<br/>
<b>8.5.3.11&#160;&#160;ApplCanInit&#160;</b><br/>
<b>ApplCanInit</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanInit</b>( CanObjectHandle logTxHwObjectFirstUsed,&#160;<br/>&#160;&#160;&#160;&#160; &#160; &#160; &#160;&#160;CanObjectHandle&#160;logTxHwObjectFirstUnused)&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>ApplCanInit</b>( CanChannelObject channel,&#160;<br/>&#160;&#160;&#160;&#160; &#160; &#160; &#160;&#160;CanObjectHandle&#160;logTxHwObjectFirstUsed,&#160;<br/>
&#160;&#160;&#160;&#160; &#160; &#160; &#160;&#160;CanObjectHandle&#160;logTxHwObjectFirstUnused)&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;&#160;(with X = 0 ... Number&#160;of generated&#160;channel index)&#160;<br/>
logTxHwObjectFirstUsed&#160;<br/>
Handle of the&#160;first CAN hardware transmit object of the current channel.&#160;<br/>
logTxHwObjectFirstUnused&#160;Handle of the&#160;first unused&#160;CAN hardware transmit object of the current&#160;<br/>
channel.&#160;<br/>example: &#160;<br/>for ( i = logTxHwObjectFirstUsed; i &lt;&#160;<br/>logTxHwObjectFirstUnused; i++)&#160;<br/>{&#160;<br/>&#160;/* loop over all used hardware transmit buffer of&#160;<br/>
the current&#160;<br/>
&#160; &#160; channel */&#160;<br/>}&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>This&#160;callback function is&#160;called in&#160;CanInit()&#160;for general purposes. In&#160;CanInit()&#160;transmit requests in&#160;<br/>
the CAN Controller are canceled.&#160;This means the corresponding confirmation notification will never&#160;<br/>occur.&#160;User defined actions started in&#160;ApplCanTxObjStart()&#160;have to be stopped in&#160;<br/>ApplCanInit().The function is called&#160;on interrupt and task level.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>This&#160;callback is active only&#160;if ‘Tx&#160;observe’&#160;functionality is activated.&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
112&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=113></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-113_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-113_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-113_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-113_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-113_5.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-113_6.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-113_7.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-113_8.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-113_9.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-113_10.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-113_11.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>8.5.3.12&#160;&#160;ApplCanTxObjStart&#160;</b><br/>
<b>ApplCanTxObjStart</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanTxObjStart</b>( CanObjectHandle logTxHwObject)&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>ApplCanTxObjStart</b>( CanChannelHandle channel,&#160;<br/>CanObjectHandle logTxHwObject)&#160;<br/>
<b>Parameter&#160;<br/></b>channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160; (with X = 0 ... Number of generated channel index)&#160;<br/>
logTxHwObject&#160;<br/>
Handle of the&#160;CAN buffer transmit object.&#160;For indexed&#160;drivers this is&#160;a&#160;<br/>unique number over all&#160;CAN channels.&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>This&#160;callback function is&#160;called every time, a transmit request is initiated in the CAN Controller.&#160;This is&#160;<br/>done in the&#160;service&#160;CanTransmit(..).The function&#160;is called in the transmit interrupt, in the&#160;<br/>CanTask()&#160;or in the&#160;CanTxTask(), if&#160;the transmit queue is&#160;enabled.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>This&#160;callback is active only&#160;if ‘Tx&#160;observe’&#160;functionality is activated.&#160;<br/>&#160;<br/>
<b>8.5.3.13&#160;&#160;ApplCanTxObjConfirmed&#160;</b><br/>
<b>ApplCanTxObjConfirmed</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanTxObjConfirmed</b>( CanObjectHandle logTxHwObject)&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>ApplCanTxObjConfirmed</b>&#160;(CanChannelHandle channel,&#160;<br/>CanObjectHandle logTxHwObject)&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160; (with X = 0 ... Number of generated channel index)&#160;<br/>
logTxHwObject&#160;<br/>
Handle of the&#160;CAN buffer transmit object.&#160;For indexed&#160;drivers this is&#160;a&#160;<br/>unique number over all&#160;CAN channels.&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>This&#160;callback function is&#160;called every time, a successful transmission is confirmed by the CAN&#160;<br/>Controller in the scope of a transmit interrupt, in the&#160;CanTask()&#160;or in the&#160;CanTxTask().&#160;<br/><b>Particularities and Limitations&#160;<br/></b>This&#160;callback is active only&#160;if ‘Tx&#160;observe’&#160;functionality is activated.&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
113&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=114></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-114_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-114_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-114_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-114_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-114_5.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-114_6.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-114_7.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-114_8.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-114_9.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-114_10.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-114_11.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-114_12.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-114_13.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-114_14.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>8.5.3.14&#160;&#160;ApplCanTimerStart&#160;</b><br/>
<b>ApplCanTimerStart</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanTimerStart</b>(vuint8 timerIdentification)&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>ApplCanTimerStart</b>(CanChannelObject channel, vuint8&#160;<br/>timerIdentification)&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160; (with X = 0 ... Number of generated channel index)&#160;<br/>
timerIdentification&#160;<br/>
Identifier for the hardware dependent loop timer&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>This&#160;callback function is&#160;called before a CAN Controller dependent&#160;loop is started. &#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;<br/>&#160;<br/>
<b>8.5.3.15&#160;&#160;ApplCanTimerLoop&#160;</b><br/>
<b>ApplCanTimerLoop</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
vuint8&#160;<b>ApplCanTimerLoop</b>(vuint8 timerIdentification)&#160;<br/>
Multiple Receive Channel&#160;<br/>
vuint8&#160;<b>ApplCanTimerLoop</b>(CanChannelObject channel, vuint8&#160;<br/>timerIdentification)&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160; (with X = 0 ... Number of generated channel index)&#160;<br/>
timerIdentification&#160;<br/>
Identifier for the hardware dependent loop timer&#160;<br/>
<b>Return code&#160;</b><br/>
FALSE (equal to 0)&#160;<br/>
Exit loop, even&#160;if hardware is not correct&#160;&#160;<br/>
TRUE (not equal to 0)&#160;<br/>
Continue with&#160;waiting for hardware condition&#160;<br/>
<b>Functional Description&#160;<br/></b>This&#160;callback function is&#160;called once in every loop cycle, i.e. multiple times for a&#160;specific&#160;condition.&#160;&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
114&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=115></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-115_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-115_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-115_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-115_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-115_5.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-115_6.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-115_7.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-115_8.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-115_9.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-115_10.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-115_11.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>8.5.3.16&#160;&#160;ApplCanTimerEnd&#160;</b><br/>
<b>ApplCanTimerEnd</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanTimerEnd</b>(vuint8 timerIdentification)&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>ApplCanTimerEnd</b>(CanChannelObject channel, vuint8&#160;<br/>timerIdentification)&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160; (with X = 0 ... Number of generated channel index)&#160;<br/>
timerIdentification&#160;<br/>
Identifier for the hardware dependent loop timer&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>This&#160;callback function is&#160;called after a hardware dependent loop is&#160;finished, due to return value&#160;also of&#160;<br/>ApplCanTimerLoop or hardware condition met.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;<br/>&#160;<br/>
<b>8.5.3.17&#160;&#160;ApplCanGenericPrecopy&#160;</b><br/>
<b>ApplCanGenericPrecopy</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
vuint8&#160;<b>ApplCanGenericPrecopy</b>(CanRxInfoStructPtr rxStruct)&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
rxStruct&#160;<br/>
Pointer to the receive&#160;structure&#160;<br/>
<b>Return code&#160;</b><br/>
kCanCopyData&#160;<br/>
The UserPrecopy function&#160;will be called&#160;and the Received data&#160;will be&#160;<br/>copied using&#160;the CAN Driver’s&#160;internal&#160;copy mechanism.&#160;<br/>
kCanNoCopyData&#160;<br/>
CAN Driver doesn’t copy data&#160;and doesn’t perform indication&#160;<br/>
<b>Functional Description&#160;<br/></b>This precopy&#160;function is&#160;common to all receive messages. It will be called immediately after the DLC-<br/>check.&#160;The call of the&#160;UserPrecopy&#160;functions or&#160;copy of data are&#160;influenced by&#160;<br/>ApplCanGenericPrecopy().&#160;The function is&#160;called&#160;in the receive interrupt, in the&#160;CanTask()&#160;or in&#160;<br/>the&#160;CanRxTask().&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;<br/>&#160;<br/>
<b>8.5.3.18&#160;&#160;ApplCanPreWakeup&#160;</b><br/>
<b>ApplCanPreWakeup</b><br/>
<b>Prototype&#160;</b><br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
115&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=116></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-116_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-116_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-116_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-116_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-116_5.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanPreWakeUp</b>( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>ApplCanPreWakeUp</b>(CanChannelHandle channel)&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160; (with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>Is called just&#160;after the activation of the wakeup interrupt. &#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;<br/>&#160;<br/>
<b>8.5.3.19&#160;&#160;ApplCanTxConfirmation&#160;</b><br/>
<b>ApplCanTxConfirmation</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanTxConfirmation</b>( CanTxInfoStructPtr txStruct)&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
txStruct&#160;<br/>
Pointer to transmit structure&#160;<br/>&#160;<br/>typedef struct &#160;<br/>
{&#160;<br/>
&#160; CanChannelHandle &#160; Channel;&#160;<br/>
&#160; CanTransmitHandle &#160;Handle;&#160;<br/>
} tCanTxConfInfoStruct;&#160;<br/>
&#160;<br/>
typedef tCanTxConfInfoStruct &#160; &#160; &#160;<br/>*CanTxInfoStructPtr;&#160;<br/>
Handle:&#160;&#160;<br/>- 0 ... (kCanNumberOfTxMessages-1):&#160;the handle of the&#160;Tx message.&#160;<br/>-&#160;kCanBufferMsgTransmit,&#160;in case the message was sent via&#160;<br/>
CanCancelMsgTransmit().&#160;<br/>-&#160;((CanTransmitHandle)0xFFFFFFFEU)&#160;<br/>in case the message was cancel by CanCanTransmit() or&#160;<br/>CanCancelMsgTransmit()&#160;but sent on the bus&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>This&#160;confirmation function is&#160;common to&#160;all transmit messages. It will be called after the successful&#160;<br/>transmission.&#160;The function&#160;is called in the transmit interrupt, in the&#160;CanTask()&#160;or in the&#160;<br/>CanTxTask().&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
116&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=117></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-117_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-117_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-117_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-117_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-117_5.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;<br/>
<b>8.5.3.20&#160;&#160;ApplCanMsgDlcFailed&#160;</b><br/>
<b>ApplCanMsgDlcFailed</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanMsgDlcFailed</b>( CanRxInfoStructPtr rxStruct )&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
rxStruct&#160;<br/>
Pointer to the receive&#160;structure&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>This&#160;callback function is&#160;called, if the DLC check fails.&#160;To&#160;activate this&#160;callback&#160;function the switch&#160;<br/>C_ENABLE_DLC_FAILED_FCT&#160;has to be&#160;set in a user&#160;configuration file.&#160;The function is&#160;called&#160;in the&#160;<br/>receive interrupt, in the&#160;CanTask()&#160;or in the&#160;CanRxTask().&#160;<br/><b>Particularities and Limitations&#160;<br/></b>It depends on the OEM if ApplCanMsgDlcFailed()&#160;is available.&#160;<br/>&#160;<br/>
<b>8.5.3.21&#160;&#160;ApplCanCancelNotification&#160;</b><br/>
<b>ApplCanCancelNotification</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanCancelNotification</b>(CanTransmitHandle txHandle)&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
txHandle&#160;<br/>
Handle of cancelled transmit object&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>This function&#160;will be called&#160;if a&#160;transmit message is deleted (<a href="TechnicalReference_CANDrivers.html#101">CanCancelTransmit, CanOf</a>fline or&#160;<br/>CanInit).&#160;This&#160;function could be called in&#160;Interrupt or&#160;Task context.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>ApplCanCancelNotification()&#160;is only called if configured.&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
117&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=118></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-118_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-118_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-118_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-118_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-118_5.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-118_6.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-118_7.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-118_8.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-118_9.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>8.5.3.22&#160;&#160;ApplCanOnline&#160;</b><br/>
<b>ApplCanOnline</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanOnline</b>(CanChannelHandle channel)&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
channel&#160;<br/>
CAN Channel&#160;on which the&#160;CAN driver&#160;was switched&#160;to online mode.&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
- &#160;<br/>
<b>Functional Description&#160;<br/></b>This&#160;callback function indicates that the CAN driver&#160;is switched to online mode.&#160;This function is called&#160;<br/>by the CAN Driver if the mode change is&#160;initiated via&#160;CanOnline().&#160;<br/><b>Particularities and Limitations&#160;<br/>Call context</b>:&#160;This&#160;function is&#160;called within&#160;CanOnline().&#160;This service function&#160;is only allowed to be&#160;<br/>
called on task level.&#160;<br/>&#160;<br/>
<b>8.5.3.23&#160;&#160;ApplCanOffline&#160;</b><br/>
<b>ApplCanOffline</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanOffline</b>(CanChannelHandle channel)&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
channel&#160;<br/>
CAN Channel&#160;on which the&#160;CAN driver&#160;was switched&#160;to offline mode.&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
- &#160;<br/>
<b>Functional Description&#160;<br/></b>This&#160;callback function indicates that the CAN driver&#160;is switched to offline mode.&#160;This function is called&#160;<br/>by the CAN Driver if the mode change is&#160;initiated via&#160;CanOffline().&#160;<br/><b>Particularities and Limitations&#160;<br/>Call context</b>:&#160;This&#160;function is&#160;called within&#160;CanOffline().&#160;This&#160;service function is&#160;allowed to&#160;be&#160;<br/>
called on task level or&#160;on interrupt level.&#160;<br/>&#160;<br/>
<b>8.5.3.24&#160;&#160;ApplCanMsgCondReceived&#160;</b><br/>
<b>ApplCanMsgCondReceived</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanMsgCondReceived&#160;</b>(CanRxInfoStructPtr rxStruct)&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
rxStruct&#160;<br/>
Pointer to the&#160;receive information structure&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
118&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=119></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-119_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-119_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-119_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-119_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-119_5.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-119_6.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-119_7.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
- &#160;<br/>
<b>Functional Description&#160;<br/></b>This&#160;callback function is&#160;conditionally called on every reception of a CAN message when the hardware&#160;<br/>acceptance filter is passed.&#160;<br/>There are preprocessor macros&#160;available&#160;to read the CAN identifier,&#160;the Data&#160;Length Code&#160;and&#160;the&#160;<br/>data in the CAN Controller receive&#160;register.&#160;<br/><b>Particularities and Limitations&#160;<br/>Call context</b>:&#160;The function&#160;is called in the receive interrupt, in the&#160;CanTask()&#160;or in the&#160;<br/>CanRxTask().&#160;<br/>&#160;<br/>
<b>8.5.3.25&#160;&#160;ApplCanMemCheckFailed&#160;</b><br/>
<b>ApplCanMemCheckFailed</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
vuint8&#160;<b>ApplCanMemCheckFailed&#160;</b>( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
vuint8&#160;<b>ApplCanMemCheckFailed&#160;</b>( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
Channel&#160;<br/>
Handle of the&#160;CAN channel&#160;on which the&#160;check failed.&#160;The generated&#160;<br/>macros&#160;should be used:&#160;<br/><b>kCanIndexX</b>&#160; (with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
kCanEnableCommunication&#160;&#160;Allow communication.&#160;&#160;<br/>
kCanDisableCommunication&#160;Disable&#160;communication, no&#160;reception&#160;and no transmission is performed.&#160;<br/><b>Functional Description&#160;<br/></b>This&#160;callback function is&#160;called if the CAN driver&#160;has found at least one corrupt&#160;memory bit within the&#160;<br/>CAN mailboxes.&#160;The application&#160;can decide if the CAN driver&#160;allows further communication by&#160;means&#160;<br/>of the return&#160;value.&#160;<br/><b>Particularities and Limitations&#160;<br/>Call context</b>:&#160;This function is called on task level or within the busoff interrupt.&#160;<br/>&#160;<br/>
<b>8.5.3.26&#160;&#160;ApplCanCorruptMailbox&#160;</b><br/>
<b>ApplCanCorruptMailbox</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanCorruptMailbox&#160;</b>( CanObjectHandle hwObjHandle )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>ApplCanCorruptMailbox&#160;</b>( CanChannelHandle channel, &#160;&#160;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160; CanObjectHandle&#160;hwObjHandle&#160;)&#160;<br/>
<b>Parameter&#160;</b><br/>
hwObjHandle&#160;<br/>
The index of the corrupt mailbox.&#160;<br/>
channel&#160;<br/>
Handle of the&#160;CAN channel on which the&#160;corrupt mailbox is located.&#160;The&#160;<br/>generated&#160;macros should be&#160;used:&#160;<br/><b>kCanIndexX</b>&#160; (with X = 0 ... Number of generated channel index)&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
119&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=120></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-120_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-120_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-120_3.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
- &#160;<br/>
<b>Functional Description&#160;<br/></b>This&#160;callback function is&#160;called if the&#160;CAN driver&#160;has found a&#160;corrupt mailbox.&#160;<br/><b>Particularities and Limitations&#160;<br/>Call context</b>:&#160;This function is called on task level or within the busoff interrupt.&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
120&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=121></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-121_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>9&#160;&#160;Description of the&#160;API (High End extension)&#160;</b><br/>
<b>9.1&#160;&#160;Functions&#160;</b><br/>
<b>9.1.1&#160;&#160;Service Functions&#160;</b><br/>
<b>9.1.1.1&#160;&#160;CanTxObjTask&#160;</b><br/>
<b>CanTxObjTask</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanTxObjTask</b>&#160;( CanObjectHandle txObjHandle )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanTxObjTask</b>&#160;( CanChannelHandle canHwChannel,&#160;<br/>CanObjectHandle txObjHandle )&#160;<br/>
<b>Parameter&#160;</b><br/>
canHwChannel&#160;<br/>
Handle of a CAN Hardware&#160;channel.&#160;The&#160;generated macros&#160;should&#160;be&#160;<br/>used:&#160;<br/>Normal Tx&#160;Object:&#160;<br/>C_TX_NORMAL_&lt;channel&gt;_HW_CHANNEL&#160;(with &lt;channel&gt; = 0 ... Number&#160;<br/>
of logical channel)&#160;<br/>Full CAN&#160;Tx&#160;Object:&#160;<br/>&lt;message name&gt;_HW_CHANNEL&#160;(with &lt;message name&gt; = Name of the&#160;<br/>
Message with pre and postfixes generated in&#160;“can_par.h”t)&#160;<br/>Low Level&#160;Tx Object:&#160;<br/>C_TX_LL_&lt;channel&gt;_HW_CHANNEL&#160;(with&#160;&lt;channel&gt; = 0 ... Number of&#160;logical&#160;<br/>
channel)&#160;<br/>
txObjHandle&#160;<br/>
Handle of a&#160;Tx mailbox.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>Normal Tx&#160;Object:&#160;<br/>C_TX_NORMAL_&lt;channel&gt;_HW_OBJ&#160;(with &lt;channel&gt; =&#160;0 ... Number&#160;of&#160;<br/>
logical channel)&#160;<br/>Full CAN&#160;Tx&#160;Object:&#160;<br/>&lt;message name&gt;_HW_OBJ&#160;(with &lt;message name&gt; = Name of the Message&#160;with&#160;<br/>
pre and postfixes&#160;generated in “can_par.h”)&#160;<br/>Low Level&#160;Tx Object:&#160;<br/>C_TX_LL_&lt;channel&gt;_HW_OBJ&#160;(with &lt;channel&gt; = 0 ... Number of logical&#160;<br/>
channel)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanTxObjTask()&#160;does polling&#160;of specified transmit hardware objects&#160;in&#160;the&#160;<br/>
CAN controller. Confirmation functions&#160;will be called&#160;and confirmation flags&#160;will be set. If the transmit&#160;<br/>queue is configured, this service function&#160;additionally transmits&#160;the&#160;queued messages.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;CanTxObjTask()&#160;is available, if the individual polling mode and at&#160;least one mailbox is configured&#160;<br/>
for polling.&#160;<br/>
&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
121&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=122></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-122_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>9.1.1.2&#160;&#160;CanRxFullCANObjTask&#160;</b><br/>
<b>CanRxFullCANObjTask</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanRxFullCANObjTask</b>&#160;(CanObjectHandle rxObjHandle )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanRxFullCANObjTask</b>&#160;( CanChannelHandle canHwChannel,&#160;<br/>CanObjectHandle rxObjHandle )&#160;<br/>
<b>Parameter&#160;</b><br/>
canHwChannel&#160;<br/>
Handle of a CAN Hardware&#160;channel.&#160;The&#160;generated macros&#160;should&#160;be&#160;<br/>used:&#160;<br/>&lt;message name&gt;_HW_ CHANNEL&#160;(with&#160;&lt;message name&gt; = Name of the&#160;<br/>
Message with pre and postfixes generated in&#160;“can_par.h”)&#160;<br/>
rxObjHandle&#160;<br/>
Handle of an&#160;Rx mailbox.&#160;The&#160;generated&#160;macros&#160;should be used:&#160;<br/>&lt;message name&gt;_HW_OBJ&#160;(with &lt;message name&gt; = Name of the Message&#160;<br/>
with pre and&#160;postfixes generated in “can_par.h”t)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanRxFullCANObjTask()&#160;does polling of specified Full CAN receive objects&#160;<br/>
according to the configured&#160;objects&#160;in polling mode.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;CanRxFullCANObjTask()&#160;must not run on higher priority than other CAN functions.&#160;<br/>
&#160;&#160;CanRxFullCANObjTask()&#160;is available,&#160;if the individual polling mode and at least one mailbox&#160;is&#160;<br/>
configured&#160;for polling.&#160;<br/>
&#160;<br/>
<b>9.1.1.3&#160;</b><br/>
<b>CanRxBasicCANObjTask&#160;</b><br/>
<b>CanRxBasicCANObjTask</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanRxBasicCANObjTask</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanRxBasicCANObjTask</b>&#160;(CanChannelHandle canHwChannel,&#160;<br/>CanObjectHandle rxObjHandle )&#160;<br/>
<b>Parameter&#160;</b><br/>
canHwChannel&#160;<br/>
Handle of a CAN Hardware&#160;channel.&#160;The&#160;generated macros&#160;should&#160;be&#160;<br/>used:&#160;<br/>C_BASIC&lt;number_of_the_BasicCAN&gt;_&lt;channel&gt;HW_CHANNEL&#160;<br/>
(with &lt;number_of_the_BasicCAN&gt;= the logical number of the Basic CAN on this&#160;<br/>channel&#160;<br/>&lt;channel&gt; = 0 ... Number of&#160;logical channel)&#160;<br/>
txObjHandle&#160;<br/>
Handle of a Rx mailbox.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>C_BASIC&lt;number_of_the_BasicCAN&gt;_&lt;channel&gt;_HW_OBJ&#160;<br/>
(with&#160;<br/>&#160;&lt;number_of_the_BasicCAN&gt;= the logical&#160;number of the Basic CAN on this channel&#160;<br/>&lt;channel&gt; = 0 ... Number of&#160;logical channel)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;</b><br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
122&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=123></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-123_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-123_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-123_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-123_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-123_5.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-123_6.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-123_7.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-123_8.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-123_9.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
The service function&#160;CanRxBasicCANObjTask()&#160;does polling of&#160;specified Basic&#160;CAN receive&#160;<br/>
objects&#160;according to the configured&#160;objects&#160;in polling&#160;mode.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;CanRxBasicCANObjTask()&#160;must not run on higher&#160;priority than other CAN functions.&#160;<br/>
&#160;&#160;CanRxBasicCANObjTask()&#160;is available, if the individual polling mode and at least one mailbox is&#160;<br/>
configured&#160;for polling.&#160;<br/>
&#160;<br/><b>9.1.1.4&#160;</b><br/>
<b>CanMsgTransmit&#160;</b><br/>
<b>CanMsgTransmit</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
vuint8&#160;<b>CanMsgTransmit</b>&#160;( tCanMsgTransmitStruct *txData )&#160;<br/>
Multiple Receive Channel&#160;<br/>
vuint8&#160;<b>CanMsgTransmit</b>&#160;( CanChannelHandle channel, &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<br/>&#160; &#160; &#160; &#160; &#160; &#160; &#160;tCanMsgObject&#160;*txData&#160;)&#160;<br/>
<b>Parameter&#160;</b><br/>
*txData&#160;<br/>
Pointer to the structure&#160;with ID, DLC and data to send&#160;<br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/><b>kCanIndexX</b>&#160; (with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
kCanTxOk&#160;<br/>
if the message-buffer is free&#160;and the data could be copied to the CAN-<br/>data-buffer or&#160;if &#160;passive mode (CanSetPassive()) is&#160;active.&#160;<br/>
kCanTxFailed&#160;<br/>
if offline mode is active, the CAN buffer is not free.&#160;<br/>
<b>Functional Description&#160;<br/></b>This function&#160;is called by the application.&#160;The function sends the message&#160;which is&#160;defined in the&#160;<br/>txData&#160;(Id, DLC, Data) to the CAN-Bus which is defined in the channel.&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
&#160;&#160;the contents&#160;of txData&#160;may not be changed while&#160;CanMsgTransmit()&#160;is running&#160;<br/>&#160;<br/>
<b>9.1.1.5&#160;</b><br/>
<b>CanCancelMsgTransmit&#160;</b><br/>
<b>CanCancelMsgTransmit</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanCancelMsgTransmit</b>( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>CanCancelMsgTransmit</b>( CanChannelHandle channel )&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160;&#160;(with X = 0 ... Number&#160;of generated&#160;channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The call of&#160;ApplCanMsgTransmitConf()&#160;is suppressed, if a message is already in the transmit&#160;<br/>buffer of the CAN controller associated&#160;with&#160;CanMsgTransmit(). Dependent&#160;on the configuration&#160;<br/>
this function&#160;cancels a message in the CAN hardware.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
123&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=124></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-124_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Particularities and Limitations&#160;<br/></b>The function call of&#160;CanCancelTransmit()&#160;must&#160;not interrupt the transmit ISR,&#160;<br/>CanMsgTransmit()&#160;or the&#160;CanTxTask().&#160;<br/>Though a transmission is&#160;canceled it will be sent if the request has been already&#160;in the hardware&#160;<br/>object. Only if activated and highly dependent on hardware and vehicle manufacturer the transmit&#160;<br/>request which is initiated&#160;with&#160;CanMsgTransmit()&#160;can be deleted in the hardware transmit&#160;object,&#160;<br/>too. The&#160;function&#160;CanCancelMsgTranmit()&#160;is only available if the confirmation&#160;<br/>ApplCanMsgTransmitConf()&#160;is configured.&#160;<br/>&#160;<br/>
<b>9.1.1.6&#160;</b><br/>
<b>CanHandleRxMsg&#160;</b><br/>
<b>CanHandleRxMsg</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanHandleRxMsg</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanHandleRxMsg()&#160;handles&#160;the received messages&#160;which are stored in the Rx&#160;<br/>
Queue.&#160;The standard mechanism&#160;(GenericPrecopy,&#160;UserPrecopy,&#160;copy of data, Indication&#160;Flag&#160;and&#160;<br/>UserIndication) is&#160;started for each stored message.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>This function&#160;is only allowed to be called&#160;on task level.&#160;<br/>&#160;<br/><b>9.1.1.7&#160;</b><br/>
<b>CanDeleteRxQueue&#160;</b><br/>
<b>CanDeleteRxQueue</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>CanDeleteRxQueue</b>&#160;( void )&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>The service function&#160;CanDeleteRxQueue()&#160;clears&#160;all pending&#160;messages in the Rx Queue.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>This function&#160;is only allowed to be called&#160;on task level.&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
124&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=125></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-125_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-125_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-125_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-125_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-125_5.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-125_6.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-125_7.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-125_8.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-125_9.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>9.1.2&#160;&#160;Callback Functions&#160;</b><br/>
<b>9.1.2.1&#160;</b><br/>
<b>ApplCanMsgTransmitConf&#160;</b><br/>
<b>ApplCanMsgTransmitConf</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanMsgTransmitConf</b>( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>ApplCanMsgTransmitConf</b>(CanChannelHandle channel)&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160; (with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>This function&#160;will be called&#160;from the CAN Driver after&#160;sending&#160;the message. It is called directly in the&#160;<br/>transmit Interrupt (Confirmation)&#160;from the CAN-Controller.&#160;On task level it is called in the&#160;CanTask()&#160;<br/>or in the&#160;CanTxTask().&#160;With this callback function&#160;it is possible&#160;to implement&#160;a queue-functionality.&#160;&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
ApplCanMsgTransmitConf()&#160;is only called if&#160;configured.&#160;<br/>&#160;<br/>
<b>9.1.2.2&#160;</b><br/>
<b>ApplCanMsgTransmitInit&#160;</b><br/>
<b>ApplCanMsgTransmitInit</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanMsgTransmitInit</b>( void )&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>ApplCanMsgTransmitInit</b>(CanChannelHandle channel)&#160;<br/>
<b>Parameter&#160;</b><br/>
channel&#160;<br/>
Handle of a CAN channel.&#160;The generated&#160;macros&#160;should be used:&#160;<br/>kCanIndexX&#160; (with X = 0 ... Number of generated channel index)&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>This function&#160;will be called&#160;from the CAN Driver after a&#160;possible&#160;cancel of a transmit request in&#160;<br/>CanInit().&#160;<br/><b>Particularities and Limitations&#160;</b><br/>
ApplCanMsgTransmitInit()&#160;is only called if&#160;ApplCanMsgTransmitConf()&#160;is configured.&#160;<br/>&#160;<br/>
<b>9.1.2.3&#160;</b><br/>
<b>ApplCanMsgCancelNotification&#160;</b><br/>
<b>ApplCanMsgCancelNotification</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanMsgCancelNotification</b>( void )&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
125&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=126></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-126_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-126_2.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-126_3.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-126_4.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-126_5.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-126_6.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
Multiple Receive Channel&#160;<br/>
void&#160;<b>ApplCanMsgCancelNotification</b>( CanChannelHandle channel&#160;<br/>)&#160;<br/>
<b>Parameter&#160;</b><br/>
Channel&#160;<br/>
CAN Channel&#160;on which the&#160;Tx Object was cancelled.&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Functional Description&#160;<br/></b>This function&#160;will be called&#160;if a&#160;transmit message is deleted (<a href="TechnicalReference_CANDrivers.html#101">CanCancelMsgTransmit). It appl</a>ies only&#160;<br/>to&#160;Tx messages that have&#160;been transmitted via&#160;<a href="TechnicalReference_CANDrivers.html#101">CanMsgTransmit.&#160;</a>This function could be&#160;called in&#160;<br/>Interrupt or&#160;Task&#160;context.&#160;<br/><b>Particularities and Limitations&#160;<br/></b>&#160;ApplCanMsgCancelNotification()&#160;is only called if configured.&#160;<br/>&#160;<br/><b>9.1.2.4&#160;</b><br/>
<b>ApplCanPreRxQueue&#160;</b><br/>
<b>ApplCanPreRxQueue</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
vuint8&#160;<b>ApplCanPreRxQueue</b>( CanRxInfoStructPtr rxStruct )&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
rxStruct&#160;<br/>
Pointer to receive information structure&#160;<br/>
<b>Return code&#160;</b><br/>
kCanCopyData&#160;<br/>
The data of the received&#160;message will&#160;be stored in the Rx Queue. &#160;<br/>
kCanNoCopyData&#160;<br/>
The data of the received&#160;message are&#160;not stored in the Rx Queue.&#160;The&#160;<br/>reception is&#160;handled&#160;within&#160;the receive interrupt.&#160;<br/>
<b>Functional Description&#160;<br/></b>This precopy&#160;function is&#160;called if a message is received which is&#160;a valid message in the receive&#160;<br/>structures or&#160;has to be handled via a range (in case&#160;the use of the&#160;Rx Queue is&#160;configured&#160;for this&#160;<br/>range ).&#160;The&#160;application&#160;can decide whether to handle&#160;the message&#160;via the Rx Queue or&#160;the standard&#160;<br/>CAN Driver&#160;mechanism within the receive interrupt.&#160;<br/><b>Particularities and Limitations&#160;<br/>Call context</b>:&#160;This&#160;function is&#160;called within the receive interrupt.&#160;<br/>&#160;<br/>
<b>9.1.2.5&#160;</b><br/>
<b>ApplCanRxQueueOverrun&#160;</b><br/>
<b>ApplCanRxQueueOverrun</b><br/>
<b>Prototype&#160;<br/></b>Single Receive Channel&#160;<br/>
void&#160;<b>ApplCanRxQueueOverrun</b>( void )&#160;<br/>
Multiple Receive Channel&#160;<br/><b>Parameter&#160;</b><br/>
-&#160;<br/>
-&#160;<br/>
<b>Return code&#160;</b><br/>
-&#160;<br/>
- &#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
126&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=127></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-127_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Functional Description&#160;<br/></b>This&#160;callback function indicates an overrun of the Rx&#160;Queue.&#160;This function&#160;is called by the CAN Driver,&#160;<br/>in case a new message has&#160;to be stored&#160;in the Rx&#160;Queue, but the Queue if full.&#160;This new message&#160;will&#160;<br/>be lost.&#160;<br/><b>Particularities and Limitations&#160;<br/>Call context</b>:&#160;This&#160;function is&#160;called within the receive interrupt.&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
127&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=128></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-128_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-128_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>10&#160;&#160;Configuration (Standard and High End)&#160;</b><br/>
This chapter describes the common options for configuring (customizing) the CAN Driver.&#160;<br/>CAN Controller dependent configuration is described in the CAN Controller specific&#160;<br/>documentation TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_conf].&#160;The configuration&#160;<br/>can be done by the Generation&#160;Tool automatically. &#160;<br/>
<b>10.1&#160;&#160;Network Database – Attribute Definition&#160;</b><br/>
<b>Caution&#160;<br/></b>Attribute names in CANgen are case sensitive and not evaluated, if the name case is&#160;<br/>
&#160;&#160;incorrect.<b>&#160;</b><br/>
&#160;<br/>
<b>Name&#160;</b><br/>
<b>GenMsgMinAcceptLength&#160;</b><br/>
<b>Description&#160;</b><br/>
The DLC check can be&#160;configured to verify the received DLC against the value&#160;<br/>given by this attribute (Against minimum acceptance length).&#160;The value can be&#160;<br/>smaller than the&#160;Application receive&#160;buffer of this message.&#160;<br/>Value “-1” means the DLC of the received message will be compared to&#160;the&#160;<br/>length of the&#160;Application&#160;receive buffer of this message.&#160;<br/>
<b>Type Of&#160;Object&#160;</b><br/>
Message&#160;<br/>
<b>Value Type&#160;</b><br/>
Integer&#160;<br/>
<b>Default&#160;</b><br/>
-1&#160;<br/>
<b>Minimum&#160;</b><br/>
-1&#160;<br/>
<b>Maximum&#160;</b><br/>
8&#160;<br/>
&#160;<br/>
<b>10.2&#160;&#160;Automatic Configuration by&#160;GENy&#160;<br/></b>Using the Generation&#160;Tool GENy the configuration can be done by&#160;the tool.&#160;The&#160;<br/>configuration options&#160;common&#160;to all CAN Drivers is described here.&#160;The CAN Controller&#160;<br/>dependent options are described in&#160;the CAN Controller specific&#160;user manual.&#160;The following&#160;<br/>dialog describes the CAN Driver common options.&#160;The configuration data is stored by the&#160;<br/>tool in the file can_cfg.h for GENy. &#160;<br/>&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
128&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=129></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-129_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-129_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;<br/>
Figure 10-1&#160;Configuration of the common CAN&#160;Driver options&#160;with GENy&#160;<br/>
&#160;<br/>
<b>Feature&#160;</b><br/>
<b>Explanation&#160;</b><br/>
Common Driver Parameters&#160;<br/>Online/Offline Callback&#160;<br/>
If&#160;CanOnline()&#160;or&#160;CanOffline()&#160;is called the&#160;Application&#160;is&#160;notified that&#160;<br/>
Functions&#160;<br/>
a certain CAN driver state was entered.&#160;<br/>
DLC check&#160;<br/>
The DLC check can be&#160;configured to “disabled”,&#160;comparison of received&#160;<br/>DLC “against data length” or “against&#160;minimum acceptance length”.&#160;<br/>&#160;“against data length” means the number of bytes necessary for the ECU&#160;<br/>and is equal to the length of the application data&#160;buffer. &#160;<br/>The minimum acceptance length can be configured message specific via&#160;<br/>database or on the Rx message view.&#160;<br/>If DLC check is used, received Data messages with smaller DLC than&#160;<br/>expected for this ID are ignored. &#160;<br/>
Data Copy&#160;Mechanism&#160;<br/>
The Data Copy Mechanism can be&#160;configured to “copy number of&#160;<br/>needed bytes” or “copy all received bytes”. &#160;<br/>“copy number of needed bytes” means the CAN driver copies always the&#160;<br/>number of bytes which is equal to the length of the application data&#160;<br/>buffer.&#160;<br/>&#160;“copy all received bytes” means if&#160;the number of received bytes is less&#160;<br/>than the size of the application data&#160;buffer only the received bytes are&#160;<br/>copied. Otherwise the number of bytes which is&#160;equal to the&#160;length of the&#160;<br/>application&#160;data buffer will be copied.&#160;<br/>
RAM check&#160;<br/>
The CAN driver supports&#160;a RAM check of the CAN controller&#160;mailboxes.&#160;<br/>
Sleep / Wakeup&#160;<br/>
If this field is checked, the CAN controller can be&#160;switched to&#160;sleep&#160;<br/>mode.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
129&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=130></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-130_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Feature&#160;</b><br/>
<b>Explanation&#160;</b><br/>
Cancel in Hardware&#160;<br/>
CanCancelTransmit()&#160;and&#160;CanCancelMsgTransmit()&#160;will delete a&#160;<br/>pending request in the&#160;CAN controller hardware.&#160;<br/>
FullCAN Overrun&#160;<br/>
If checked an overrun in the receive FullCAN objects&#160;will be&#160;signaled to&#160;<br/>
Notification&#160;<br/>
the Application.&#160;<br/>
Receive Function&#160;<br/>
The receive function&#160;ApplCanMsgReceived()&#160;is&#160;called by the CAN&#160;<br/>Driver on every reception of a CAN&#160;message after the hardware&#160;<br/>acceptance&#160;filter is passed. Within this callback function the&#160;Application&#160;<br/>may preprocess the received message in any way (ECU specific&#160;<br/>dynamic filtering mechanisms, preprocessing&#160;of the messages, gateway&#160;<br/>functionality...). &#160;<br/>If the callback function&#160;ApplCanMsgReceived()&#160;returns&#160;kCanCopyData,&#160;<br/>the CAN Driver continues to work on&#160;the message received.&#160;<br/>If the callback function returns&#160;kCanNoCopyData, the CAN finishes&#160;<br/>working on the message received.&#160;<br/>The callback function has to be defined by the application.&#160;<br/>
Active / Passive State&#160;<br/>
If this field is checked, the CAN Driver's transmit path can be switched to&#160;<br/>the &#34;Passive&#34; state. In this state no CAN messages are sent to the CAN&#160;<br/>bus.&#160;The transmit request always returns with ”OK”.&#160;<br/>This ”passive” state functionality may be used to localize errors&#160;in a CAN&#160;<br/>bus: If there&#160;are errors in&#160;a CAN bus, and the errors disappear when a&#160;<br/>particular node is switched to passive state, the&#160;scapegoat is found.&#160;The&#160;<br/>Application&#160;must be switched to the&#160;passive state and back to active&#160;<br/>state by an external tester.&#160;<br/>If active/passive state is&#160;enabled, the&#160;CAN Driver is in active state after&#160;<br/>initialization.&#160;<br/>If this field is not selected, the corresponding service functions are&#160;<br/>available but without any effect on the CAN Driver status.&#160;<br/>
Extended Status&#160;<br/>
This is the global checkbox for using hardware status information in the&#160;<br/>CAN Driver&#160;service&#160;CanGetStatus()&#160;or not.&#160;<br/>
Transmit Queue&#160;<br/>
If this field is checked the CAN Driver&#160;is configured to use a transmit&#160;<br/>queue. &#160;<br/>If no transmit queue is used, the&#160;Application&#160;is responsible&#160;to&#160;restart a&#160;<br/>transmit request if it wasn’t accepted&#160;by the CAN Driver. In the case of&#160;<br/>using a transmit queue, a transmit request is almost accepted. But the&#160;<br/>queue does&#160;only store the transmit request of a message. It doesn’t&#160;<br/>store the data to be sent&#160;in any case.&#160;The CAN Driver inserts a transmit&#160;<br/>request to the queue, if no hardware object is available when&#160;<br/>CanTransmit()&#160;is called. On a transmit interrupt, this means&#160;a former&#160;<br/>requested message is transmitted, the CAN Driver checks whether&#160;<br/>transmit requests&#160;are stored in the queue. If so, these requests&#160;are&#160;<br/>removed from&#160;the queue and the transmit request is executed.&#160;The&#160;<br/>search algorithm in the queue is priority based, there is no FIFO&#160;<br/>strategy.&#160;This means the identifier with the lowest&#160;number is removed&#160;<br/>first from the queue.&#160;<br/>
Tx observation&#160;<br/>
This is the global switch&#160;for using the&#160;Tx observe functionality of the&#160;<br/>CAN Driver&#160;or not.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
130&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=131></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-131_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Feature&#160;</b><br/>
<b>Explanation&#160;</b><br/>
Message-Not-Matched&#160;<br/>
This is the global switch&#160;for using the&#160;MsgNotMatched&#160;function of the&#160;<br/>
Function&#160;<br/>
CAN Driver&#160;or not.&#160;<br/>
Overrun&#160;Notification&#160;<br/>
If this field is checked the CAN Driver&#160;is configured to notify the&#160;<br/>Application in case of an&#160;overrun.&#160;<br/>The&#160;Application has to provide an Overrun callback function:&#160;<br/>void&#160;ApplCanOverrun(void)&#160;&#160;/* Overrun in the CAN&#160;Controller */ &#160;<br/>The overrun handling itself is done by&#160;the CAN&#160;Driver.&#160;<br/>
Hardware Loop Check&#160;<br/>
This is the global switch&#160;for using the&#160;hardware loop check of&#160;the CAN&#160;<br/>Driver or not.&#160;<br/>
Partial Offline Mode&#160;<br/>
If the checkbox “Use PartOffline Functionality” is&#160;checked, the partial&#160;<br/>offline mode&#160;is available.&#160;&#160;<br/>
Generic Pre-copy &#160;<br/>
This checkbox enables&#160;the use of the generic precopy function –&#160;<br/>ApplCanGenericPrecopy().&#160;This precopy function is common to all&#160;<br/>receive messages. it will be called as&#160;soon as the receive handle is&#160;<br/>determined.&#160;<br/>
CAN Copy&#160;from &amp; to CAN&#160;&#160;This checkbox enables the use of copy functions&#160;CopyFromCan()&#160;and&#160;<br/>
CopyToCan().&#160;<br/>
CAN cancel Notification&#160;<br/>
The application will be notified via&#160;ApplCanCancelNotification()&#160;if a&#160;<br/>message is&#160;canceled and therefore confirmation will occur.&#160;This is valid&#160;<br/>for messages which have been requested via&#160;CanTransmit().&#160;<br/>
CAN Interrupt Control&#160;<br/>
There are two call back functions for the application. Within&#160;<br/>
Callbacks&#160;<br/>
CanCanInterruptDisable()&#160;the function&#160;<br/>ApplCanAddCanInterruptDisable()&#160;is called and within&#160;<br/>CanCanInterruptRestore()&#160;the function&#160;<br/>ApplCanAddCanInterruptRestore()&#160;is called.&#160;<br/>These two functions have to be used to handle the wake-up interrupt if&#160;<br/>the hardware treats this&#160;interrupt separately or if the Driver runs in&#160;<br/>Polling Mode the polling&#160;tasks have to be disabled.<b>&#160;</b><br/>
Common Confirmation&#160;<br/>
If this field is checked the common confirmation function of the CAN&#160;<br/>
Function&#160;<br/>
Driver is enabled.&#160;<br/>
Offline Modes&#160;<br/>Name of Mode X&#160;<br/>
with X&#160;= 0..7. &#160;<br/>If the partial&#160;Offline Mode is enabled&#160;the name of each send&#160;group can&#160;<br/>be configured here.&#160;<a href="TechnicalReference_CANDrivers.html#35">more...</a>&#160;<br/>
Default Mapping&#160;<br/>Message Class 0&#160;<br/>
All messages with don’t&#160;belong to an&#160;other class&#160;are assigned to this&#160;<br/>class.&#160;<br/>
OfflineModeX&#160;<br/>
with X&#160;= 0..7. &#160;<br/>The message class&#160;0 can be assigned to certain&#160;Offline Modes (send&#160;<br/>goups) by selecting the&#160;check box.&#160;<br/>
Message Class 1 (Appl)&#160;<br/>
All application messages are assigned to this message class.&#160;<br/>
OfflineModeX&#160;<br/>
with X&#160;= 0..7. &#160;<br/>The message class&#160;1 can be assigned to certain&#160;Offline Modes (send&#160;<br/>goups) by selecting the&#160;check box.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
131&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=132></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-132_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Feature&#160;</b><br/>
<b>Explanation&#160;</b><br/>
Message Class 2 (NM)&#160;<br/>
All network mangement&#160;messages are assigned&#160;to this message class.&#160;<br/>
OfflineModeX&#160;<br/>
with X&#160;= 0..7. &#160;<br/>The message class&#160;2 can be assigned to certain&#160;Offline Modes (send&#160;<br/>goups) by selecting the&#160;check box.&#160;<br/>
Message Class 3 (TP)&#160;<br/>
All transport&#160;layer messages are assigned to this message&#160;class.&#160;<br/>
OfflineModeX&#160;<br/>
with X&#160;= 0..7. &#160;<br/>The message class&#160;3 can be assigned to certain&#160;Offline Modes (send&#160;<br/>goups) by selecting the&#160;check box.&#160;<br/>
Message Class 4 (Diag)&#160;<br/>
All diagnostic messages are assigned to this message class.&#160;<br/>
OfflineModeX&#160;<br/>
with X&#160;= 0..7. &#160;<br/>The message class&#160;4 can be assigned to certain&#160;Offline Modes (send&#160;<br/>goups) by selecting the&#160;check box.&#160;<br/>
Message Class 5 (IL)&#160;<br/>
All interaction layer messages are assigned to this message class.&#160;<br/>
OfflineModeX&#160;<br/>
with X&#160;= 0..7. &#160;<br/>The message class&#160;5 can be assigned to certain&#160;Offline Modes (send&#160;<br/>goups) by selecting the&#160;check box.&#160;<br/>
OSEK OS&#160;<br/>Use OsekOS Interrupt Cat&#160;&#160;In case of using OSEK-OS the interrupt category of the CAN Driver&#160;<br/>2&#160;<br/>
interrupts have to be defined. Normally category 1 is used. Instead of&#160;<br/>this category 2 can be selected.&#160;<br/>
OSEK&#160;OS&#160;<br/>
If this field is checked the CAN Driver is configured to support OSEK-<br/>OS.&#160;The kind of OSEK-OS depends on the specific microprocessor.&#160;<br/>
Polling&#160;<br/>Polling type&#160;<br/>
The polling type can be switched between “None”, “Type specific” and&#160;<br/>“individual”.&#160;<br/>Individual:&#160;&#160;&#160;If enabled,&#160;each BasicCAN, Normal&#160;Tx, Low level&#160;Tx and&#160;<br/>FullCAN can be selected to be polled individual&#160;<br/>
Rx Basic CAN Polling&#160;<br/>
Normally the CAN driver works interrupt driven.&#160;To use the reception via&#160;<br/>Basic CAN objects&#160;in polling mode, check&#160;this field.&#160;This field is available&#160;<br/>in “Type specific polling&#160;mode”.&#160;<br/>
Rx Full CAN&#160;Polling&#160;<br/>
Normally the CAN driver works interrupt driven.&#160;To use the reception via&#160;<br/>Full CAN objects&#160;in polling mode, check&#160;this field.&#160;This field is available&#160;<br/>in “Type specific polling&#160;mode”.&#160;<br/>
Tx Polling&#160;<br/>
Normally the CAN driver works&#160;interrupt driven.&#160;To use the transmission&#160;<br/>in polling mode, check this field.&#160;This field is available in “Type specific&#160;<br/>polling mode”.&#160;<br/>
Wakeup Polling&#160;<br/>
Normally the CAN driver works interrupt driven.&#160;To use the&#160;wake up&#160;<br/>detection in&#160;polling mode, check this field. &#160;<br/>
CAN&#160;Status Polling&#160;<br/>
Normally the CAN driver&#160;works interrupt driven.&#160;To use the Status and&#160;<br/>Error detection in polling&#160;mode, check this field.&#160;<br/>
Low Level&#160;Transmission&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
132&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=133></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-133_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Feature&#160;</b><br/>
<b>Explanation&#160;</b><br/>
Cancel Notification&#160;<br/>
The application will be notified if a message is&#160;canceled and therefore&#160;<br/>
Function&#160;<br/>
confirmation will occur.&#160;This is valid&#160;if&#160;the transmission has been&#160;<br/>requested via&#160;CanMsgTransmit().&#160;<br/>
Enable Low Level&#160;<br/>
If the checkbox “Use Low Level Message&#160;Transmit” is checked, the&#160;<br/>
Transmission&#160;<br/>
function&#160;CanMsgTransmit()&#160;can be&#160;used.&#160;<br/>
Confirmation Function&#160;<br/>
This checkbox is only available, if&#160;“use Low Level Message&#160;Transmit” is&#160;<br/>active.&#160;The&#160;confirmation and init callback functions of low level transmit&#160;<br/>functionality can be activated by this checkbox.&#160;<br/>
API&#160;<br/>Symbolic Names for&#160;<br/>
If the database allows the assignment of value tables to individual&#160;<br/>
Signal Values&#160;<br/>
signals,&#160;this&#160;feature is selectable. If this functionality is enabled, symbolic&#160;<br/>names for values are generated for all signals that have an associated&#160;<br/>value table&#160;<br/>
Indexed Component&#160;<br/>
This switch&#160;determines whether the component should configure the&#160;<br/>indexed or non-indexed version of the driver component.&#160;<br/>
General Settings&#160;<br/>Security level&#160;<br/>
This is the define value to configure the security level. Valid values are 0,&#160;<br/>10, 20 or 30<a href="TechnicalReference_CANDrivers.html#1">.&#160;more...&#160;</a><br/>
User Config File&#160;<br/>
The CAN Driver configuration file (can_cfg.h) is generated. If&#160;the user&#160;<br/>wants to overwrite this&#160;automatically generated configuration file, the&#160;<br/>user is able&#160;to define the&#160;name of a user defined&#160;configuration file which&#160;<br/>is included at the end of the generated file can_cfg.h.&#160;This means entries&#160;<br/>in the user defined configuration file&#160;overwrite the entries in&#160;can_cfg.h.&#160;<br/>
Debug Suport&#160;<br/>Assertions&#160;<br/>
There are different groups&#160;of&#160;assertions supported by the CAN Driver.&#160;<br/>They can be selected depending of the development phase:&#160;<br/><b>None</b>: No debug functionality active.&#160;&#160;<br/><b>User</b>: User&#160;API is debugged.&#160;The CAN Driver service function&#160;<br/>parameters are&#160;checked.&#160;&#160;&#160;<br/><b>Hardware</b>:&#160;The CAN Controller interface is&#160;checked. Depends on CAN&#160;<br/>Controller.&#160;<br/><b>Gen</b>:&#160;The configuration data are checked.&#160;<br/><b>Internal</b>: CAN Driver internal checking.&#160;<br/>
Dynamic Tx&#160;Objects&#160;<br/>ID&#160;<br/>
If the checkbox “ID” is checked, the&#160;IDs of the dynamic transmit objects&#160;<br/>can be changed by the service function&#160;CanDynTxObjSetId()&#160;and/or by&#160;<br/>the service function&#160;CanDynTxObjSetExtId().&#160;The last mentioned&#160;<br/>service function is only available if&#160;extended ID addressing is checked&#160;in&#160;<br/>the Generation&#160;Tool.&#160;<br/>
DLC&#160;<br/>
If the checkbox “DLC” is&#160;checked, the DLC of the dynamic transmit&#160;<br/>objects&#160;can&#160;be changed&#160;by the service function&#160;CanDynTxObjSetDlc.&#160;<br/>
Data Pointer&#160;<br/>
If the checkbox “Data Pointer” is checked, the data pointers&#160;of the&#160;<br/>dynamic transmit objects&#160;can be changed by the service function&#160;<br/>CanDynTxObjSetDataPtr().&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
133&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=134></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-134_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Feature&#160;</b><br/>
<b>Explanation&#160;</b><br/>
Confirmation&#160;<br/>
If the checkbox “Confirmation” is checked, the&#160;confirmation function of&#160;<br/>the dynamic transmit objects&#160;can be&#160;changed by the service function&#160;<br/>CanDynTxObjSetConfirmationFct().&#160;The occurrence of this switch is&#160;<br/>CAN Controller dependent.&#160;<br/>
Pre-transmit&#160;<br/>
If the checkbox “Pre-transmit” is checked, the pretransmit function of the&#160;<br/>dynamic transmit objects&#160;can be changed by the service function&#160;<br/>CanDynTxObjSetPreTransmitFct().The occurrence of this&#160;switch is&#160;<br/>CAN Controller dependent.&#160;<br/>
ID Search&#160;Algorithm&#160;<br/>Search&#160;Algorithm&#160;<br/>
For a Basic&#160;CAN Controller or the Basic CAN object of a Full CAN&#160;<br/>Controller the hardware acceptance&#160;filtering provided by the CAN&#160;<br/>Controller is not sufficient.&#160;Therefore a software acceptance&#160;filtering has&#160;<br/>to be supported by comparing the incoming message identifier with the&#160;<br/>complete list&#160;of all relevant message identifier. Here could the&#160;way how&#160;<br/>to search in&#160;the table of the receive messages be defined.&#160;The optimum&#160;<br/>algorithm depends on the number of the received messages to search in&#160;<br/>and their identifier structure.&#160;The supported search algorithms are&#160;<br/>dependent of the CAN Driver and the hardware. Refer to the CAN&#160;<br/>controller specific documenation&#160;<br/>TechnicalReference_CAN_&lt;hardware&gt;.pdf [#hw_feature] for more&#160;<br/>information.&#160;<br/>
&#160;&#160;linear&#160;<br/>
&#160;&#160;hash search&#160;<br/>
&#160;&#160;index search&#160;<br/>
&#160;&#160;table search&#160;&#160;<br/>
Additional Memory [Byes]&#160;&#160;This shows the byte consumption when&#160;<b>hash search</b>&#160;is selected. It is&#160;<br/>
just for information.&#160;<br/>
Maximum&#160;Search Steps&#160;<br/>
This is only activated when&#160;<b>hash search</b>&#160;is selected. Enter&#160;here the&#160;<br/>amount of maximum search steps that are necessary to find the received&#160;<br/>message ID in the list of&#160;to be received messages.&#160;The little this value&#160;<br/>the greater the additional memory bytes and the faster the receive ISR. &#160;<br/>
Rx Queue&#160;<br/>Overrun&#160;Notification&#160;<br/>
The&#160;Application is informed, if the Rx Queue is full and a new&#160;message&#160;<br/>should be copied into the Queue.&#160;The new message will be lost.&#160;<br/>
Enable Rx&#160;Queue&#160;<br/>
If the checkbox “Enable Rx&#160;Queue” is checked, the RX&#160;Queue is&#160;<br/>enabled. Else the Rx Queue is disabled.&#160;<br/>
Pre Rx&#160;Queue Function&#160;<br/>
If the checkbox “Pre Rx&#160;Queue Function” is checked, a Callback function&#160;<br/>is enabled where the application&#160;could decide what should happen with&#160;<br/>the CAN Message which&#160;was received.&#160;The two possibilities are to store&#160;<br/>the message in the queue, or to process the message in the&#160;interrupt.&#160;<br/>
Number of queued Rx&#160;<br/>
Specifies the depth of the queue (&#34;Number of queued Rx messages&#34;).&#160;<br/>
Messages&#160;<br/>&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
134&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=135></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-135_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-135_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;<br/>
Figure 10-2&#160;Channel Specific Configuration for&#160;GENy&#160;<br/>
&#160;<br/>
<b>Features&#160;</b><br/>
<b>Explanation&#160;</b><br/>
Configuration Options&#160;<br/>General Settings&#160;<br/>Bus System&#160;Type&#160;<br/>
Each channel is configured for a specific type of&#160;bus&#160;<br/>system.&#160;The bus system is always CAN for CAN Driver.&#160;<br/>
Manufacturer&#160;<br/>
Manufacturer with is specified in&#160;the&#160;database file for this&#160;<br/>channel.&#160;<br/>
Common Driver Parameters&#160;<br/>Multiple Basic CAN&#160;<br/>Enable Multiple Basic&#160;<br/>
If checked,&#160;the number of Basic CAN objects&#160;can be&#160;<br/>
CAN&#160;<br/>
selected.&#160;The deselecting of this checkbox resets&#160;the&#160;<br/>number of Basic CAN objects&#160;to the&#160;default.&#160;<br/>
Number Of&#160;BasicCAN&#160;<br/>
Enter number of needed Basic CAN objects. Each Basic&#160;<br/>
Objects&#160;<br/>
CAN object may consist of 2 hardware mailboxes.&#160;This&#160;<br/>depends on&#160;the CAN controller.&#160;<br/>
Ranges / Range Precopy Functions&#160;<br/>Range&#160;<br/>
Ranges are normally used for Network Management,&#160;<br/>Transport Protocol and so on.&#160;There&#160;are in maximum 4&#160;<br/>ranges configurable.&#160;<br/>
Mask&#160;<br/>
Acceptance&#160;mask of this identifier range.&#160;<br/>
Code&#160;<br/>
Acceptance&#160;code of this&#160;identifier range.&#160;<br/>
Precopy function&#160;<br/>
Specific precopy function for this range.&#160;<br/>
Extended IDs&#160;<br/>
The range can be specified to receive extended IDs. If not&#160;<br/>selected, this&#160;range will&#160;receive standard IDs.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
135&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=136></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-136_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-136_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
Use Own Filter&#160;<br/>
If there are&#160;enough Basic CAN filters available, one Basic&#160;<br/>CAN filter can be used&#160;exclusive for this range.&#160;<br/>
Use Rx&#160;Queue&#160;<br/>
All messages which are&#160;received by this range can be&#160;<br/>configured to be handled via the Rx&#160;Queue.&#160;This is only&#160;<br/>possible,&#160;if the feature Rx Queue is activated.&#160;<br/>
Dynamic Tx&#160;objects&#160;<br/>Number of dynamic&#160;Tx&#160;<br/>
Maximum number of dynamic send&#160;objects&#160;which are&#160;<br/>
objects&#160;<br/>
available at&#160;run time.&#160;<br/>
&#160;<br/>&#160;<br/>
&#160;<br/>
Figure 10-3&#160;Configuration of&#160;individual polling with&#160;GENy&#160;<br/>
&#160;<br/>
<b>Features&#160;</b><br/>
<b>Explanation&#160;</b><br/>
Configuration Options&#160;<br/>Enable Polling&#160;<br/>
If checked,&#160;the associated mailbox will be handled in&#160;<br/>polling mode.&#160;This is only selectable, if the polling mode is&#160;<br/>configured to individual&#160;polling.&#160;<br/>
&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
136&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=137></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-137_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-137_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;<br/>
Figure 10-4&#160;Configuration of&#160;a&#160;Tx message&#160;with GENy&#160;<br/>
<b>Features&#160;</b><br/>
<b>Explanation&#160;</b><br/>
Configuration Options&#160;<br/>Message / Frame Properties&#160;<br/>Generate&#160;<br/>
If unchecked, the generation of this&#160;message will be&#160;<br/>suppressed.&#160;<br/>
Common Driver Parameters&#160;<br/>Signal&#160;Access Macros&#160;<br/>
Signal access macros can be used&#160;by the application for&#160;<br/>an easy access to signals specified&#160;within a message.&#160;<br/>
Offline Modes&#160;<br/>&lt;Part offline&#160;group&gt;/&lt;Mode X&#160;name&gt;&#160;<br/>Usage&#160;<br/>
Standard: configuration&#160;via default mapping&#160;<br/>User Defined: the user can set or reset the “Real Value”&#160;<br/>
Real Value&#160;<br/>
It set, the message belongs to this group and the&#160;<br/>transmission of this message will be disabled&#160;if&#160;this group&#160;<br/>is switched&#160;offline.&#160;<br/>
Flags&#160;<br/>Confirmation Flag&#160;<br/>
After successful transmission of a message the&#160;driver sets&#160;<br/>the confirmation flag of the message.&#160;<br/>
Functions&#160;<br/>Confirmation Function&#160;<br/>
After successful transmission of a message the&#160;driver call&#160;<br/>the user defined confirmation function of the message.&#160;The&#160;<br/>name of this function has to be specified in this field.&#160;<br/>
Pretransmit Function&#160;<br/>
The used defined pretransmit function can be called before&#160;<br/>the transmission of a message is started.&#160;The name of this&#160;<br/>function has to be specified in this field.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
137&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=138></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-138_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-138_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
Full CAN&#160;Tx&#160;<br/>Tx FullCAN&#160;<br/>
A&#160;Tx message can be assigned to a&#160;Full CAN objects.&#160;<br/>
&#160;<br/>
&#160;<br/>
Figure 10-5&#160;Configuration of&#160;an Rx message with&#160;GENy&#160;<br/>
<b>Features&#160;</b><br/>
<b>Explanation&#160;</b><br/>
Configuration Options&#160;<br/>Message / Frame Properties&#160;<br/>Generate&#160;<br/>
If unchecked, the generation of this&#160;message will be&#160;<br/>suppressed.&#160;<br/>
Common Driver Parameters&#160;<br/>Minimum Data&#160;Length&#160;<br/>
&#160;<br/>
Signal Access&#160;Macros&#160;<br/>
Signal access macros can be used&#160;by the application for&#160;<br/>an easy access to signals specified&#160;within a message.&#160;<br/>
Flags&#160;<br/>Indication Flag&#160;<br/>
After successful reception of a message the driver sets&#160;the&#160;<br/>indication&#160;flag of the message&#160;<br/>
Functions&#160;<br/>Indication Function&#160;<br/>
The name of the used defined indication function can be&#160;<br/>specified&#160;in this field.&#160;<br/>
Precopy Function&#160;<br/>
The name of the used defined precopy function can be&#160;<br/>specified&#160;in this field.&#160;<br/>
Full CAN&#160;<br/>Full CAN&#160;<br/>
An Rx&#160;message can be&#160;assigned to&#160;a Full CAN objects.&#160;<br/>
Lock Full CAN&#160;<br/>
If set, the assignment of a Rx&#160;message to a Full&#160;CAN&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
138&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=139></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-139_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-139_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
object cannot be changes by the filter optimization.&#160;<br/>
Hardware Channel&#160;<br/>
In case a receive message is configured to be ‘FullCAN’&#160;<br/>and Common CAN is activated then the user can&#160;configure&#160;<br/>this message to be received on the first (Channel&#160;A) or the&#160;<br/>second (Channel B) CAN controller&#160;on this channel.&#160;<br/>
&#160;<br/>&#160;<br/>
<b>10.3&#160;&#160;Automatic Configuration by&#160;CANgen&#160;<br/></b>Using the Generation&#160;Tool CANgen the configuration can be done&#160;by the tool.&#160;The&#160;<br/>configuration options&#160;common&#160;to all CAN Drivers is described here.&#160;The CAN Controller&#160;<br/>dependent options are described in&#160;the CAN Controller specific&#160;user manual.&#160;The following&#160;<br/>dialog describes the CAN Driver common options.&#160;The configuration data is stored by the&#160;<br/>tool in the file can_cfg.h for CANgen. &#160;<br/>&#160;<br/>
&#160;<br/>
Figure 10-6&#160;CAN Driver configuration tab&#160;<br/>
&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
139&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=140></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-140_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Feature&#160;</b><br/>
<b>Explanation&#160;</b><br/>
&#160;<br/>Path of the CAN config file&#160;&#160;The CAN Driver configuration file (can_cfg.h) is generated. If&#160;the user&#160;<br/>
wants to overwrite this&#160;automatically generated configuration file, the&#160;<br/>user is able&#160;to define the&#160;name of a user defined&#160;configuration file which&#160;<br/>is included at the end of the generated file can_cfg.h.&#160;This means entries&#160;<br/>in the user defined configuration file&#160;overwrite the entries in&#160;can_cfg.h.&#160;<br/>
Use Receive Function&#160;<br/>
The receive function&#160;ApplCanMsgReceived()&#160;is&#160;called by the CAN&#160;<br/>
(ApplCanMsgReceived)&#160;<br/>
Driver on every reception of a CAN&#160;message after the hardware&#160;<br/>acceptance&#160;filter is passed. Within this callback function the&#160;Application&#160;<br/>may preprocess the received message in any way (ECU specific&#160;<br/>dynamic filtering mechanisms, preprocessing&#160;of the messages, gateway&#160;<br/>functionality...). &#160;<br/>If the callback function&#160;ApplCanMsgReceived()&#160;returns&#160;kCanCopyData,&#160;<br/>the CAN Driver continues to work on&#160;the message received.&#160;<br/>If the callback function returns&#160;kCanNoCopyData, the CAN finishes&#160;<br/>working on the message received.&#160;<br/>
Support Active/Passive&#160;<br/>
If this field is checked, the CAN Driver's transmit path can be switched to&#160;<br/>
State&#160;<br/>
the &#34;Passive&#34; state. In this state no CAN messages are sent to the CAN&#160;<br/>bus.&#160;The transmit request always returns with ”OK”.&#160;<br/>This ”passive” state functionality may be used to localize errors&#160;in a CAN&#160;<br/>bus: If there&#160;are errors in&#160;a CAN bus, and the errors disappear when a&#160;<br/>particular node is switched to passive state, the&#160;scapegoat is found.&#160;The&#160;<br/>Application&#160;must be switched to the&#160;passive state and back to active&#160;<br/>state by an external tester.&#160;<br/>If active/passive state is&#160;enabled, the&#160;CAN Driver is in active state after&#160;<br/>initialization.&#160;<br/>
Use&#160;Transmit Queue&#160;<br/>
If this field is checked the CAN Driver&#160;is configured to use a transmit&#160;<br/>queue. &#160;<br/>If no transmit queue is used, the&#160;Application&#160;is responsible&#160;to&#160;restart a&#160;<br/>transmit request if it wasn’t accepted&#160;by the CAN Driver. In the case of&#160;<br/>using a transmit queue, a transmit request is almost accepted. But the&#160;<br/>queue does&#160;only store the transmit request of a message. It doesn’t&#160;<br/>store the data to be sent&#160;in any case.&#160;The CAN Driver inserts a transmit&#160;<br/>request to the queue, if no hardware object is available when&#160;<br/>CanTransmit()&#160;is called. On a transmit interrupt, this means&#160;a former&#160;<br/>requested message is transmitted, the CAN Driver checks whether&#160;<br/>transmit requests&#160;are stored in the queue. If so, these requests&#160;are&#160;<br/>removed from&#160;the queue and the transmit request is executed.&#160;The&#160;<br/>search algorithm in the queue is priority based, there is no FIFO&#160;<br/>strategy.&#160;This means the identifier with the lowest&#160;number is removed&#160;<br/>first from the queue.&#160;<br/>
Support for OSEK&#160;OS&#160;<br/>
If this field is checked&#160;the CAN Driver is configured to support OSEK-<br/>OS.&#160;The kind of OSEK-OS depends on the specific microprocessor.&#160;<br/>
Use OsekOS Interrupt Cat&#160;&#160;In case of using OSEK-OS the interrupt category of the CAN Driver&#160;<br/>2&#160;<br/>
interrupts have to be defined. Normally category 1 is used. Instead of&#160;<br/>this category 2 can be selected.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
140&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=141></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-141_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Feature&#160;</b><br/>
<b>Explanation&#160;</b><br/>
Support Overrun&#160;<br/>
If this field is checked the CAN Driver&#160;is configured to notify the&#160;<br/>
Notification&#160;<br/>
Application in case of an&#160;overrun.&#160;<br/>The&#160;Application has to provide an Overrun callback function:&#160;<br/>void&#160;ApplCanOverrun(void)&#160;&#160;/* Overrun in the CAN&#160;Controller */ &#160;<br/>The overrun handling itself is done by&#160;the CAN&#160;Driver:&#160;<br/>
Security Level&#160;<br/>
This is the define value to configure the security level. Valid values are&#160;<br/>0,10, 20 or&#160;30.&#160;<br/>
Extended Status&#160;<br/>
This is the global checkbox for using hardware status information in the&#160;<br/>CAN Driver&#160;service&#160;CanGetStatus()&#160;or not.&#160;<br/>
Debug level&#160;<br/>
There are different Debug Levels supported by the CAN Driver:&#160;<br/>None: No debug functionality active.&#160;&#160;<br/>User: User&#160;API is debugged.&#160;The CAN Driver service function&#160;<br/>parameters are&#160;checked.&#160;&#160;&#160;<br/>Hardware:&#160;The CAN Controller interface is checked. Depends on CAN&#160;<br/>Controller.&#160;<br/>Gen:&#160;The configuration data are checked.&#160;<br/>Internal: CAN Driver internal checking (consistency of transmit queue).&#160;<br/>
Extended IDs&#160;<br/>
This checkbox is available only if extended CAN&#160;identifiers&#160;are selected&#160;<br/>in the channel configuration dialog. It&#160;has to be enabled if extended CAN&#160;<br/>identifiers&#160;have to be received by the range specific acceptance filtering&#160;<br/>and the appropriate precopy function has to be&#160;called. In&#160;such case no&#160;<br/>standard identifiers can&#160;be received by any acceptance range.&#160;<br/>
Use Range X&#160;<br/>
This is the global switch&#160;to select&#160;identifier range&#160;specific precopy&#160;<br/>functions.&#160;These ranges are normally used for Network Management,&#160;<br/>Transport Protocol and so on.&#160;There&#160;are in maximum 4 ranges&#160;<br/>configurable, where ‘X’&#160;is&#160;the number of the specified range. If a range is&#160;<br/>enabled, the&#160;following additional settings has to be done:&#160;<br/>
Range X&#160;mask&#160;<br/>
Acceptance&#160;code of the identifier range X.&#160;<br/>
Range X&#160;ID&#160;<br/>
Acceptance&#160;mask of the identifier range X.&#160;<br/>
Range X&#160;precopy function&#160;&#160;Specific precopy function for range X.&#160;<br/>Tx observe&#160;<br/>
This is the global switch&#160;for using the&#160;tx observe functionality&#160;of the CAN&#160;<br/>Driver or not.&#160;<br/>
Use MsgNotMatched&#160;<br/>
This is the global switch&#160;for using the&#160;MsgNotMatched&#160;function of the&#160;<br/>
function&#160;<br/>
CAN Driver&#160;or not.&#160;<br/>
Hardware Loop Check&#160;<br/>
This is the global switch&#160;for using the&#160;hardware loop check of&#160;the CAN&#160;<br/>Driver or not.&#160;<br/>
Number of dynamic tx&#160;<br/>
Maximum number of dynamic send&#160;objects&#160;which are available at run&#160;<br/>
objects&#160;&#160;<br/>
time.&#160;<br/>
Dynamic&#160;TxId&#160;<br/>
If the checkbox “DynamicTxId” is checked, the IDs of the dynamic&#160;<br/>transmit objects&#160;can be&#160;changed by the service function&#160;<br/>CanDynTxObjSetId()&#160;and/or by the service function&#160;<br/>CanDynTxObjSetExtId().&#160;The last&#160;mentioned service function is only&#160;<br/>available if extended ID&#160;addressing is checked in&#160;the Generation&#160;Tool.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
141&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=142></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-142_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>Feature&#160;</b><br/>
<b>Explanation&#160;</b><br/>
Dynamic&#160;TxDLC&#160;<br/>
If the checkbox “DynamicTxDLC”&#160;is checked, the DLCs of the dynamic&#160;<br/>transmit objects&#160;can be&#160;changed by the service function&#160;<br/>CanDynTxObjSetDlc().&#160;<br/>
Dynamic&#160;TxDataPtr&#160;<br/>
If the checkbox “DynamicTxDataPtr” is checked,&#160;the data pointers of the&#160;<br/>dynamic transmit objects&#160;can be changed by the service function&#160;<br/>CanDynTxObjSetDataPtr().&#160;The occurrence of this switch&#160;is CAN&#160;<br/>Controller dependent.&#160;<br/>
Dynamic&#160;TxConfirmation&#160;<br/>
If the checkbox “DynamicTxConfirmation” is checked, the confirmation&#160;<br/>function of the dynamic transmit objects&#160;can be&#160;changed by the service&#160;<br/>function&#160;CanDynTxObjSetConfirmationFct().&#160;The occurrence of this&#160;<br/>switch is CAN Controller dependent.&#160;<br/>
Dynamic&#160;TxPreTransmit&#160;<br/>
If the checkbox “DynamicTxPretransmit” is checked, the pretransmit&#160;<br/>function of the dynamic transmit objects&#160;can be&#160;changed by the service&#160;<br/>function&#160;CanDynTxObjSetPreTransmitFct().The occurrence of this&#160;<br/>switch is CAN Controller dependent.&#160;<br/>
Use Low Level Message&#160;<br/>
If the checkbox “Use Low Level Message&#160;Transmit” is checked, the&#160;<br/>
Transmit&#160;<br/>
function&#160;CanMsgTransmit()&#160;can be&#160;used.&#160;<br/>
Use Low Level Message&#160;<br/>
This checkbox is only available, if&#160;“use Low Level Message&#160;Transmit” is&#160;<br/>
Transmit Confirmation&#160;<br/>
active.&#160;The&#160;confirmation and init callback functions of low level transmit&#160;<br/>functionality can be activated by this checkbox.&#160;<br/>
Use PartOffline&#160;<br/>
If the checkbox “Use PartOffline Functionality” is&#160;checked, the partial&#160;<br/>
Functionality&#160;<br/>
offline mode&#160;is available.&#160;&#160;<br/>
Use Generic Precopy&#160;<br/>
This checkbox enables&#160;the use of the generic precopy function –&#160;<br/>ApplCanGenericPrecopy().&#160;This precopy function is common to all&#160;<br/>receive messages. It will be called as&#160;soon as the receive handle is&#160;<br/>determined.&#160;<br/>
&#160;<br/>The next figure shows&#160;the Configuration of&#160;the partial offline mode.&#160;Every transmit&#160;<br/>message can be assigned to up to&#160;eight partial offline groups.&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
142&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=143></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-143_1.png"/><br/>
<img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-143_2.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;<br/>
&#160;Figure 10-7&#160;Configuration of&#160;Partial Offline Mode&#160;<br/>
&#160;<br/>
<b>Feature&#160;</b><br/>
<b>Explanation&#160;</b><br/>
Edit part offline mode&#160;<br/>
this button can be used to change the names of the eight partial offline&#160;<br/>
names&#160;<br/>
groups&#160;<br/>
&#160;<br/>The following features cannot be&#160;configured by the&#160;Application.&#160;They are set automatically&#160;<br/>depending on the used OEM:&#160;<br/>
&#160;&#160;DLC check&#160;<br/>
&#160;&#160;Data&#160;Copy Mechanism&#160;<br/>
&#160;&#160;Cancel&#160;in Hardware&#160;<br/>
&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
143&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=144></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-144_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
&#160;<br/>
<b>10.4&#160;&#160;Manual configuration via user configuration file&#160;<br/></b>This chapter describes additional configuration&#160;options for special features which can only&#160;<br/>be configured via user configuration file.&#160;<br/>In the following table you will find a list of&#160;configuration switches, used to control the&#160;<br/>functional units of the CAN Driver:&#160;<br/>&#160;<br/>
<b>Switch&#160;</b><br/>
<b>Value / Range&#160;</b><br/>
<b>Use of ...&#160;</b><br/>
C_xxx_APPLCANPREWAKEUP_FCT&#160;&#160;ENABLE, DISABLE&#160;<br/>
Activate call of&#160;ApplCanPreWakeUp() if&#160;<br/>an WakeUp Interrupt occurs.&#160;<br/>
C_xxx_NOTIFY_CORRUPT_MAILBOX ENABLE,&#160;<br/>
DISABLE&#160;&#160;Activate call of &#160;ApplCanCorruptMailbox()&#160;<br/>
in case the CAN RAM Check fails for a&#160;<br/>certain mailbox.&#160;<br/>
&#160;<br/>If the Generation&#160;Tool CANgen is&#160;used, some additional configurations can only be due via&#160;<br/>user configuration file:&#160;<br/>&#160;<br/>
<b>Switch&#160;</b><br/>
<b>Value / Range&#160;</b><br/>
<b>Use of ...&#160;</b><br/>
C_xxx_ONLINE_OFFLINE_CALLBACK&#160;ENABLE, DISABLE&#160;<br/>
Activate call of&#160;ApplCanOnline() and&#160;<br/>
_FCT&#160;<br/>
ApplCanOffline() if the associated CAN&#160;<br/>driver&#160;state was entered.&#160;<br/>
C_xxx_INTCTRL_ADD_CAN_FCT ENABLE,&#160;<br/>
DISABLE&#160;<br/>
Activate call of&#160;<br/>ApplCanAddCanInterruptDisable()&#160;<br/>
and&#160;<br/>ApplCanAddCanInterruptRestore().&#160;<br/>These two functions have&#160;to be used&#160;to&#160;<br/>handle the wake-up interrupt if the&#160;<br/>hardware&#160;treats&#160;this&#160;interrupt separately&#160;<br/>or if the Driver&#160;runs&#160;in Polling Mode the&#160;<br/>polling tasks&#160;have to be disabled.&#160;<br/>
&#160;<br/>&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
144&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=145></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-145_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>11&#160;&#160;Glossary&#160;</b><br/>
<b>Abbreviations and&#160;</b><br/>
<b>Expressions&#160;</b><br/>
<b>Explanation&#160;</b><br/>
Acceptance&#160;filtering&#160;<br/>
Mechanism which decides whether each received protocol frame is&#160;<br/>to be taken into account&#160;by the local&#160;Node or ignored.&#160;<br/>
API Application&#160;<br/>
Program&#160;<br/>
Interface.&#160;<br/>
Application Interface&#160;<br/>
An application interface&#160;is the prescribed method of a SW&#160;<br/>component for using the&#160;available functionality.&#160;<br/>
Arbitration&#160;<br/>
Mechanism which guarantees that a&#160;simultaneous access made by&#160;<br/>multiple stations results in a contention where one frame will&#160;<br/>survive uncorrupted.&#160;<br/>
ASAP Arbeitskreis&#160;<br/>
zur&#160;<br/>
Standardisierung von&#160;Applikationssystemen.&#160;<br/>
Standardization of&#160;Application and Calibration system task force&#160;<br/>
BCD&#160;<br/>
Binary Coded Decimal&#160;<br/>
Buffer&#160;<br/>
A&#160;buffer in a&#160;memory area normally&#160;in the RAM.&#160;It is an area,&#160;the&#160;<br/>application&#160;reserved for data storage&#160;<br/>
Bus&#160;<br/>
Defines what we call internal as channel or connection.&#160;<br/>
BusOff&#160;<br/>
A&#160;node is in&#160;the state bus off when it&#160;is switched&#160;off from the bus&#160;<br/>due to a request of fault&#160;confinement entity. In the bus off state, a&#160;<br/>node can neither send nor receive any frames.&#160;A&#160;node can start the&#160;<br/>recovery from&#160;bus off state only upon a user request.A&#160;node&#160;is in&#160;<br/>the state BusOff when it is switched&#160;off from the bus. In the state&#160;<br/>BusOff a node can neither send nor&#160;receive any protocol frames.&#160;<br/>
Callback function&#160;<br/>
This is a&#160;function provided by an application.&#160;E.g. the CAN&#160;Driver&#160;<br/>calls a&#160;callback function&#160;to allow the&#160;application&#160;to control some&#160;<br/>action, to make decisions&#160;at runtime and to influence the work of&#160;<br/>the Driver.&#160;<br/>
CAN&#160;<br/>
Controller&#160;Area Network protocol originally defined for use as&#160;a&#160;<br/>communication network&#160;for control applications&#160;in vehicles.&#160;<br/>
CAN Controller&#160;<br/>
A&#160;hardware unit integrated into a micro controller (or as a separate&#160;<br/>unit) handling the CAN protocol.&#160;<br/>
CAN Driver&#160;<br/>
The CAN driver encapsulates a specific CAN controller handling. It&#160;<br/>consists&#160;of algorithms for HW initialization, CAN message&#160;<br/>transmission and reception.&#160;The application&#160;interface supports&#160;both&#160;<br/>event and polling notification and WR/RD access to the message&#160;<br/>buffers.&#160;<br/>
Channel&#160;<br/>
A&#160;channel defines the assignment (1:1) between a physical&#160;<br/>communication interface&#160;and a physical layer on&#160;which different&#160;<br/>modules are connected to (either CAN or LIN). 1 channel consists&#160;<br/>of 1..X&#160;network(s).&#160;<br/>
Configuration&#160;<br/>
The communication&#160;configuration adapts the communication stack&#160;<br/>to the specific component requirements by means of the&#160;<br/>Generation Tool.&#160;<br/>
Confirmation&#160;<br/>
A&#160;service primitive defined in the ISO/OSI&#160;Reference model (ISO&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
145&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=146></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-146_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
7498). With&#160;the service&#160;primitive 'confirmation' a service provider&#160;<br/>informs a service user about the result of a preceding service&#160;<br/>request of the service user. Notification by the CAN Driver on&#160;<br/>asynchronous successful transmission of a CAN message.&#160;<br/>
Data consistency&#160;<br/>
Data consistency means that the content of a given application&#160;<br/>message correlates unambiguously to the operation performed&#160;<br/>onto the message by the application.&#160;This means that no&#160;<br/>unforeseen&#160;sequence of&#160;operations&#160;may alter the content of&#160;a&#160;<br/>message hence rendering a message inconsistent with respect to&#160;<br/>its allowed and expected value.&#160;<br/>
DBC&#160;<br/>
CAN database format of the Vector company which is used by&#160;<br/>Vector tools&#160;<br/>
DLC&#160;<br/>
Data Length CodeNumber of data bytes of a CAN message&#160;<br/>
ECU&#160;<br/>
Electronic Control Unit&#160;<br/>
Error&#160;<br/>
Error is a local problem which could&#160;be solved locally. If not, the&#160;<br/>error will be&#160;given as an exception to the application.&#160;An error is not&#160;<br/>the specification conform misbehavior of a system (e.g. a not&#160;<br/>responded diagnostic request after three requests&#160;without&#160;<br/>response is&#160;no error). Discrepancy between a computed, observed&#160;<br/>or measured value or condition and&#160;the true, specified or&#160;<br/>theoretically&#160;correct value or condition (IEC 61508-4).&#160;<br/>
FIFO&#160;<br/>
First In First&#160;Out&#160;<br/>
FILO&#160;<br/>
First In Last&#160;Out&#160;<br/>
Gateway&#160;<br/>
A&#160;gateway is&#160;designed to enable communication between different&#160;<br/>bus systems, e.g. from CAN to LIN.&#160;<br/>
Generation&#160;Tool&#160;<br/>
See CANgen, DBKOMGen and GENy.&#160;The generation tool&#160;<br/>configures the communication stack&#160;based on database attributes&#160;<br/>(vehicle manufacturer),&#160;project settings (module supplier) and&#160;<br/>license information&#160;(Vector).&#160;<br/>
HIS Hersteller-Initiative&#160;<br/>
Software&#160;<br/>
HW Hardware&#160;<br/>ID&#160;<br/>
Identifier (e.g. Identifier&#160;of a CAN message)&#160;<br/>
Indication&#160;<br/>
A&#160;service primitive defined in the ISO/OSI&#160;Reference Model (ISO&#160;<br/>7498). With&#160;the service&#160;primitive 'indication' a&#160;service provider&#160;<br/>informs a service user about the occurrence of either an internal&#160;<br/>event or a service request issued by another service user.&#160;<br/>Notification&#160;of application in case of&#160;events in the Vector software&#160;<br/>components, e.g. an asynchronous reception of&#160;a CAN&#160;message.&#160;<br/>
Interrupt&#160;<br/>
Processor-specific event&#160;which can interrupt the execution of a&#160;<br/>current program section.&#160;<br/>
Interrupt level&#160;<br/>
Processing level provided for time-critical activities.&#160;To&#160;keep the&#160;<br/>interrupt latency brief, only absolutely indispensable actions should&#160;<br/>be effected&#160;in the Interrupt Service Routine, which ensures&#160;<br/>reception of&#160;the interrupt&#160;and trigger its (post) processing within a&#160;<br/>task. Other processing&#160;levels are: Operating System Level and&#160;<br/>Task Level.&#160;<br/>
ISO&#160;<br/>
International Standardization Organization&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
146&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=147></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-147_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
ISR&#160;<br/>
Interrupt Service Routine&#160;<br/>
LIN&#160;<br/>
Local Interconnect Network&#160;<br/>
Manufacturer Vehicle&#160;<br/>
manufacturer&#160;<br/>
Message&#160;<br/>
A&#160;message is responsible for the logical transmission and reception&#160;<br/>of information depending&#160;on the restrictions of the&#160;physical layer.&#160;<br/>The definition of the message contents&#160;is part of the database&#160;<br/>given by the&#160;vehicle manufacturer.&#160;<br/>
MISRA&#160;<br/>
Motor Industry Software Reliability&#160;Association&#160;<br/>
MRC&#160;<br/>
Multiple Receive Channel&#160;<br/>
Network&#160;<br/>
A&#160;network defines the assignment (1:N) between a logical&#160;<br/>communication grouping&#160;and a physical layer on&#160;which different&#160;<br/>modules are connected to (either CAN or LIN). 1 network consists&#160;<br/>of 1 channel,&#160;Y&#160;networks consists&#160;of&#160;1..Z channel(s). We say&#160;<br/>network if we talk about&#160;more than 1 bus.&#160;<br/>
NM Network&#160;<br/>
Management&#160;<br/>
Node&#160;<br/>
A&#160;network topological entity. Nodes are connected by data links&#160;<br/>forming the network. Each node is&#160;separately addressable on the&#160;<br/>network.&#160;<br/>
OEM&#160;<br/>
Original Equipment Manufacturer&#160;<br/>
Offline&#160;<br/>
State of the data link layer. In the Offline state, no application&#160;<br/>communication is possible. Only the network management is&#160;<br/>allowed to communicate.&#160;<br/>
Online&#160;<br/>
(Normal) state of the data link layer.&#160;Application&#160;and Network&#160;<br/>Management communication are possible.&#160;<br/>
OS Operating&#160;<br/>
System&#160;<br/>
OSEK&#160;<br/>
Name of the&#160;overall project:&#160;Abbreviation of the&#160;German term&#160;<br/>&#34;Offene Systeme und deren Schnittstellen fÃ¼r die Elektronik&#160;im&#160;<br/>Kraftfahrzeug&#34; - Open Systems and the Corresponding Interfaces&#160;<br/>for Automotive&#160;Electronics.&#160;<br/>
Overrun&#160;<br/>
Overwriting data in a memory&#160;with limited capacity, e.g. Queued&#160;<br/>message object&#160;<br/>
Platform&#160;<br/>
The sum of micro controller derivative, communication controller&#160;<br/>implementation and compiler is&#160;called platform.&#160;<br/>
RAM Random&#160;<br/>
Access&#160;<br/>
Memory&#160;<br/>
Register&#160;<br/>
A&#160;register is&#160;a memory area in the controller, e.g.&#160;in the CAN&#160;<br/>Controller. Distinguish Register from Buffer&#160;<br/>
RI Reference&#160;<br/>
Implementation&#160;<br/>
ROM Read-Only&#160;<br/>
Memory&#160;<br/>
Signal&#160;<br/>
A&#160;signal is responsible&#160;for the logical transmission and reception of&#160;<br/>information depending on the restrictions of the physical layer.&#160;The&#160;<br/>definition of&#160;the signal&#160;contents is part of the database given by the&#160;<br/>vehicle manufacturer. Signals describe the significance of the&#160;<br/>individual data segments within a message. &#160;Typically bits, bytes or&#160;<br/>words are used for data segments but individual&#160;bit combinations&#160;<br/>are also possible. In the&#160;CAN data base, each data segment is&#160;<br/>assigned a&#160;symbolic name, a value&#160;range, a conversion formula&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
147&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=148></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-148_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
and a physical unit, as&#160;well as a list&#160;of receiving&#160;nodes.&#160;<br/>
SRC&#160;<br/>
Single Receive Channel&#160;<br/>
Status&#160;<br/>
A&#160;status describes the properties (parameters) of an entity.&#160;A&#160;state&#160;<br/>is interpreted as an information, e.g. an error, by the entity which&#160;<br/>uses a status, and is frequently determined by the history.&#160;<br/>
Task Level&#160;<br/>
Processing level where the actual application&#160;software, is&#160;<br/>executed.&#160;Tasks are executed according to the&#160;priority assigned to&#160;<br/>them, and to the selected scheduling policy. Other processing&#160;<br/>levels are: Interrupt level and Operating System&#160;Level.&#160;<br/>
Transceiver&#160;<br/>
A&#160;transceiver adapts the physical layer to the communication&#160;<br/>interface.&#160;<br/>
Vehicle Manufacturer&#160;<br/>
We use this&#160;instead of OEM&#160;<br/>
Watchdog&#160;<br/>
A&#160;monitoring entity.&#160;<br/>
&#160;<br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
148&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name=149></a><img src="ElectricPowerSteering_RH850_GM_T1XX_website/content/en/docs/Can/doc/TechnicalReference_CANDriver-149_1.png"/><br/>
TechnicalReference Vector CAN Driver&#160;<br/>
&#160;<br/>
<b>12&#160;&#160;Contact&#160;</b><br/>
Visit our website for more information on&#160;<br/>&#160;<br/>&gt;&#160; &#160;News&#160;<br/>&gt;&#160; &#160;Products&#160;<br/>&gt;&#160; &#160;Demo software&#160;<br/>&gt;&#160; &#160;Support&#160;<br/>&gt;&#160; &#160;Training data&#160;<br/>&gt;&#160; &#160;Addresses&#160;<br/>&#160;<br/><b>www.vector-informatik.com&#160;</b><br/>
©2010, Vector Informatik GmbH&#160;<br/>
Version: 3.01.01&#160;<br/>
149&#160;/ 149<br/>
based on template&#160;version 2.1&#160;<br/>
<hr/>
<a name="outline"></a><h1>Document Outline</h1>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#2">1 Document Information</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#2">1.1 History</a></li>
<li><a href="TechnicalReference_CANDrivers.html#4">1.2 Reference Documents</a></li>
<li><a href="TechnicalReference_CANDrivers.html#5">1.3 Contents1</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#13">2 About this Document</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#14">2.1 Documents this one refers to…</a></li>
<li><a href="TechnicalReference_CANDrivers.html#14">2.2 Naming Conventions</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#15">3 Reference Implementations</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#15">3.1 Version 1.0</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#15">3.1.1 What's new?</a></li>
<li><a href="TechnicalReference_CANDrivers.html#15">3.1.2 What's changed?</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#16">3.2 Version 1.1</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#16">3.2.1 What's new?</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#16">3.2.1.1 Mandatory (for all CAN Drivers)</a></li>
<li><a href="TechnicalReference_CANDrivers.html#16">3.2.1.2 Optional (for some specific CAN Drivers)</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#16">3.2.2 What's changed?</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#17">3.3 Version 1.2</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#17">3.3.1 What’s new?</a></li>
<li><a href="TechnicalReference_CANDrivers.html#17">3.3.2 What’s changed?</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#17">3.4 Version 1.3</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#17">3.4.1 What’s new?</a></li>
<li><a href="TechnicalReference_CANDrivers.html#17">3.4.2 What’s changed?</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#18">3.5 Version 1.4</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#18">3.5.1 What’s new?</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#18">3.5.1.1 Mandatory (for all CAN Drivers)</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#18">3.5.1.1.1 Common features</a></li>
<li><a href="TechnicalReference_CANDrivers.html#18">3.5.1.1.2 Transmission features</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#18">3.5.1.2 Optional (for some specific CAN Drivers)</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#18">3.5.1.2.1 Transmission features</a></li>
<li><a href="TechnicalReference_CANDrivers.html#18">3.5.1.2.2 Reception features</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#19">3.5.2 What’s changed?</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#19">3.5.2.1 Transmission features</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#19">3.6 Version 1.5</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#19">3.6.1 What’s new?</a></li>
<li><a href="TechnicalReference_CANDrivers.html#20">3.6.2 What’s changed?</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#21">4 Overview</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#22">4.1 Short Summary of the Functional Scope</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#22">4.1.1 Initialization</a></li>
<li><a href="TechnicalReference_CANDrivers.html#22">4.1.2 Transmission</a></li>
<li><a href="TechnicalReference_CANDrivers.html#23">4.1.3 Reception</a></li>
<li><a href="TechnicalReference_CANDrivers.html#23">4.1.4 Bus-Off</a></li>
<li><a href="TechnicalReference_CANDrivers.html#23">4.1.5 Sleep Mode</a></li>
<li><a href="TechnicalReference_CANDrivers.html#23">4.1.6 Special Features</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#24">4.2 Data Structures for CAN Driver Customization</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#25">4.2.1 ROM Data</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#25">4.2.1.1 Initialization Structures</a></li>
<li><a href="TechnicalReference_CANDrivers.html#26">4.2.1.2 Transmit Structures</a></li>
<li><a href="TechnicalReference_CANDrivers.html#26">4.2.1.3 Receive Structures</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#26">4.2.2 RAM Data</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#27">5 Detailed Description of the Functional Scope (Standard)</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#27">5.1 Initialization</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#27">5.1.1 Power-On Initialization of the CAN Driver</a></li>
<li><a href="TechnicalReference_CANDrivers.html#27">5.1.2 Re-Initialization of the CAN Controller</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#27">5.2 Transmission</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#27">5.2.1 Detailed Functional Description</a></li>
<li><a href="TechnicalReference_CANDrivers.html#32">5.2.2 Transmit Queue</a></li>
<li><a href="TechnicalReference_CANDrivers.html#33">5.2.3 Data Copy Mechanisms</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#33">5.2.3.1 Internal</a></li>
<li><a href="TechnicalReference_CANDrivers.html#34">5.2.3.2 User defined (“Pretransmit Function”)</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#34">5.2.4 Notification</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#34">5.2.4.1 Data Interface (Confirmation Flag)</a></li>
<li><a href="TechnicalReference_CANDrivers.html#34">5.2.4.2 Functional Interface (Confirmation Function for each message)</a></li>
<li><a href="TechnicalReference_CANDrivers.html#34">5.2.4.3 Functional Interface (Common Confirmation Function for all messages)</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#35">5.2.5 Offline Mode</a></li>
<li><a href="TechnicalReference_CANDrivers.html#35">5.2.6 Partial Offline Mode</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#36">5.2.6.1 &#160;Partial Offline Mode with GENy</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#39">5.2.7 Passive State</a></li>
<li><a href="TechnicalReference_CANDrivers.html#40">5.2.8 Tx Observe</a></li>
<li><a href="TechnicalReference_CANDrivers.html#41">5.2.9 Cancellation of a Transmission</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#41">5.2.9.1 Cancel a Transmission via CanInit</a></li>
<li><a href="TechnicalReference_CANDrivers.html#41">5.2.9.2 Cancel a Transmission via CanCancelTransmit or CanCancelMsgTransmit</a></li>
<li><a href="TechnicalReference_CANDrivers.html#42">5.2.9.3 Notification about Cancellation of a message</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#43">5.2.10 Overview of Transmit Objects</a></li>
<li><a href="TechnicalReference_CANDrivers.html#43">5.2.11 Normal Transmit Object</a></li>
<li><a href="TechnicalReference_CANDrivers.html#43">5.2.12 Full CAN Transmit Objects</a></li>
<li><a href="TechnicalReference_CANDrivers.html#43">5.2.13 Dynamic Transmit Objects</a></li>
<li><a href="TechnicalReference_CANDrivers.html#45">5.2.14 Priority of Transmit Objects</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#46">5.3 Reception</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#46">5.3.1 Detailed Functional Description</a></li>
<li><a href="TechnicalReference_CANDrivers.html#50">5.3.2 Receive Function</a></li>
<li><a href="TechnicalReference_CANDrivers.html#50">5.3.3 Range-Specific Precopy Functions</a></li>
<li><a href="TechnicalReference_CANDrivers.html#50">5.3.4 Identifier Search Algorithms</a></li>
<li><a href="TechnicalReference_CANDrivers.html#51">5.3.5 DLC check</a></li>
<li><a href="TechnicalReference_CANDrivers.html#51">5.3.6 Data Copy Mechanism</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#51">5.3.6.1 Internal</a></li>
<li><a href="TechnicalReference_CANDrivers.html#52">5.3.6.2 User-defined Precopy Functions</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#52">5.3.7 Notification</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#53">5.3.7.1 Data Interface (Indication Flag)</a></li>
<li><a href="TechnicalReference_CANDrivers.html#53">5.3.7.2 Functional Interface (Indication Function)</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#53">5.3.8 Not-Matched Function</a></li>
<li><a href="TechnicalReference_CANDrivers.html#53">5.3.9 Overrun Handling</a></li>
<li><a href="TechnicalReference_CANDrivers.html#53">5.3.10 Full CAN Overrun Handling</a></li>
<li><a href="TechnicalReference_CANDrivers.html#54">5.3.11 Conditional Message Received</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#54">5.4 Bus-Off Handling</a></li>
<li><a href="TechnicalReference_CANDrivers.html#55">5.5 Sleep Mode</a></li>
<li><a href="TechnicalReference_CANDrivers.html#56">5.6 Special Features</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#56">5.6.1 Status</a></li>
<li><a href="TechnicalReference_CANDrivers.html#57">5.6.2 Stop Mode</a></li>
<li><a href="TechnicalReference_CANDrivers.html#57">5.6.3 Remote Frames</a></li>
<li><a href="TechnicalReference_CANDrivers.html#57">5.6.4 Interrupt Control</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#57">5.6.4.1 Security Level</a></li>
<li><a href="TechnicalReference_CANDrivers.html#58">5.6.4.2 Control of CAN interrupts</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#59">5.6.5 Assertions</a></li>
<li><a href="TechnicalReference_CANDrivers.html#62">5.6.6 Hardware Loop Check</a></li>
<li><a href="TechnicalReference_CANDrivers.html#63">5.6.7 Support of OSEK-Compliant Operating Systems</a></li>
<li><a href="TechnicalReference_CANDrivers.html#63">5.6.8 Multiple-Channel CAN Driver</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#63">5.6.8.1 Indexed CAN Driver</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#63">5.6.9 Standard Polling Mode</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#64">5.6.9.1 Application Hints</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#64">5.6.10 Handling of different identifier types</a></li>
<li><a href="TechnicalReference_CANDrivers.html#65">5.6.11 Copying Mechanisms</a></li>
<li><a href="TechnicalReference_CANDrivers.html#65">5.6.12 Common CAN</a></li>
<li><a href="TechnicalReference_CANDrivers.html#65">5.6.13 Multiple ECU</a></li>
<li><a href="TechnicalReference_CANDrivers.html#65">5.6.14 Signal Access Macros</a></li>
<li><a href="TechnicalReference_CANDrivers.html#66">5.6.15 CAN RAM Check</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#67">6 Detailed Description of the Functional Scope (High End extension)</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#67">6.1 Transmission</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#67">6.1.1 Low-Level Message Transmit</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#67">6.2 Reception</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#67">6.2.1 Multiple Basic CAN</a></li>
<li><a href="TechnicalReference_CANDrivers.html#67">6.2.2 Rx Queue</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#68">6.2.2.1 Handling in Receive Interrupt</a></li>
<li><a href="TechnicalReference_CANDrivers.html#69">6.2.2.2 Handling on Task Level</a></li>
<li><a href="TechnicalReference_CANDrivers.html#70">6.2.2.3 Resetting the Rx Queue &#160;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#71">6.3 Special Features</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#71">6.3.1 Individual Polling</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#72">7 Feature List (Standard and High End)</a></li>
<li><a href="TechnicalReference_CANDrivers.html#75">8 Description of the API (Standard)</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#75">8.1 API Categories</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#75">8.1.1 Single Receive Channel (SRC)</a></li>
<li><a href="TechnicalReference_CANDrivers.html#75">8.1.2 Multiple Receive Channel (MRC)</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#76">8.2 Data Types</a></li>
<li><a href="TechnicalReference_CANDrivers.html#77">8.3 Constants</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#77">8.3.1 Version Number</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#77">8.4 Macros</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#77">8.4.1 Conversion between Logical and Hardware Representation of CAN Parameter DLC</a></li>
<li><a href="TechnicalReference_CANDrivers.html#78">8.4.2 Direct Access to the CAN Controller Registers</a></li>
<li><a href="TechnicalReference_CANDrivers.html#79">8.4.3 Interpretation of the CAN Status</a></li>
<li><a href="TechnicalReference_CANDrivers.html#80">8.4.4 Access to low level transmit structure</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#80">8.5 Functions</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#81">8.5.1 Service Functions</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#81">8.5.1.1 CanInitPowerOn</a></li>
<li><a href="TechnicalReference_CANDrivers.html#81">8.5.1.2 CanInit</a></li>
<li><a href="TechnicalReference_CANDrivers.html#82">8.5.1.3 CanTransmit</a></li>
<li><a href="TechnicalReference_CANDrivers.html#83">8.5.1.4 CanTask</a></li>
<li><a href="TechnicalReference_CANDrivers.html#83">8.5.1.5 CanTxTask</a></li>
<li><a href="TechnicalReference_CANDrivers.html#84">8.5.1.6 CanRxFullCANTask</a></li>
<li><a href="TechnicalReference_CANDrivers.html#84">8.5.1.7 CanRxBasicCANTask</a></li>
<li><a href="TechnicalReference_CANDrivers.html#85">8.5.1.8 CanErrorTask</a></li>
<li><a href="TechnicalReference_CANDrivers.html#85">8.5.1.9 CanWakeUpTask</a></li>
<li><a href="TechnicalReference_CANDrivers.html#86">8.5.1.10 CanOnline</a></li>
<li><a href="TechnicalReference_CANDrivers.html#86">8.5.1.11 CanOffline</a></li>
<li><a href="TechnicalReference_CANDrivers.html#87">8.5.1.12 CanPartOnline</a></li>
<li><a href="TechnicalReference_CANDrivers.html#87">8.5.1.13 CanPartOffline</a></li>
<li><a href="TechnicalReference_CANDrivers.html#88">8.5.1.14 CanGetPartMode&#160;</a></li>
<li><a href="TechnicalReference_CANDrivers.html#88">8.5.1.15 CanGetStatus</a></li>
<li><a href="TechnicalReference_CANDrivers.html#89">8.5.1.16 CanSleep</a></li>
<li><a href="TechnicalReference_CANDrivers.html#90">8.5.1.17 CanWakeUp</a></li>
<li><a href="TechnicalReference_CANDrivers.html#91">8.5.1.18 CanStart</a></li>
<li><a href="TechnicalReference_CANDrivers.html#92">8.5.1.19 CanStop</a></li>
<li><a href="TechnicalReference_CANDrivers.html#92">8.5.1.20 CanGlobalInterruptDisable</a></li>
<li><a href="TechnicalReference_CANDrivers.html#93">8.5.1.21 CanGlobalInterruptRestore</a></li>
<li><a href="TechnicalReference_CANDrivers.html#93">8.5.1.22 CanCanInterruptDisable</a></li>
<li><a href="TechnicalReference_CANDrivers.html#94">8.5.1.23 CanCanInterruptRestore</a></li>
<li><a href="TechnicalReference_CANDrivers.html#94">8.5.1.24 CanSetPassive</a></li>
<li><a href="TechnicalReference_CANDrivers.html#95">8.5.1.25 CanSetActive</a></li>
<li><a href="TechnicalReference_CANDrivers.html#95">8.5.1.26 CanResetBusOffStart</a></li>
<li><a href="TechnicalReference_CANDrivers.html#96">8.5.1.27 CanResetBusOffEnd</a></li>
<li><a href="TechnicalReference_CANDrivers.html#96">8.5.1.28 CanResetBusSleep</a></li>
<li><a href="TechnicalReference_CANDrivers.html#97">8.5.1.29 CanGetDynTxObj</a></li>
<li><a href="TechnicalReference_CANDrivers.html#99">8.5.1.30 CanReleaseDynTxObj</a></li>
<li><a href="TechnicalReference_CANDrivers.html#99">8.5.1.31 CanDynTxObjSetId</a></li>
<li><a href="TechnicalReference_CANDrivers.html#100">8.5.1.32 CanDynTxObjSetExtId</a></li>
<li><a href="TechnicalReference_CANDrivers.html#100">8.5.1.33 CanDynTxObjSetDlc</a></li>
<li><a href="TechnicalReference_CANDrivers.html#101">8.5.1.34 CanDynTxObjSetDataPtr</a></li>
<li><a href="TechnicalReference_CANDrivers.html#101">8.5.1.35 CanCancelTransmit</a></li>
<li><a href="TechnicalReference_CANDrivers.html#101">8.5.1.36 CanCopyFromCan</a></li>
<li><a href="TechnicalReference_CANDrivers.html#102">8.5.1.37 CanCopyToCan</a></li>
<li><a href="TechnicalReference_CANDrivers.html#102">8.5.1.38 CanTxGetActHandle</a></li>
<li><a href="TechnicalReference_CANDrivers.html#103">8.5.1.39 CanResetMsgReceivedCondition</a></li>
<li><a href="TechnicalReference_CANDrivers.html#103">8.5.1.40 CanSetMsgReceivedCondition</a></li>
<li><a href="TechnicalReference_CANDrivers.html#104">8.5.1.41 CanGetMsgReceivedCondition</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#105">8.5.2 User Specific Functions</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#105">8.5.2.1 UserPrecopy</a></li>
<li><a href="TechnicalReference_CANDrivers.html#105">8.5.2.2 UserIndication</a></li>
<li><a href="TechnicalReference_CANDrivers.html#106">8.5.2.3 UserPreTransmit</a></li>
<li><a href="TechnicalReference_CANDrivers.html#106">8.5.2.4 UserConfirmation</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#107">8.5.3 Callback Functions</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#107">8.5.3.1 ApplCanBusOff</a></li>
<li><a href="TechnicalReference_CANDrivers.html#107">8.5.3.2 ApplCanWakeUp</a></li>
<li><a href="TechnicalReference_CANDrivers.html#108">8.5.3.3 ApplCanOverrun</a></li>
<li><a href="TechnicalReference_CANDrivers.html#108">8.5.3.4 ApplCanFullCanOverrun</a></li>
<li><a href="TechnicalReference_CANDrivers.html#109">8.5.3.5 ApplCanMsgReceived</a></li>
<li><a href="TechnicalReference_CANDrivers.html#109">8.5.3.6 ApplCanRangePrecopy</a></li>
<li><a href="TechnicalReference_CANDrivers.html#110">8.5.3.7 ApplCanAddCanInterruptDisable</a></li>
<li><a href="TechnicalReference_CANDrivers.html#110">8.5.3.8 ApplCanAddCanInterruptRestore</a></li>
<li><a href="TechnicalReference_CANDrivers.html#111">8.5.3.9 ApplCanFatalError</a></li>
<li><a href="TechnicalReference_CANDrivers.html#111">8.5.3.10 ApplCanMsgNotMatched</a></li>
<li><a href="TechnicalReference_CANDrivers.html#112">8.5.3.11 ApplCanInit</a></li>
<li><a href="TechnicalReference_CANDrivers.html#113">8.5.3.12 ApplCanTxObjStart</a></li>
<li><a href="TechnicalReference_CANDrivers.html#113">8.5.3.13 ApplCanTxObjConfirmed</a></li>
<li><a href="TechnicalReference_CANDrivers.html#114">8.5.3.14 ApplCanTimerStart</a></li>
<li><a href="TechnicalReference_CANDrivers.html#114">8.5.3.15 ApplCanTimerLoop</a></li>
<li><a href="TechnicalReference_CANDrivers.html#115">8.5.3.16 ApplCanTimerEnd</a></li>
<li><a href="TechnicalReference_CANDrivers.html#115">8.5.3.17 ApplCanGenericPrecopy</a></li>
<li><a href="TechnicalReference_CANDrivers.html#115">8.5.3.18 ApplCanPreWakeup</a></li>
<li><a href="TechnicalReference_CANDrivers.html#116">8.5.3.19 ApplCanTxConfirmation</a></li>
<li><a href="TechnicalReference_CANDrivers.html#117">8.5.3.20 ApplCanMsgDlcFailed</a></li>
<li><a href="TechnicalReference_CANDrivers.html#117">8.5.3.21 ApplCanCancelNotification</a></li>
<li><a href="TechnicalReference_CANDrivers.html#118">8.5.3.22 ApplCanOnline</a></li>
<li><a href="TechnicalReference_CANDrivers.html#118">8.5.3.23 ApplCanOffline</a></li>
<li><a href="TechnicalReference_CANDrivers.html#118">8.5.3.24 ApplCanMsgCondReceived</a></li>
<li><a href="TechnicalReference_CANDrivers.html#119">8.5.3.25 ApplCanMemCheckFailed</a></li>
<li><a href="TechnicalReference_CANDrivers.html#119">8.5.3.26 ApplCanCorruptMailbox</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#121">9 Description of the API (High End extension)</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#121">9.1 Functions</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#121">9.1.1 Service Functions</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#121">9.1.1.1 CanTxObjTask</a></li>
<li><a href="TechnicalReference_CANDrivers.html#122">9.1.1.2 CanRxFullCANObjTask</a></li>
<li><a href="TechnicalReference_CANDrivers.html#122">9.1.1.3 CanRxBasicCANObjTask</a></li>
<li><a href="TechnicalReference_CANDrivers.html#123">9.1.1.4 CanMsgTransmit</a></li>
<li><a href="TechnicalReference_CANDrivers.html#123">9.1.1.5 CanCancelMsgTransmit</a></li>
<li><a href="TechnicalReference_CANDrivers.html#124">9.1.1.6 CanHandleRxMsg</a></li>
<li><a href="TechnicalReference_CANDrivers.html#124">9.1.1.7 CanDeleteRxQueue</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#125">9.1.2 Callback Functions</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#125">9.1.2.1 ApplCanMsgTransmitConf</a></li>
<li><a href="TechnicalReference_CANDrivers.html#125">9.1.2.2 ApplCanMsgTransmitInit</a></li>
<li><a href="TechnicalReference_CANDrivers.html#125">9.1.2.3 ApplCanMsgCancelNotification</a></li>
<li><a href="TechnicalReference_CANDrivers.html#126">9.1.2.4 ApplCanPreRxQueue</a></li>
<li><a href="TechnicalReference_CANDrivers.html#126">9.1.2.5 ApplCanRxQueueOverrun</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#128">10 Configuration (Standard and High End)</a>
<ul>
<li><a href="TechnicalReference_CANDrivers.html#128">10.1 Network Database – Attribute Definition</a></li>
<li><a href="TechnicalReference_CANDrivers.html#128">10.2 Automatic Configuration by GENy</a></li>
<li><a href="TechnicalReference_CANDrivers.html#139">10.3 Automatic Configuration by CANgen</a></li>
<li><a href="TechnicalReference_CANDrivers.html#144">10.4 Manual configuration via user configuration file</a></li>
</ul>
</li>
<li><a href="TechnicalReference_CANDrivers.html#145">11 Glossary</a></li>
<li><a href="TechnicalReference_CANDrivers.html#149">12 Contact</a></li>
</ul>
<hr/>
</body>
</html>
